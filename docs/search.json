[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pocket",
    "section": "",
    "text": "1 Preface\nFilesystem-based caching for expensive Clojure computations",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-this-about",
    "href": "index.html#what-is-this-about",
    "title": "Pocket",
    "section": "What is this about?",
    "text": "What is this about?\nPocket makes it easy to cache expensive function calls to disk and reuse results across sessions. If a computation takes longer than disk I/O, Pocket can help ‚Äî wrap it once, and the result is saved for next time. This is especially useful for data science workflows with expensive intermediate steps that need to survive JVM restarts.\nUnder the hood, Pocket derives cache keys from the function identity and its arguments (so the same computation always maps to the same cache entry), uses Nippy for fast serialization, and provides an in-memory layer backed by core.cache with configurable eviction policies. Concurrent uses of the same computation are thread-safe ‚Äî the computation runs only once.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Pocket",
    "section": "Key features",
    "text": "Key features\n\nLazy evaluation ‚Äî cached returns a deref-able value; computation runs only when needed\nPipeline caching ‚Äî chain cached steps into pipelines with automatic provenance tracking\nStorage policies ‚Äî :mem+disk (default), :mem (no disk I/O), or :none (identity tracking only)\nDAG introspection ‚Äî reconstruct the full computation graph and render it as a flowchart\nThread-safe ‚Äî concurrent uses of the same computation run it exactly once\nConfigurable ‚Äî cache directory, eviction policy, and storage mode via pocket.edn, environment variables, or code",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#general-info",
    "href": "index.html#general-info",
    "title": "Pocket",
    "section": "General info",
    "text": "General info\n\n\n\nWebsite\nhttps://scicloj.github.io/pocket/\n\n\nSource\n\n\n\nDeps\n\n\n\nLicense\nMIT\n\n\nStatus\nüõ†alphaüõ†",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#quick-example",
    "href": "index.html#quick-example",
    "title": "Pocket",
    "section": "Quick example",
    "text": "Quick example\n(require '[scicloj.pocket :as pocket])\n\n(pocket/set-base-cache-dir! \"/tmp/my-cache\")\n\n(defn expensive-calculation [x y]\n  (Thread/sleep 5000)\n  (+ x y))\n\n;; Create a lazy cached computation\n(def result (pocket/cached #'expensive-calculation 10 20))\n\n@result  ;; =&gt; 30 (computes and caches ‚Äî takes 5 seconds)\n@result  ;; =&gt; 30 (loads from cache ‚Äî instant)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#discussion",
    "href": "index.html#discussion",
    "title": "Pocket",
    "section": "Discussion",
    "text": "Discussion\nThe best places to discuss this project are:\n\na topic thread under the #data-science channel at the Clojurians Zulip (more about chat channels here)\n\nIt is highly recommended to create separate topics for separate questions.\n\na github issue",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Pocket",
    "section": "License",
    "text": "License\nCopyright ¬© 2025-2026 Scicloj\nDistributed under the MIT License ‚Äî see LICENSE.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#chapters-in-this-book",
    "href": "index.html#chapters-in-this-book",
    "title": "Pocket",
    "section": "Chapters in this book",
    "text": "Chapters in this book\n\nGetting Started\nConfiguration\nLogging\nRecursive Caching in Pipelines\nUsage Practices\nReal-World Walkthrough: Weather Analysis Pipeline\nConcurrency\nExtending Pocket\nExample: Machine Learning Workflows\nüöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml\nüöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines\nUnder the hood: cache keys\nDeveloping Pocket\nAPI Reference\n\n\nsource: notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html",
    "href": "pocket_book.getting_started.html",
    "title": "2¬† Getting Started",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nPocket is a Clojure library for filesystem-based caching of expensive computations. It persists results to disk so they survive JVM restarts. Cache keys are derived from the function identity and its arguments, so the same computation always maps to the same cache entry.\nFirst, we set up a cache directory and define an expensive computation:\nStart fresh so the examples below run from a clean slate:",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#setup",
    "href": "pocket_book.getting_started.html#setup",
    "title": "2¬† Getting Started",
    "section": "",
    "text": "(ns pocket-book.getting-started\n  (:require\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]))\n\n\n\n(def cache-dir \"/tmp/pocket-demo\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:30.644 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo\n\n\n\n\n\n\"/tmp/pocket-demo\"\n\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:30.645 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo\n\n\n\n\n\n{:dir \"/tmp/pocket-demo\", :existed false}\n\n\n(defn expensive-calculation\n  \"Simulates an expensive computation\"\n  [x y]\n  (println (str \"Computing \" x \" + \" y \" (this is expensive!)\"))\n  (Thread/sleep 400)\n  (+ x y))",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#background-deref-in-clojure",
    "href": "pocket_book.getting_started.html#background-deref-in-clojure",
    "title": "2¬† Getting Started",
    "section": "Background: deref in Clojure",
    "text": "Background: deref in Clojure\nIn Clojure, deref extracts a value from a reference type. It can be written as (deref x) or with the shorthand reader macro @x ‚Äî both are equivalent. Pocket‚Äôs cached returns a Cached object that implements IDeref, so you use @ (or deref) to trigger the computation and retrieve the result.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#creating-a-cached-computation",
    "href": "pocket_book.getting_started.html#creating-a-cached-computation",
    "title": "2¬† Getting Started",
    "section": "Creating a cached computation",
    "text": "Creating a cached computation\ncached creates a lazy cached computation. It returns a Cached object ‚Äî the computation won‚Äôt run until we deref it:\n\n(def cached-result\n  (pocket/cached #'expensive-calculation 10 20))\n\n\n(type cached-result)\n\n\nscicloj.pocket.impl.cache.Cached\n\nFirst deref (computes and caches):\n\n(time @cached-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:30.650 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\"Elapsed time: 401.977817 msecs\"\n\n\n\n\n\n30\n\nSecond deref (loaded from cache, instant):\n\n(time @cached-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.3385 msecs\"\n\n\n\n\n\n30",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#wrapping-functions-with-caching-fn",
    "href": "pocket_book.getting_started.html#wrapping-functions-with-caching-fn",
    "title": "2¬† Getting Started",
    "section": "Wrapping functions with caching-fn",
    "text": "Wrapping functions with caching-fn\nFor convenience, caching-fn wraps a function so that every call returns a Cached object:\n\n(def cached-expensive\n  (pocket/caching-fn #'expensive-calculation))\n\nFirst call:\n\n(time @(cached-expensive 5 15))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.058 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 5 + 15 (this is expensive!)\n\"Elapsed time: 402.068495 msecs\"\n\n\n\n\n\n20\n\nSame args ‚Äî cache hit:\n\n(time @(cached-expensive 5 15))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.438541 msecs\"\n\n\n\n\n\n20\n\nDifferent args ‚Äî new computation:\n\n(time @(cached-expensive 7 8))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.465 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 7 + 8 (this is expensive!)\n\"Elapsed time: 401.948657 msecs\"\n\n\n\n\n\n15",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#nil-handling",
    "href": "pocket_book.getting_started.html#nil-handling",
    "title": "2¬† Getting Started",
    "section": "Nil handling",
    "text": "Nil handling\nPocket properly handles nil values. Since the cache uses files on disk, it needs to distinguish ‚Äúnever computed‚Äù from ‚Äúcomputed and got nil‚Äù. It does this with a special marker file:\n\n(defn returns-nil [] nil)\n\n\n(def nil-result (pocket/cached #'returns-nil))\n\nCached nil value:\n\n(deref nil-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.871 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/returns-nil\n\n\n\n\n\nnil\n\nLoading nil from cache:\n\n(deref nil-result)\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#important-use-vars-or-keywords-for-functions",
    "href": "pocket_book.getting_started.html#important-use-vars-or-keywords-for-functions",
    "title": "2¬† Getting Started",
    "section": "Important: use vars or keywords for functions",
    "text": "Important: use vars or keywords for functions\nAlways pass functions as vars (#'fn-name) or keywords, not as bare function objects. Vars have stable names that produce consistent cache keys across sessions. Keywords are useful for extracting from cached maps (e.g., (cached :train split-c)). Pocket throws an error if you pass a bare function:\n;; ‚úÖ (pocket/cached #'my-function args)\n;; ‚úÖ (pocket/cached :train cached-map)\n;; ‚ùå (pocket/cached my-function args)\nSee the Usage Practices chapter for a detailed explanation and more best practices.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#next-steps",
    "href": "pocket_book.getting_started.html#next-steps",
    "title": "2¬† Getting Started",
    "section": "Next steps",
    "text": "Next steps\n\nConfiguration ‚Äî cache directory, in-memory eviction policies, pocket.edn\nRecursive Caching in Pipelines ‚Äî chaining cached computations\nUsage Practices ‚Äî invalidation strategies, testing, serialization, and more",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#cleanup",
    "href": "pocket_book.getting_started.html#cleanup",
    "title": "2¬† Getting Started",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.876 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo\n\n\n\n\n\n{:dir \"/tmp/pocket-demo\", :existed true}\n\n\nsource: notebooks/pocket_book/getting_started.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html",
    "href": "pocket_book.configuration.html",
    "title": "3¬† Configuration",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nPocket resolves configuration using a precedence chain (for both cache directory and in-memory cache options), from highest to lowest priority:",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#setup",
    "href": "pocket_book.configuration.html#setup",
    "title": "3¬† Configuration",
    "section": "",
    "text": "binding (thread-local override)\nset-*! functions (set-base-cache-dir!, set-mem-cache-options!)\nEnvironment variable (POCKET_BASE_CACHE_DIR, POCKET_MEM_CACHE)\npocket.edn on classpath\nLibrary defaults (pocket-defaults.edn)\n\nflowchart TD\n    B(binding) --&gt;|if nil| S(set-*!)\n    S --&gt;|if nil| E(Environment variable)\n    E --&gt;|if nil| P(pocket.edn)\n    P --&gt;|if nil| D(Hardcoded default)\n    style B fill:#4a9,color:#fff\n    style D fill:#888,color:#fff",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#pocket.edn",
    "href": "pocket_book.configuration.html#pocket.edn",
    "title": "3¬† Configuration",
    "section": "pocket.edn",
    "text": "pocket.edn\nPlace a pocket.edn file on your classpath root for declarative, project-level configuration:\n{:base-cache-dir \"/tmp/my-project-cache\"\n :mem-cache {:policy :lru :threshold 256}}\nIt is re-read on each cache operation (with a 1-second TTL cache), so changes take effect quickly during REPL development. It provides defaults that can be overridden by environment variables, set-*! calls, or binding.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#library-defaults",
    "href": "pocket_book.configuration.html#library-defaults",
    "title": "3¬† Configuration",
    "section": "Library defaults",
    "text": "Library defaults\nPocket ships with pocket-defaults.edn containing the library defaults. These are used when no other configuration is provided:\n\n(-&gt; (clojure.java.io/resource \"pocket-defaults.edn\")\n    slurp\n    clojure.edn/read-string)\n\n\n{:base-cache-dir \".cache/pocket\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\nYou can override any of these via pocket.edn, environment variables, or the set-*! functions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cache-directory",
    "href": "pocket_book.configuration.html#cache-directory",
    "title": "3¬† Configuration",
    "section": "Cache directory",
    "text": "Cache directory\nThe cache directory can be set in several ways.\nEnvironment variable ‚Äî POCKET_BASE_CACHE_DIR:\nexport POCKET_BASE_CACHE_DIR=/path/to/cache\nProgrammatically with set-base-cache-dir!:\n\n(pocket/set-base-cache-dir! \"/tmp/pocket-demo-config\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.910 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-config\n\n\n\n\n\n\"/tmp/pocket-demo-config\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.911 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-config\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-config\", :existed false}\n\nYou can inspect the effective resolved configuration at any time:\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-config\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\nThread-local binding (useful for tests):\n(binding [pocket/*base-cache-dir* \"/tmp/test-cache\"]\n  @(pocket/cached #'my-fn args))",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#in-memory-cache-and-thread-safety",
    "href": "pocket_book.configuration.html#in-memory-cache-and-thread-safety",
    "title": "3¬† Configuration",
    "section": "In-memory cache and thread safety",
    "text": "In-memory cache and thread safety\nPocket maintains an in-memory cache in front of the disk layer, backed by core.cache.\nflowchart LR\n    D(deref) --&gt; MC{In-memory\ncache?}\n    MC --&gt;|hit| R[Return value]\n    MC --&gt;|miss| DC{Disk\ncache?}\n    DC --&gt;|hit| R\n    DC --&gt;|miss| C[Compute] --&gt; W[Write to disk] --&gt; R\nThis provides two benefits:\n\nPerformance ‚Äî repeated derefs of the same computation skip disk I/O entirely (until the entry is evicted from memory).\nThread safety ‚Äî when multiple threads deref the same Cached value concurrently, the computation runs exactly once. This is coordinated via a ConcurrentHashMap of delays, so no duplicate work is performed. See the Concurrency chapter for a detailed explanation.\n\nBy default, the in-memory layer uses an LRU (Least Recently Used) policy ‚Äî see defaults above.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cache-policies",
    "href": "pocket_book.configuration.html#cache-policies",
    "title": "3¬† Configuration",
    "section": "Cache policies",
    "text": "Cache policies\nSupported policies and their parameters:\n\n\n\nPolicy\nKey\nParameters\n\n\n\n\nLRU (Least Recently Used)\n:lru\n:threshold (see defaults above)\n\n\nFIFO (First In First Out)\n:fifo\n:threshold (see defaults above)\n\n\nLFU (Least Frequently Used)\n:lu\n:threshold (see defaults above)\n\n\nTTL (Time To Live)\n:ttl\n:ttl in ms (see defaults above)\n\n\nLIRS\n:lirs\n:s-history-limit, :q-history-limit\n\n\nSoft references\n:soft\n(none ‚Äî uses JVM garbage collection)\n\n\nBasic (unbounded)\n:basic\n(none)\n\n\n\nConfigure via set-mem-cache-options!:\n\n(pocket/set-mem-cache-options! {:policy :fifo :threshold 100})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.915 INFO scicloj.pocket - Mem-cache options set: {:policy :fifo, :threshold 100}\n10:06:31.916 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :fifo, :threshold 100}\n\n\n\n\n\n{:policy :fifo, :threshold 100}\n\nOr a TTL policy where entries expire after 60 seconds:\n\n(pocket/set-mem-cache-options! {:policy :ttl :ttl 60000})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.918 INFO scicloj.pocket - Mem-cache options set: {:policy :ttl, :ttl 60000}\n10:06:31.918 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :ttl, :ttl 60000}\n\n\n\n\n\n{:policy :ttl, :ttl 60000}\n\nReset to the default LRU policy:\n\n(pocket/set-mem-cache-options! {:policy :lru :threshold 256})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.919 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 256}\n10:06:31.919 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\nEnvironment variable ‚Äî POCKET_MEM_CACHE (EDN string):\nexport POCKET_MEM_CACHE='{:policy :lru :threshold 512}'\nThread-local binding (useful for tests):\n(binding [pocket/*mem-cache-options* {:policy :fifo :threshold 50}]\n  @(pocket/cached #'my-fn args))\nCaution: binding *mem-cache-options* reconfigures the shared global mem-cache, which affects all threads. This is useful for test fixtures but should be avoided in concurrent production use with different policies.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#storage-policies",
    "href": "pocket_book.configuration.html#storage-policies",
    "title": "3¬† Configuration",
    "section": "Storage policies",
    "text": "Storage policies\nPocket supports three storage modes, controlled by *storage*:\n\n\n\nMode\nBehavior\n\n\n\n\n:mem+disk\nIn-memory cache backed by disk persistence (default)\n\n\n:mem\nIn-memory cache only ‚Äî no disk I/O\n\n\n:none\nNo shared cache ‚Äî instance-local memoization only\n\n\n\n:mem is useful for cheap computations that are called many times with the same arguments. It avoids disk serialization overhead while still deduplicating concurrent access.\n:none is useful for trivially cheap functions that you want to participate in DAG identity tracking (see Recursive Caching in Pipelines) without any shared caching. Each Cached instance memoizes its own result (like a delay), but separate instances recompute.\nProgrammatically with set-storage!:\n\n(pocket/set-storage! :mem)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.920 INFO scicloj.pocket - Storage policy set to: :mem\n\n\n\n\n\n:mem\n\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-config\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem,\n :filename-length-limit 240}\n\nPer-function via caching-fn options:\n(def fast-fn* (pocket/caching-fn #'fast-fn {:storage :mem}))\n(def identity-fn* (pocket/caching-fn #'identity-fn {:storage :none}))\nThe option map can also override :cache-dir and :mem-cache:\n(pocket/caching-fn #'f {:storage :mem+disk\n                        :cache-dir \"/data/project-cache\"\n                        :mem-cache {:policy :ttl :ttl 60000}})\nThread-local binding:\n(binding [pocket/*storage* :mem]\n  @(pocket/cached #'my-fn args))\nEnvironment variable ‚Äî POCKET_STORAGE:\nexport POCKET_STORAGE=mem\nNote: :mem-only entries do not appear in cache-entries or cache-stats, which scan the disk cache. :none entries are not tracked anywhere ‚Äî they exist only as in-memory Cached objects.\nReset to default:\n\n(pocket/set-storage! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.923 INFO scicloj.pocket - Storage policy set to: nil\n\n\n\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#filename-length-limit-windows",
    "href": "pocket_book.configuration.html#filename-length-limit-windows",
    "title": "3¬† Configuration",
    "section": "Filename length limit (Windows)",
    "text": "Filename length limit (Windows)\nMost operating systems have a 255-character filename limit, which Pocket handles with its default threshold of 240. However, Windows has a 260-character full path limit (unless long path support is enabled). If your base cache directory is deep, the combined path may exceed this.\nWhen a cache key exceeds the configured limit, Pocket falls back to a SHA-1 hash as the directory name. The default (240) is safe for Linux and macOS, but Windows users with deep base directories may need to lower it.\nConfigure in pocket.edn:\n{:filename-length-limit 80}  ; for Windows with deep paths\nOr at runtime:\n\n(pocket/set-filename-length-limit! 80)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.925 INFO scicloj.pocket - Filename length limit set to: 80\n\n\n\n\n\n80\n\nOr via environment variable:\nexport POCKET_FILENAME_LENGTH_LIMIT=80\nThe current limit is included in config:\n\n(:filename-length-limit (pocket/config))\n\n\n80\n\nReset to default (240):\n\n(pocket/set-filename-length-limit! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.926 INFO scicloj.pocket - Filename length limit set to: nil\n\n\n\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#per-function-configuration-with-caching-fn",
    "href": "pocket_book.configuration.html#per-function-configuration-with-caching-fn",
    "title": "3¬† Configuration",
    "section": "Per-function configuration with caching-fn",
    "text": "Per-function configuration with caching-fn\nThe caching-fn wrapper accepts an optional options map. When provided, the wrapper binds the corresponding dynamic vars before calling cached. This is equivalent to wrapping the call in binding yourself:\n;; These two are equivalent:\n(def c-fn (pocket/caching-fn #'my-fn {:storage :mem}))\n\n(defn c-fn [& args]\n  (binding [pocket/*storage* :mem]\n    (apply pocket/cached #'my-fn args)))\n\nAvailable options\n\n\n\nOption\nBinds\n\n\n\n\n:storage\n*storage*\n\n\n:cache-dir\n*base-cache-dir*\n\n\n:mem-cache\n*mem-cache-options*\n\n\n:filename-length-limit\n*filename-length-limit*\n\n\n\n\n\nExample: Mixed storage policies\nA data science pipeline might use different storage for different steps:\n\n(defn load-data [path] (slurp path))\n\n\n(defn compute-stats [data] {:lines (count (clojure.string/split-lines data))})\n\n\n(defn train-model [data stats] {:model \"trained\" :stats stats})\n\nExpensive data loading ‚Äî default (disk + memory):\n\n(def c-load (pocket/caching-fn #'load-data))\n\nCheap stats ‚Äî memory only, no disk I/O:\n\n(def c-stats (pocket/caching-fn #'compute-stats {:storage :mem}))\n\nExpensive training ‚Äî shorter filenames for Windows compatibility:\n\n(def c-train (pocket/caching-fn #'train-model {:filename-length-limit 80}))",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cleanup",
    "href": "pocket_book.configuration.html#cleanup",
    "title": "3¬† Configuration",
    "section": "Cleanup",
    "text": "Cleanup\nTo delete all cached values (both disk and in-memory), use cleanup!:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.929 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-config\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-config\", :existed false}\n\n\nsource: notebooks/pocket_book/configuration.clj",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html",
    "href": "pocket_book.logging.html",
    "title": "4¬† Logging",
    "section": "",
    "text": "Log levels\nLast modified: 2026-02-08\nPocket uses clojure.tools.logging for cache lifecycle messages. It does not bundle a logging backend ‚Äî you provide your own (e.g., SLF4J with slf4j-simple or Logback, or Log4j2 directly). tools.logging auto-discovers a backend from the classpath; without one, logging is silently disabled.\nThis documentation was rendered using slf4j-simple as a dev dependency of the Pocket project, so the log output shown here is real.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html#log-levels",
    "href": "pocket_book.logging.html#log-levels",
    "title": "4¬† Logging",
    "section": "",
    "text": "Level\nMessages\n\n\n\n\n:debug\nCache hits (memory and disk), cache writes\n\n\n:info\nCache misses (computation), invalidation, mem-cache reconfiguration, cleanup",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html#internals",
    "href": "pocket_book.logging.html#internals",
    "title": "4¬† Logging",
    "section": "Internals",
    "text": "Internals\nslf4j-simple reads system properties only at class-load time. In a warm REPL (or when notebooks are evaluated after loggers already exist), we need reflection to change settings on the already-initialized CONFIG_PARAMS singleton and on existing logger instances.\n\n(defn- get-config\n  \"Return the slf4j-simple CONFIG_PARAMS singleton via reflection.\"\n  []\n  (let [f (.getDeclaredField SimpleLogger \"CONFIG_PARAMS\")]\n    (.setAccessible f true)\n    (.get f nil)))\n\n\n#'pocket-book.logging/get-config\n\n\n(def ^:private slf4j-levels\n  {:error 40 :warn 30 :info 20 :debug 10 :trace 0})\n\n\n(defn set-slf4j-level!\n  \"Set the slf4j-simple log level via reflection.\n  `level` is a keyword: :error, :warn, :info, :debug, or :trace.\n  Sets both the default for future loggers and the level on\n  existing Pocket logger instances.\"\n  [level]\n  (try\n    (let [int-level (get slf4j-levels level)\n          config (get-config)\n          dl (.getDeclaredField (class config) \"defaultLogLevel\")\n          level-field (.getDeclaredField SimpleLogger \"currentLogLevel\")]\n      (.setAccessible dl true)\n      (.setInt dl config int-level)\n      (.setAccessible level-field true)\n      (doseq [name [\"scicloj.pocket\" \"scicloj.pocket.impl.cache\"]]\n        (.setInt level-field (LoggerFactory/getLogger name) int-level)))\n    (catch Exception _)))\n\n\n(defn- set-slf4j-output-stdout!\n  \"Force slf4j-simple to write to stdout via reflection.\"\n  []\n  (try\n    (let [config (get-config)\n          oc-field (.getDeclaredField (class config) \"outputChoice\")]\n      (.setAccessible oc-field true)\n      (let [sys-out (java.lang.Enum/valueOf\n                     org.slf4j.simple.OutputChoice$OutputChoiceType \"SYS_OUT\")\n            ctor (.getDeclaredConstructor\n                  org.slf4j.simple.OutputChoice\n                  (into-array Class [org.slf4j.simple.OutputChoice$OutputChoiceType]))]\n        (.setAccessible ctor true)\n        (.set oc-field config (.newInstance ctor (object-array [sys-out])))))\n    (catch Exception _)))\n\n\n#'pocket-book.logging/set-slf4j-output-stdout!\n\n\n(defn- redirect-jul-to-stdout!\n  \"Redirect java.util.logging (JUL) output to stdout.\n  Some libraries (e.g., Tribuo) use JUL directly instead of SLF4J.\n  JUL defaults to stderr, which Clay renders as `## ERR` sections.\"\n  []\n  (let [root (java.util.logging.Logger/getLogger \"\")\n        handler (proxy [java.util.logging.StreamHandler]\n                       [System/out (java.util.logging.SimpleFormatter.)]\n                  (publish [record]\n                    (proxy-super publish record)\n                    (.flush this))\n                  (close [] (.flush this)))]\n    (doseq [h (.getHandlers root)]\n      (.removeHandler root h))\n    (.addHandler root handler)))\n\n\n#'pocket-book.logging/redirect-jul-to-stdout!",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html#setup-for-notebooks",
    "href": "pocket_book.logging.html#setup-for-notebooks",
    "title": "4¬† Logging",
    "section": "Setup for notebooks",
    "text": "Setup for notebooks\nThe following configures slf4j-simple for notebook use. These properties must be set before any logging occurs.\nHide thread names to reduce clutter:\n\n(System/setProperty \"org.slf4j.simpleLogger.showThreadName\" \"false\")\n\n\n\"false\"\n\nShow timestamps for each log message:\n\n(System/setProperty \"org.slf4j.simpleLogger.showDateTime\" \"true\")\n\n\n\"true\"\n\nUse hours:minutes:seconds.milliseconds format:\n\n(System/setProperty \"org.slf4j.simpleLogger.dateTimeFormat\" \"HH:mm:ss.SSS\")\n\n\n\"HH:mm:ss.SSS\"\n\nWrite to stdout so messages appear as OUT rather than ERR:\n\n(System/setProperty \"org.slf4j.simpleLogger.logFile\" \"System.out\")\n\n\n\"System.out\"\n\nApply stdout and debug level via reflection (works even in a warm REPL):\n\n(set-slf4j-output-stdout!)\n\n\nnil\n\n\n(set-slf4j-level! :debug)\n\n\nnil\n\n\n(redirect-jul-to-stdout!)\n\n\nnil\n\nOther notebooks in this book require this namespace to activate logging. In your own projects, configure your preferred SLF4J backend instead.\n\nsource: notebooks/pocket_book/logging.clj",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html",
    "href": "pocket_book.recursive_caching_in_pipelines.html",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-09\nWhen you pass a Cached value as an argument to another cached function, Pocket handles this recursively. The cache key for the outer computation is derived from the identity of the inner computation (its function name and arguments), not from its result. This means the entire pipeline‚Äôs cache key captures the full computation graph.\nPocket automatically derefs any Cached arguments before calling the function, so pipeline functions receive plain values and don‚Äôt need any special handling.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#setup",
    "href": "pocket_book.recursive_caching_in_pipelines.html#setup",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "",
    "text": "(ns pocket-book.recursive-caching-in-pipelines\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; String utilities:\n   [clojure.string :as str]))\n\n\n(def cache-dir \"/tmp/pocket-demo-pipelines\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.991 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-pipelines\n\n\n\n\n\n\"/tmp/pocket-demo-pipelines\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.992 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-pipelines\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-pipelines\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#a-three-step-pipeline",
    "href": "pocket_book.recursive_caching_in_pipelines.html#a-three-step-pipeline",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "A three-step pipeline",
    "text": "A three-step pipeline\nWe‚Äôll build a simple data science pipeline with three stages: load data, preprocess it, and train a model. Each stage is wrapped with caching-fn so every call returns a Cached object. Passing one Cached result into the next stage is what makes the caching recursive.\nflowchart LR\n    LD[load-dataset] --&gt; PP[preprocess]\n    PP --&gt; TM[train-model]",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#pipeline-functions",
    "href": "pocket_book.recursive_caching_in_pipelines.html#pipeline-functions",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Pipeline functions",
    "text": "Pipeline functions\n\n(defn load-dataset [path]\n  (println \"Loading dataset from\" path \"...\")\n  (Thread/sleep 300)\n  {:data [1 2 3 4 5] :source path})\n\n\n(defn preprocess [data opts]\n  (println \"Preprocessing with options:\" opts)\n  (Thread/sleep 300)\n  (update data :data #(map (fn [x] (* x (:scale opts))) %)))\n\n\n(defn train-model [data params]\n  (println \"Training model with params:\" params)\n  (Thread/sleep 300)\n  {:model :trained :accuracy 0.95 :data data})\n\nWrap each function with caching-fn so every call returns a Cached object:\n\n(def load-dataset* (pocket/caching-fn #'load-dataset))\n\n\n(def preprocess* (pocket/caching-fn #'preprocess))\n\n\n(def train-model* (pocket/caching-fn #'train-model))",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#running-the-pipeline",
    "href": "pocket_book.recursive_caching_in_pipelines.html#running-the-pipeline",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Running the pipeline",
    "text": "Running the pipeline\nChain cached computations in a pipeline:\nFirst pipeline run:\n\n(time\n (-&gt; \"data/raw.csv\"\n     (load-dataset*)\n     (preprocess* {:scale 2})\n     (train-model* {:epochs 100})\n     deref\n     (select-keys [:model :accuracy])))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:31.998 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/train-model\n10:06:31.998 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess\n10:06:31.998 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset\nLoading dataset from data/raw.csv ...\n10:06:32.311 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/b8/(pocket-book.recursive-caching-in-pipelines_load-dataset \"data_raw.csv\")\nPreprocessing with options: {:scale 2}\n10:06:32.614 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/85/(pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset \"data_raw.csv\") {:scale 2})\nTraining model with params: {:epochs 100}\n10:06:32.915 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/c9/(pocket-book.recursive-caching-in-pipelines_train-model (pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset \"data_raw.csv\") {:scale 2}) {:epochs 100})\n\"Elapsed time: 918.094275 msecs\"\n\n\n\n\n\n{:model :trained, :accuracy 0.95}\n\nRun the same pipeline again ‚Äî everything loads from cache:\nSecond pipeline run (all cached):\n\n(time\n (-&gt; \"data/raw.csv\"\n     (load-dataset*)\n     (preprocess* {:scale 2})\n     (train-model* {:epochs 100})\n     deref\n     (select-keys [:model :accuracy])))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.525695 msecs\"\n\n\n\n\n\n{:model :trained, :accuracy 0.95}\n\nNo log output above ‚Äî the result was served entirely from the in-memory cache, so no disk I/O or computation occurred. Each step caches independently. If you change only the last step (e.g., different training params), the upstream steps load from cache while only the final step recomputes.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#provenance-in-cache-entries",
    "href": "pocket_book.recursive_caching_in_pipelines.html#provenance-in-cache-entries",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Provenance in cache entries",
    "text": "Provenance in cache entries\nThe cache entries reveal the pipeline structure. Each entry‚Äôs identity encodes its full computation history ‚Äî not just the function name, but the nested identities of all its cached inputs.\n\n(-&gt;&gt; (pocket/cache-entries)\n     (mapv :id))\n\n\n[\"(pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\")\"\n \"(pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\") {:scale 2})\"\n \"(pocket-book.recursive-caching-in-pipelines/train-model (pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\") {:scale 2}) {:epochs 100})\"]\n\n\n(-&gt;&gt; (pocket/cache-entries)\n     (mapv :id)\n     (str/join \"\\n\")\n     kind/code)\n\n\n(pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\")\n(pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\") {:scale 2})\n(pocket-book.recursive-caching-in-pipelines/train-model (pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\") {:scale 2}) {:epochs 100})\n\nThe inner step appears as a literal sub-expression in the outer step‚Äôs identity. This is how Pocket tracks provenance: the cache key for train-model records that its input came from preprocess, which in turn came from load-dataset.\nThis happens automatically when you pass Cached objects (without derefing) from one cached step to the next.\nIf you deref early with @ (or deref), the derefed value still carries its origin identity ‚Äî (pocket/-&gt;id @cached-ref) returns the same lightweight identity as the Cached reference itself. This means downstream cached steps get efficient cache keys even when working with real (derefed) values. The link breaks only when the value is transformed (e.g., adding a column), creating a new object that falls back to content-based identity. See Under the hood: cache keys for details on the origin registry.\nSimilarly, origin-story follows derefed values back through the registry to their Cached origin, producing the full provenance DAG. We demonstrate this below.\nFor a fuller example with branching dependencies, see the Real-World Walkthrough.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#inspecting-the-dag",
    "href": "pocket_book.recursive_caching_in_pipelines.html#inspecting-the-dag",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Inspecting the DAG",
    "text": "Inspecting the DAG\nPocket provides three functions for DAG introspection:\n\norigin-story ‚Äî nested tree with :ref pointers for shared nodes\norigin-story-graph ‚Äî flat {:nodes ... :edges ...} for graph algorithms\norigin-story-mermaid ‚Äî Mermaid flowchart string for visualization\n\nBuild the pipeline keeping the intermediate Cached objects:\n\n(def data-c (load-dataset* \"data/experiment.csv\"))\n\n\n(def preprocessed-c (preprocess* data-c {:scale 2}))\n\n\n(def model-c (train-model* preprocessed-c {:epochs 100}))\n\n\norigin-story ‚Äî tree structure\nReturns a nested map where each cached step is {:fn &lt;var&gt; :args [...] :id &lt;string&gt;}. Plain arguments become {:value ...} leaves. If a step has been computed, :value is included.\nBefore any computation:\n\n(pocket/origin-story model-c)\n\n\n{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n :args\n [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :args\n   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n     :args [{:value \"data/experiment.csv\"}],\n     :id \"c3\"}\n    {:value {:scale 2}}],\n   :id \"c2\"}\n  {:value {:epochs 100}}],\n :id \"c1\"}\n\nNo :value keys yet. Now trigger computation:\n\n(deref model-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:32.923 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/train-model\n10:06:32.923 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess\n10:06:32.923 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset\nLoading dataset from data/experiment.csv ...\n10:06:33.224 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/cd/(pocket-book.recursive-caching-in-pipelines_load-dataset \"data_experiment.csv\")\nPreprocessing with options: {:scale 2}\n10:06:33.526 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/f8/(pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset \"data_experiment.csv\") {:scale 2})\nTraining model with params: {:epochs 100}\n10:06:33.828 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/9e/(pocket-book.recursive-caching-in-pipelines_train-model (pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset \"data_experiment.csv\") {:scale 2}) {:epochs 100})\n\n\n\n\n\n{:model :trained,\n :accuracy 0.95,\n :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}\n\nAfter deref, every node includes its :value:\n\n(pocket/origin-story model-c)\n\n\n{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n :args\n [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :args\n   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n     :args [{:value \"data/experiment.csv\"}],\n     :id \"c3\",\n     :value {:data [1 2 3 4 5], :source \"data/experiment.csv\"}}\n    {:value {:scale 2}}],\n   :id \"c2\",\n   :value {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}\n  {:value {:epochs 100}}],\n :id \"c1\",\n :value\n {:model :trained,\n  :accuracy 0.95,\n  :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}}\n\nWhen the same Cached instance appears multiple times (diamond pattern), subsequent occurrences are {:ref &lt;id&gt;} pointing to the first.\n\n\norigin-story-graph ‚Äî flat graph\nReturns {:nodes {&lt;id&gt; &lt;node-map&gt;} :edges [[&lt;from&gt; &lt;to&gt;] ...]}. Useful for graph algorithms or custom rendering.\n\n(pocket/origin-story-graph model-c)\n\n\n{:nodes\n {\"c1\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n   :value\n   {:model :trained,\n    :accuracy 0.95,\n    :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}},\n  \"c2\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :value {:data (2 4 6 8 10), :source \"data/experiment.csv\"}},\n  \"c3\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n   :value {:data [1 2 3 4 5], :source \"data/experiment.csv\"}},\n  \"v4\" {:value \"data/experiment.csv\"},\n  \"v5\" {:value {:scale 2}},\n  \"v6\" {:value {:epochs 100}}},\n :edges [[\"c1\" \"c2\"] [\"c2\" \"c3\"] [\"c3\" \"v4\"] [\"c2\" \"v5\"] [\"c1\" \"v6\"]]}\n\n\n\norigin-story-mermaid ‚Äî visualization\nReturns a Mermaid flowchart string. Arrows show data flow direction (from inputs toward the final result). It returns a kindly value that renders directly.\n\n(pocket/origin-story-mermaid model-c)\n\nflowchart TD\n  n0[\"train-model\"]\n  n1[\"preprocess\"]\n  n2[\"load-dataset\"]\n  n3[/\"'data/experiment.csv'\"/]\n  n3 --&gt; n2\n  n2 --&gt; n1\n  n4[/\"{:scale 2}\"/]\n  n4 --&gt; n1\n  n1 --&gt; n0\n  n5[/\"{:epochs 100}\"/]\n  n5 --&gt; n0",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#provenance-through-derefed-values",
    "href": "pocket_book.recursive_caching_in_pipelines.html#provenance-through-derefed-values",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Provenance through derefed values",
    "text": "Provenance through derefed values\nIn the pipeline above, we passed Cached references directly from one step to the next. But sometimes we need to deref between steps ‚Äî for example, when passing data to a library that expects concrete values. The origin registry ensures provenance still works in this case.\nHere we build the same three-step pipeline, but deref between each step:\n\n(def data-c2 (load-dataset* \"data/deref-demo.csv\"))\n\n\n(def data-val (deref data-c2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:33.833 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset\nLoading dataset from data/deref-demo.csv ...\n10:06:34.134 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/94/(pocket-book.recursive-caching-in-pipelines_load-dataset \"data_deref-demo.csv\")\n\n\n\n\n\n(def processed-c2 (preprocess* data-val {:scale 3}))\n\n\n(def processed-val (deref processed-c2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.136 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess\nPreprocessing with options: {:scale 3}\n10:06:34.437 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/0c/(pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset \"data_deref-demo.csv\") {:scale 3})\n\n\n\n\n\n(def model-c2 (train-model* processed-val {:epochs 50}))\n\nEven though each cached function received a derefed (real) value, origin-story traces the full chain ‚Äî from train-model back through preprocess to load-dataset:\n\n(pocket/origin-story model-c2)\n\n\n{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n :args\n [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :args\n   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n     :args [{:value \"data/deref-demo.csv\"}],\n     :id \"c3\",\n     :value {:data [1 2 3 4 5], :source \"data/deref-demo.csv\"}}\n    {:value {:scale 3}}],\n   :id \"c2\",\n   :value {:data (3 6 9 12 15), :source \"data/deref-demo.csv\"}}\n  {:value {:epochs 50}}],\n :id \"c1\"}\n\norigin-story-graph shows three cached nodes (one per pipeline step). Without the origin registry, the derefed values would appear as opaque leaves and we would see only one cached node:\n\n(let [g (pocket/origin-story-graph model-c2)]\n  (count (filter (fn [[_ v]] (:fn v)) (:nodes g))))\n\n\n3\n\nThe full chain as a Mermaid flowchart:\n\n(pocket/origin-story-mermaid model-c2)\n\nflowchart TD\n  n0[\"train-model\"]\n  n1[\"preprocess\"]\n  n2[\"load-dataset\"]\n  n3[/\"'data/deref-demo.csv'\"/]\n  n3 --&gt; n2\n  n2 --&gt; n1\n  n4[/\"{:scale 3}\"/]\n  n4 --&gt; n1\n  n1 --&gt; n0\n  n5[/\"{:epochs 50}\"/]\n  n5 --&gt; n0",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#cleanup",
    "href": "pocket_book.recursive_caching_in_pipelines.html#cleanup",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.448 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-pipelines\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-pipelines\", :existed true}\n\n\nsource: notebooks/pocket_book/recursive_caching_in_pipelines.clj",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html",
    "href": "pocket_book.usage_practices.html",
    "title": "6¬† Usage Practices",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nThis chapter expands on the basics from Getting Started with practical patterns for day-to-day work: function identity in depth, cache invalidation strategies, testing, REPL introspection, serialization constraints, and debugging tips.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#setup",
    "href": "pocket_book.usage_practices.html#setup",
    "title": "6¬† Usage Practices",
    "section": "",
    "text": "(ns pocket-book.usage-practices\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]))\n\n\n(def test-dir \"/tmp/pocket-dev-practices\")\n\n\n(pocket/set-base-cache-dir! test-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.519 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-dev-practices\n\n\n\n\n\n\"/tmp/pocket-dev-practices\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#when-to-use-pocket",
    "href": "pocket_book.usage_practices.html#when-to-use-pocket",
    "title": "6¬† Usage Practices",
    "section": "When to Use Pocket",
    "text": "When to Use Pocket\n\nGood use cases\n\nData science pipelines with expensive intermediate steps (data loading, preprocessing, feature engineering, model training)\nReproducible research where cached intermediate results let you iterate on downstream steps without re-running upstream computations\nLong-running computations (minutes to hours) that need to survive JVM restarts, crashes, or machine reboots\nMulti-threaded workflows where multiple threads may request the same expensive computation ‚Äî Pocket ensures it runs only once\n\n\n\nComparison to alternatives\n\n\n\nFeature\nPocket\nclojure.core/memoize\ncore.memoize\n\n\n\n\nPersistence\nDisk + memory\nMemory only\nMemory only\n\n\nCross-session\nYes\nNo\nNo\n\n\nLazy evaluation\nIDeref\nEager\nEager\n\n\nEviction policies\nLRU, FIFO, TTL, etc.\nNone\nLRU, TTL, etc.\n\n\nThread-safe (single computation)\nYes\nNo\nYes\n\n\nPipeline caching\nYes (recursive)\nNo\nNo",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#function-identity-use-vars-or-keywords",
    "href": "pocket_book.usage_practices.html#function-identity-use-vars-or-keywords",
    "title": "6¬† Usage Practices",
    "section": "Function Identity: Use Vars or Keywords",
    "text": "Function Identity: Use Vars or Keywords\nPocket requires functions to be passed as vars (#'fn-name) or keywords (e.g., :train), not as bare function objects.\n;; ‚ùå WRONG - bare function, unstable identity\n(pocket/cached my-expensive-fn arg1 arg2)\n\n;; ‚úÖ CORRECT - var, stable identity\n(pocket/cached #'my-expensive-fn arg1 arg2)\n\n;; ‚úÖ CORRECT - keyword, stable identity\n(pocket/cached :train cached-split)\nWhy? Function objects have different identity across JVM sessions, making cache keys unpredictable. Vars provide stable symbol names that survive restarts. Keywords are inherently stable and work naturally as map accessors on cached values.\nPocket validates this and throws a clear error if you forget:\n\n(defn example-fn [x] (* x x))\n\n\n(try\n  (pocket/cached example-fn 5)\n  (catch Exception e\n    (ex-message e)))\n\n\n\"pocket/cached requires a var or keyword (e.g., #'my-fn or :my-key), got: class pocket_book.usage_practices$example_fn\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#cache-invalidation-strategies",
    "href": "pocket_book.usage_practices.html#cache-invalidation-strategies",
    "title": "6¬† Usage Practices",
    "section": "Cache Invalidation Strategies",
    "text": "Cache Invalidation Strategies\nPocket does not automatically detect when a function‚Äôs implementation changes. You must invalidate manually. Here are the strategies:\n\nStrategy 1: Manual Invalidation\nUse invalidate! for specific entries or invalidate-fn! for all entries of a function:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.524 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed false}\n\n\n(defn transform [x] (* x 2))\n\nCache a computation:\n\n(deref (pocket/cached #'transform 10))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.525 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n10:06:34.526 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/1c/(pocket-book.usage-practices_transform 10)\n\n\n\n\n\n20\n\nFunction implementation changed ‚Äî invalidate a single entry:\n\n(pocket/invalidate! #'transform 10)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.528 INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-dev-practices/1c/(pocket-book.usage-practices_transform 10) existed= true\n\n\n\n\n\n{:path\n \"/tmp/pocket-dev-practices/1c/(pocket-book.usage-practices_transform 10)\",\n :existed true}\n\nOr invalidate all entries for a function:\n\n(deref (pocket/cached #'transform 1))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.528 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n10:06:34.529 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\n\n\n\n\n\n2\n\n\n(deref (pocket/cached #'transform 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.530 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n10:06:34.530 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\n\n\n\n\n\n4\n\n\n(pocket/invalidate-fn! #'transform)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.531 INFO scicloj.pocket.impl.cache - Invalidated 2 entries for pocket-book.usage-practices/transform\n\n\n\n\n\n{:fn-name \"pocket-book.usage-practices/transform\",\n :count 2,\n :paths\n [\"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\"\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\"]}\n\n\n\nStrategy 2: Versioning Pattern\nAdd a version key to your function‚Äôs input. Bumping the version creates new cache entries while preserving old ones for comparison:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.532 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn process-data [{:keys [data version]}]\n  {:result (reduce + data)\n   :version version})\n\nVersion 1:\n\n(deref (pocket/cached #'process-data {:data [1 2 3] :version 1}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.534 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-data\n10:06:34.535 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/58/(pocket-book.usage-practices_process-data {:data [1 2 3], :version 1})\n\n\n\n\n\n{:result 6, :version 1}\n\nAfter changing the function, bump version:\n\n(deref (pocket/cached #'process-data {:data [1 2 3] :version 2}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.536 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-data\n10:06:34.537 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/64/(pocket-book.usage-practices_process-data {:data [1 2 3], :version 2})\n\n\n\n\n\n{:result 6, :version 2}\n\nBoth versions coexist in cache ‚Äî useful for A/B comparison.\n\n\nStrategy 3: Full Cleanup\nFor a fresh start, use cleanup! to delete the entire cache:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.538 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#testing-with-pocket",
    "href": "pocket_book.usage_practices.html#testing-with-pocket",
    "title": "6¬† Usage Practices",
    "section": "Testing with Pocket",
    "text": "Testing with Pocket\nTests should be isolated from production caches and from each other. Use binding and cleanup fixtures:\n\nTest Fixture Pattern\n(def test-cache-dir \"/tmp/my-project-test-cache\")\n\n(defn cleanup-fixture [f]\n  (binding [pocket/*base-cache-dir* test-cache-dir]\n    (pocket/cleanup!)\n    (try\n      (f)\n      (finally\n        (pocket/cleanup!)))))\n\n(use-fixtures :each cleanup-fixture)\nThis ensures: 1. Tests use a separate cache directory 2. Cache is cleared before and after each test 3. Tests don‚Äôt affect each other\n\n\nVerifying Cache Behavior\nUse an atom to track computation calls:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.539 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed false}\n\n\n(def call-count (atom 0))\n\n\n(defn tracked-fn [x]\n  (swap! call-count inc)\n  (* x x))\n\nFirst call computes:\n\n(reset! call-count 0)\n\n\n0\n\n\n(let [result (deref (pocket/cached #'tracked-fn 5))\n      calls @call-count]\n  {:result result :calls calls})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.541 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/tracked-fn\n10:06:34.542 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/4a/(pocket-book.usage-practices_tracked-fn 5)\n\n\n\n\n\n{:result 25, :calls 1}\n\nSecond call uses cache (no additional computation):\n\n(let [result (deref (pocket/cached #'tracked-fn 5))\n      calls @call-count]\n  {:result result :calls calls})\n\n\n{:result 25, :calls 1}",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#repl-development-workflow",
    "href": "pocket_book.usage_practices.html#repl-development-workflow",
    "title": "6¬† Usage Practices",
    "section": "REPL Development Workflow",
    "text": "REPL Development Workflow\n\nInspecting the Cache\nUse introspection functions to understand cache state:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.545 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(deref (pocket/cached #'transform 1))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.545 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n10:06:34.546 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\n\n\n\n\n\n2\n\n\n(deref (pocket/cached #'transform 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.547 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n10:06:34.547 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\n\n\n\n\n\n4\n\n\n(deref (pocket/cached #'tracked-fn 3))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.548 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/tracked-fn\n10:06:34.548 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/e8/(pocket-book.usage-practices_tracked-fn 3)\n\n\n\n\n\n9\n\nSee all cached entries:\n\n(count (pocket/cache-entries))\n\n\n3\n\nGet aggregate statistics:\n\n(:total-entries (pocket/cache-stats))\n\n\n3\n\nVisualize cache structure:\n\n(pocket/dir-tree)\n\n\npocket-dev-practices\n‚îú‚îÄ‚îÄ db\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.usage-practices_transform 1)\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ e4\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.usage-practices_transform 2)\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îî‚îÄ‚îÄ e8\n    ‚îî‚îÄ‚îÄ (pocket-book.usage-practices_tracked-fn 3)\n        ‚îú‚îÄ‚îÄ meta.edn\n        ‚îî‚îÄ‚îÄ value.nippy\n\nEach directory contains a meta.edn file with metadata about the cached computation:\n\n(-&gt; (pocket/cache-entries)\n    first\n    :path\n    (str \"/meta.edn\")\n    slurp\n    clojure.edn/read-string)\n\n\n{:id \"(pocket-book.usage-practices/transform 1)\",\n :fn-name \"pocket-book.usage-practices/transform\",\n :args-str \"[1]\",\n :created-at \"2026-02-09T08:06:34.545970813Z\"}\n\nThis same information is available through the API:\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\",\n  :id \"(pocket-book.usage-practices/transform 1)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[1]\",\n  :created-at \"2026-02-09T08:06:34.545970813Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\",\n  :id \"(pocket-book.usage-practices/transform 2)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[2]\",\n  :created-at \"2026-02-09T08:06:34.547336137Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e8/(pocket-book.usage-practices_tracked-fn 3)\",\n  :id \"(pocket-book.usage-practices/tracked-fn 3)\",\n  :fn-name \"pocket-book.usage-practices/tracked-fn\",\n  :args-str \"[3]\",\n  :created-at \"2026-02-09T08:06:34.548536434Z\"}]\n\nFilter entries by function name:\n\n(pocket/cache-entries (str (ns-name *ns*) \"/transform\"))\n\n\n[{:path\n  \"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\",\n  :id \"(pocket-book.usage-practices/transform 1)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[1]\",\n  :created-at \"2026-02-09T08:06:34.545970813Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\",\n  :id \"(pocket-book.usage-practices/transform 2)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[2]\",\n  :created-at \"2026-02-09T08:06:34.547336137Z\"}]\n\n\n\nChecking Cached Status\nCached values print their status without forcing computation:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.557 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(def pending-value (pocket/cached #'transform 99))\n\nBefore deref:\n\n(pr-str pending-value)\n\n\n\"#&lt;Cached (pocket-book.usage-practices/transform 99) :pending&gt;\"\n\n\n(deref pending-value)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.559 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n10:06:34.560 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/d8/(pocket-book.usage-practices_transform 99)\n\n\n\n\n\n198\n\nAfter deref:\n\n(pr-str pending-value)\n\n\n\"#&lt;Cached (pocket-book.usage-practices/transform 99) :cached&gt;\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#debugging-with-logging",
    "href": "pocket_book.usage_practices.html#debugging-with-logging",
    "title": "6¬† Usage Practices",
    "section": "Debugging with Logging",
    "text": "Debugging with Logging\nEnable debug logging to see cache hits, misses, and writes. See the Logging chapter for setup.\nWith debug logging enabled, you‚Äôll see:\n\nCache miss, computing: ... ‚Äî computation triggered\nCache hit (memory): ... ‚Äî served from in-memory cache\nCache hit (disk): ... ‚Äî loaded from disk\nCache write: ... ‚Äî written to disk",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#long-cache-keys",
    "href": "pocket_book.usage_practices.html#long-cache-keys",
    "title": "6¬† Usage Practices",
    "section": "Long Cache Keys",
    "text": "Long Cache Keys\nWhen a cache key string exceeds 240 characters, Pocket falls back to using a SHA-1 hash as the directory name. This ensures the filesystem can handle arbitrarily complex arguments while maintaining correct caching behavior.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.562 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn process-long-text [text]\n  (str \"Processed: \" (count text) \" chars\"))\n\n\n(def long-text (apply str (repeat 300 \"x\")))\n\n\n(deref (pocket/cached #'process-long-text long-text))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.564 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-long-text\n10:06:34.564 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/6d/6d7a9c06574c78354a8235a2e77b6ed27348e404\n\n\n\n\n\n\"Processed: 300 chars\"\n\nThe entry is stored with a hash-based directory name:\n\n(pocket/dir-tree)\n\n\npocket-dev-practices\n‚îî‚îÄ‚îÄ 6d\n    ‚îî‚îÄ‚îÄ 6d7a9c06574c78354a8235a2e77b6ed27348e404\n        ‚îú‚îÄ‚îÄ meta.edn\n        ‚îî‚îÄ‚îÄ value.nippy\n\nBut meta.edn inside still contains the full details, so cache-entries and invalidate-fn! work correctly:\n\n(-&gt; (pocket/cache-entries (str (ns-name *ns*) \"/process-long-text\"))\n    first\n    :fn-name)\n\n\n\"pocket-book.usage-practices/process-long-text\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#serialization-constraints",
    "href": "pocket_book.usage_practices.html#serialization-constraints",
    "title": "6¬† Usage Practices",
    "section": "Serialization Constraints",
    "text": "Serialization Constraints\nPocket uses Nippy for serialization. Most Clojure data structures work, but some don‚Äôt:\n\n‚úÖ Safe to Cache\n\nPrimitive types (numbers, strings, keywords, symbols)\nCollections (vectors, maps, sets, lists)\nRecords and most deftypes\nJava Serializable objects\n\n\n\n‚ö†Ô∏è Requires Care\n\nLazy sequences ‚Äî Nippy fully realizes them during serialization, which means infinite lazy seqs will hang or OOM. Force lazy seqs with doall inside your function (see below) to keep realization explicit and catch errors early. The round-trip type may also change (a LazySeq comes back as a regular seq).\n\n\n\n‚ùå Cannot Cache\n\nOpen file handles, streams\nNetwork connections, sockets\nFunctions, closures (use vars instead)\nAtoms, refs, agents (stateful references)\n\n\n\nLazy Sequences\nUse doall or vec to force evaluation inside your function:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.569 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn generate-data [n]\n  ;; doall forces full evaluation of the lazy sequence\n  (doall (range n)))\n\n\n(deref (pocket/cached #'generate-data 5))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.571 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/generate-data\n10:06:34.572 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-dev-practices/79/(pocket-book.usage-practices_generate-data 5)\n\n\n\n\n\n(0 1 2 3 4)",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#known-limitations",
    "href": "pocket_book.usage_practices.html#known-limitations",
    "title": "6¬† Usage Practices",
    "section": "Known Limitations",
    "text": "Known Limitations\n\nNo automatic cache invalidation ‚Äî Pocket doesn‚Äôt detect when a function‚Äôs implementation changes. Use invalidate!, invalidate-fn!, or the versioning pattern described above.\nRequires serializable values ‚Äî Nippy handles most Clojure types, but you can‚Äôt cache functions, atoms, channels, file handles, or other stateful objects.\nDisk cache grows indefinitely ‚Äî The in-memory cache supports eviction policies (LRU, TTL, etc.), but the disk cache has no automatic cleanup. Use cleanup! or invalidate-fn! periodically if disk space is a concern.\nNo disk cache TTL ‚Äî Cached values on disk never expire automatically. If you need time-based expiration, you‚Äôll need to manage it externally or use cleanup!.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#summary",
    "href": "pocket_book.usage_practices.html#summary",
    "title": "6¬† Usage Practices",
    "section": "Summary",
    "text": "Summary\n\n\n\nPractice\nRecommendation\n\n\n\n\nFunction identity\nAlways use vars (#'fn-name)\n\n\nInvalidation\nManual, versioning, or full cleanup\n\n\nTesting\nUse binding + cleanup fixtures\n\n\nDebugging\nEnable logging, use introspection\n\n\nLong cache keys\nAuto-handled with SHA-1 fallback\n\n\nSerialization\nAvoid stateful objects; force lazy seqs with doall\n\n\nConfiguration\nUse pocket.edn ‚Äî see Configuration\n\n\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.574 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\nsource: notebooks/pocket_book/usage_practices.clj",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html",
    "href": "pocket_book.real_world_walkthrough.html",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "",
    "text": "Overview\nLast modified: 2026-02-08\nThis walkthrough demonstrates a realistic data pipeline with multiple stages and branching dependencies. We‚Äôll simulate a weather analysis workflow where raw sensor readings are cleaned, then fed into two independent analyses ‚Äî one for temperature trends and one for rainfall totals. Both analyses share the same cleaned data, so Pocket caches it once and reuses it.\nThis builds on the concepts from Recursive Caching in Pipelines, adding branching dependencies where two analyses share a common upstream computation.\nThe dependency graph: fetch-readings ‚Üí clean-data ‚Üí both temperature-trends and rainfall-totals ‚Üí summary.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#overview",
    "href": "pocket_book.real_world_walkthrough.html#overview",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "",
    "text": "flowchart TD\n    FR[fetch-readings] --&gt; CD[clean-data]\n    CD --&gt; TT[temperature-trends]\n    CD --&gt; RT[rainfall-totals]\n    TT --&gt; S[summary]\n    RT --&gt; S",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#setup",
    "href": "pocket_book.real_world_walkthrough.html#setup",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Setup",
    "text": "Setup\n\n(ns pocket-book.real-world-walkthrough\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Filesystem utilities:\n   [babashka.fs :as fs]))\n\n\n(def cache-dir \"/tmp/pocket-walkthrough\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.664 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-walkthrough\n\n\n\n\n\n\"/tmp/pocket-walkthrough\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.665 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-walkthrough\n\n\n\n\n\n{:dir \"/tmp/pocket-walkthrough\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#pipeline-functions",
    "href": "pocket_book.real_world_walkthrough.html#pipeline-functions",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Pipeline functions",
    "text": "Pipeline functions\nEach function simulates real work with a short delay. Note that these are plain Clojure functions ‚Äî they know nothing about caching.\n\n(defn fetch-readings\n  \"Simulate fetching raw sensor data for a city.\"\n  [opts]\n  (println \"  Fetching readings for\" (:city opts) \"...\")\n  (Thread/sleep 300)\n  {:city (:city opts)\n   :source (:source opts)\n   :readings (case (:city opts)\n               \"Paris\"\n               [{:day 1 :temp-c 15.0 :rain-mm 2.1}\n                {:day 2 :temp-c 17.3 :rain-mm 0.0}\n                {:day 3 :temp-c 14.6 :rain-mm 7.8}\n                {:day 4 :temp-c 18.1 :rain-mm 0.0}\n                {:day 5 :temp-c 13.9 :rain-mm 4.5}\n                {:day 6 :temp-c 16.7 :rain-mm 0.0}\n                {:day 7 :temp-c 19.2 :rain-mm 1.0}]\n               ;; default (London, etc.)\n               [{:day 1 :temp-c 18.2 :rain-mm 0.0}\n                {:day 2 :temp-c 21.5 :rain-mm 5.2}\n                {:day 3 :temp-c 19.8 :rain-mm 12.1}\n                {:day 4 :temp-c 22.0 :rain-mm 0.0}\n                {:day 5 :temp-c 16.3 :rain-mm 8.4}\n                {:day 6 :temp-c 20.1 :rain-mm 0.0}\n                {:day 7 :temp-c 23.7 :rain-mm 3.3}])})\n\n\n(defn clean-data\n  \"Remove readings with missing values and round numbers.\"\n  [raw-data opts]\n  (println \"  Cleaning data for\" (:city raw-data) \"with\" opts \"...\")\n  (Thread/sleep 200)\n  (let [precision (:precision opts 10)]\n    (update raw-data :readings\n            (fn [rs]\n              (-&gt;&gt; rs\n                   (filter #(and (:temp-c %) (:rain-mm %)))\n                   (mapv #(-&gt; %\n                              (update :temp-c (fn [t] (Math/round (* t (double precision)))))\n                              (update :rain-mm (fn [r] (Math/round (* r (double precision))))))))))))\n\n\n(defn temperature-trends\n  \"Compute temperature statistics from cleaned data.\"\n  [clean-data opts]\n  (println \"  Analyzing temperature for\" (:city clean-data) \"...\")\n  (Thread/sleep 300)\n  (let [temps (map :temp-c (:readings clean-data))\n        n (count temps)]\n    {:city (:city clean-data)\n     :unit (:unit opts)\n     :min-temp (apply min temps)\n     :max-temp (apply max temps)\n     :mean-temp (quot (reduce + temps) n)\n     :days n}))\n\n\n(defn rainfall-totals\n  \"Compute rainfall statistics from cleaned data.\"\n  [clean-data opts]\n  (println \"  Analyzing rainfall for\" (:city clean-data) \"...\")\n  (Thread/sleep 300)\n  (let [rains (map :rain-mm (:readings clean-data))\n        rainy-days (count (filter pos? rains))]\n    {:city (:city clean-data)\n     :unit (:unit opts)\n     :total-rain (reduce + rains)\n     :rainy-days rainy-days\n     :dry-days (- (count rains) rainy-days)}))\n\n\n(defn summary\n  \"Combine temperature and rainfall analyses into a report.\"\n  [temp-analysis rain-analysis]\n  (println \"  Generating summary for\" (:city temp-analysis) \"...\")\n  (Thread/sleep 200)\n  (merge temp-analysis rain-analysis\n         {:report (str (:city temp-analysis)\n                       \": temp range \"\n                       (:min-temp temp-analysis) \"‚Äì\"\n                       (:max-temp temp-analysis)\n                       \", total rain \"\n                       (:total-rain rain-analysis)\n                       \" over \" (:rainy-days rain-analysis) \" days\")}))",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#first-run-everything-computes",
    "href": "pocket_book.real_world_walkthrough.html#first-run-everything-computes",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "First run: everything computes",
    "text": "First run: everything computes\nWe build the pipeline using cached. Each call returns a Cached object that we pass directly to the next stage. Pocket derives cache keys from the computation graph, not from intermediate values.\n\n(println \"=== First run ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n=== First run ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"London\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:34.678 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/summary\n10:06:34.678 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/temperature-trends\n10:06:34.678 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/clean-data\n10:06:34.678 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/fetch-readings\n  Fetching readings for London ...\n10:06:34.981 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/29/(pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api})\n  Cleaning data for London with {:precision 10, :remove-nulls true} ...\n10:06:35.184 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/2c/(pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\n  Analyzing temperature for London ...\n10:06:35.486 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/17/17db4a12cb5e1ba8da076b6148be68b333bc6a16\n10:06:35.486 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/rainfall-totals\n  Analyzing rainfall for London ...\n10:06:35.788 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/a4/(pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\n  Generating summary for London ...\n10:06:35.990 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/50/50a0ffd14b1b8fa3a7ba7a1fa3d75cf5b26f0c57\n\"Elapsed time: 1312.197295 msecs\"\n\n\n\n\n\n{:report \"London: temp range 163‚Äì237, total rain 290 over 4 days\",\n :max-temp 237,\n :dry-days 3,\n :unit :mm,\n :city \"London\",\n :days 7,\n :total-rain 290,\n :rainy-days 4,\n :mean-temp 202,\n :min-temp 163}\n\nEvery function ran. Notice the log messages showing cache misses, computations, and writes.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#second-run-everything-from-cache",
    "href": "pocket_book.real_world_walkthrough.html#second-run-everything-from-cache",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Second run: everything from cache",
    "text": "Second run: everything from cache\nRunning the exact same pipeline again ‚Äî nothing recomputes:\n\n(println \"\\n=== Second run (fully cached) ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Second run (fully cached) ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"London\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.227553 msecs\"\n\n\n\n\n\n{:report \"London: temp range 163‚Äì237, total rain 290 over 4 days\",\n :max-temp 237,\n :dry-days 3,\n :unit :mm,\n :city \"London\",\n :days 7,\n :total-rain 290,\n :rainy-days 4,\n :mean-temp 202,\n :min-temp 163}\n\nNo log output ‚Äî served entirely from the in-memory cache.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#changing-an-upstream-input",
    "href": "pocket_book.real_world_walkthrough.html#changing-an-upstream-input",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Changing an upstream input",
    "text": "Changing an upstream input\nNow suppose we want a different city. The entire pipeline recomputes because the root input changed:\n\n(println \"\\n=== Different city ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Different city ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"Paris\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:36.001 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/summary\n10:06:36.001 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/temperature-trends\n10:06:36.001 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/clean-data\n10:06:36.001 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/fetch-readings\n  Fetching readings for Paris ...\n10:06:36.303 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/49/(pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api})\n  Cleaning data for Paris with {:precision 10, :remove-nulls true} ...\n10:06:36.505 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/36/(pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\n  Analyzing temperature for Paris ...\n10:06:36.807 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/4d/4d7d654476f96c5a4808c863dd3c29e845d4a9f6\n10:06:36.808 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/rainfall-totals\n  Analyzing rainfall for Paris ...\n10:06:37.109 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/6d/(pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\n  Generating summary for Paris ...\n10:06:37.311 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-walkthrough/be/be026e38b57ab3e7ce5623eff753a616df974e93\n\"Elapsed time: 1311.025628 msecs\"\n\n\n\n\n\n{:report \"Paris: temp range 139‚Äì192, total rain 154 over 4 days\",\n :max-temp 192,\n :dry-days 3,\n :unit :mm,\n :city \"Paris\",\n :days 7,\n :total-rain 154,\n :rainy-days 4,\n :mean-temp 164,\n :min-temp 139}\n\nBut running it again is instant ‚Äî Paris is now cached too:\n\n(println \"\\n=== Paris again (cached) ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Paris again (cached) ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"Paris\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.319826 msecs\"\n\n\n\n\n\n{:report \"Paris: temp range 139‚Äì192, total rain 154 over 4 days\",\n :max-temp 192,\n :dry-days 3,\n :unit :mm,\n :city \"Paris\",\n :days 7,\n :total-rain 154,\n :rainy-days 4,\n :mean-temp 164,\n :min-temp 139}\n\nNo log output ‚Äî served entirely from the in-memory cache.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#inspecting-the-cache-on-disk",
    "href": "pocket_book.real_world_walkthrough.html#inspecting-the-cache-on-disk",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Inspecting the cache on disk",
    "text": "Inspecting the cache on disk\nLet‚Äôs look at what Pocket stored. The cache directory is organized by a SHA-1 prefix, then a human-readable directory named after the function and arguments.\n\nCache entries\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-walkthrough/17/17db4a12cb5e1ba8da076b6148be68b333bc6a16\",\n  :id\n  \"(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius})\",\n  :fn-name \"pocket-book.real-world-walkthrough/temperature-trends\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}]\",\n  :created-at \"2026-02-09T08:06:35.485068512Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/be/be026e38b57ab3e7ce5623eff753a616df974e93\",\n  :id\n  \"(pocket-book.real-world-walkthrough/summary (pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}))\",\n  :fn-name \"pocket-book.real-world-walkthrough/summary\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})]\",\n  :created-at \"2026-02-09T08:06:37.310197629Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/2c/(pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :fn-name \"pocket-book.real-world-walkthrough/clean-data\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}]\",\n  :created-at \"2026-02-09T08:06:35.183392972Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/6d/(pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :fn-name \"pocket-book.real-world-walkthrough/rainfall-totals\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}]\",\n  :created-at \"2026-02-09T08:06:37.108761748Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/50/50a0ffd14b1b8fa3a7ba7a1fa3d75cf5b26f0c57\",\n  :id\n  \"(pocket-book.real-world-walkthrough/summary (pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}))\",\n  :fn-name \"pocket-book.real-world-walkthrough/summary\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})]\",\n  :created-at \"2026-02-09T08:06:35.989495101Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/36/(pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :fn-name \"pocket-book.real-world-walkthrough/clean-data\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}]\",\n  :created-at \"2026-02-09T08:06:36.504746234Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/49/(pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api})\",\n  :fn-name \"pocket-book.real-world-walkthrough/fetch-readings\",\n  :args-str \"[{:city \\\"Paris\\\", :days 7, :source :api}]\",\n  :created-at \"2026-02-09T08:06:36.302192454Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/29/(pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api})\",\n  :fn-name \"pocket-book.real-world-walkthrough/fetch-readings\",\n  :args-str \"[{:city \\\"London\\\", :days 7, :source :api}]\",\n  :created-at \"2026-02-09T08:06:34.980022089Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/a4/(pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :fn-name \"pocket-book.real-world-walkthrough/rainfall-totals\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}]\",\n  :created-at \"2026-02-09T08:06:35.787520891Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/4d/4d7d654476f96c5a4808c863dd3c29e845d4a9f6\",\n  :id\n  \"(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius})\",\n  :fn-name \"pocket-book.real-world-walkthrough/temperature-trends\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}]\",\n  :created-at \"2026-02-09T08:06:36.806596162Z\"}]\n\n\n\nCache statistics\n\n(pocket/cache-stats)\n\n\n{:total-entries 10,\n :total-size-bytes 16707,\n :entries-per-fn\n {\"pocket-book.real-world-walkthrough/temperature-trends\" 2,\n  \"pocket-book.real-world-walkthrough/summary\" 2,\n  \"pocket-book.real-world-walkthrough/clean-data\" 2,\n  \"pocket-book.real-world-walkthrough/rainfall-totals\" 2,\n  \"pocket-book.real-world-walkthrough/fetch-readings\" 2}}\n\n\n\nDirectory tree\nEach entry contains either a value.nippy file (serialized value) or a nil marker, plus a meta.edn with metadata. Here is the actual cache directory tree, generated dynamically.\nNotice that some entries use human-readable directory names while others fall back to SHA-1 hashes ‚Äî this happens when the cache key (which includes the full upstream computation chain) exceeds 240 characters. The meta.edn inside each entry always contains the full details.\n\n(pocket/dir-tree)\n\n\npocket-walkthrough\n‚îú‚îÄ‚îÄ 17\n‚îÇ   ‚îî‚îÄ‚îÄ 17db4a12cb5e1ba8da076b6148be68b333bc6a16\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 29\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 2c\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 36\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 49\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 4d\n‚îÇ   ‚îî‚îÄ‚îÄ 4d7d654476f96c5a4808c863dd3c29e845d4a9f6\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 50\n‚îÇ   ‚îî‚îÄ‚îÄ 50a0ffd14b1b8fa3a7ba7a1fa3d75cf5b26f0c57\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 6d\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ a4\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îî‚îÄ‚îÄ be\n    ‚îî‚îÄ‚îÄ be026e38b57ab3e7ce5623eff753a616df974e93\n        ‚îú‚îÄ‚îÄ meta.edn\n        ‚îî‚îÄ‚îÄ value.nippy",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#cleanup",
    "href": "pocket_book.real_world_walkthrough.html#cleanup",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Cleanup",
    "text": "Cleanup\nRemove all cached data:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:37.332 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-walkthrough\n\n\n\n\n\n{:dir \"/tmp/pocket-walkthrough\", :existed true}\n\n\nsource: notebooks/pocket_book/real_world_walkthrough.clj",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html",
    "href": "pocket_book.concurrency.html",
    "title": "8¬† Concurrency",
    "section": "",
    "text": "The Challenge\nLast modified: 2026-02-08\nPocket guarantees that when multiple threads deref the same Cached value concurrently, the underlying computation executes exactly once. This chapter explains how that guarantee is achieved and demonstrates the concurrency scenarios it handles.\nThe naive approach to caching ‚Äî check if cached, compute if not ‚Äî has a race condition:\nBoth threads see the cache miss and both compute the value. For expensive computations (minutes, hours), this wastes resources.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#the-challenge",
    "href": "pocket_book.concurrency.html#the-challenge",
    "title": "8¬† Concurrency",
    "section": "",
    "text": "Thread A                    Thread B\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncheck cache ‚Üí miss          check cache ‚Üí miss\ncompute value               compute value     ‚Üê duplicate!\nstore result                store result",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#why-core.cache-alone-is-not-enough",
    "href": "pocket_book.concurrency.html#why-core.cache-alone-is-not-enough",
    "title": "8¬† Concurrency",
    "section": "Why core.cache Alone Is Not Enough",
    "text": "Why core.cache Alone Is Not Enough\nClojure‚Äôs core.cache provides lookup-or-miss which wraps the value function in a delay to prevent duplicate work across swap! retries within a single call. However, each call to lookup-or-miss creates its own delay, and the value function is evaluated inside the swap! body (via through-cache). This means concurrent callers racing into swap! can each see a miss and each start computing before any compare-and-swap succeeds:\nThread A                          Thread B\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nlookup-or-miss\n  create delay-A\n  swap!                           lookup-or-miss\n    through-cache ‚Üí miss            create delay-B\n    @delay-A ‚Üí computing...         swap!\n                                      through-cache ‚Üí miss\n                                      @delay-B ‚Üí computing... ‚Üê duplicate!\nThe swap! compare-and-swap ensures only one result enters the cache, but both computations have already started. The delay prevents redundant work across retries of a single swap! call ‚Äî it does not deduplicate across concurrent callers.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#seeing-the-problem",
    "href": "pocket_book.concurrency.html#seeing-the-problem",
    "title": "8¬† Concurrency",
    "section": "Seeing the Problem",
    "text": "Seeing the Problem\nWe can demonstrate this directly. Here we use core.cache.wrapped/lookup-or-miss with a slow computation and five concurrent threads. A CyclicBarrier synchronizes the threads so they all call lookup-or-miss at the same instant:\n\n(let [call-count (atom 0)\n      cache (cw/lru-cache-factory {} :threshold 32)\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      slow-fn (fn [_key]\n                (swap! call-count inc)\n                (Thread/sleep 500)\n                42)]\n  (let [futures (doall (for [_ (range 5)]\n                         (future\n                           (.await barrier)\n                           (cw/lookup-or-miss cache :same-key slow-fn))))\n        results (mapv deref futures)]\n    {:results results\n     :computation-count @call-count}))\n\n\n{:results [42 42 42 42 42], :computation-count 5}\n\nAll five threads computed the value independently ‚Äî computation-count is greater than 1 (typically 5). The delay inside lookup-or-miss prevented duplicate work on swap! retries within each thread, but concurrent callers each created and forced their own delay.\nScenario 1 (below) repeats this same pattern using Pocket, where the ConcurrentHashMap layer reduces the count to exactly 1.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#pockets-solution",
    "href": "pocket_book.concurrency.html#pockets-solution",
    "title": "8¬† Concurrency",
    "section": "Pocket‚Äôs Solution",
    "text": "Pocket‚Äôs Solution\nPocket adds a ConcurrentHashMap layer that ensures only one delay exists per cache key, regardless of how many threads request it:\n(def ^ConcurrentHashMap in-flight\n  (java.util.concurrent.ConcurrentHashMap.))\n\n;; Inside the lookup-or-miss miss-fn:\n(let [d (.computeIfAbsent\n          in-flight path\n          (fn [_]\n            (delay\n              (try\n                ;; disk check + computation\n                (finally\n                  (.remove in-flight path))))))]\n  @d)\ncomputeIfAbsent is atomic: the first thread creates and inserts the delay; all subsequent threads for the same key receive the same delay instance. Since a Clojure delay executes its body exactly once, the computation runs once and all threads share the result.\n\nFailure Handling\nThe finally block removes the entry from in-flight after computation (success or failure). If a computation throws, the next caller gets a fresh delay and a fresh attempt ‚Äî exceptions are never cached.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#architecture-layers",
    "href": "pocket_book.concurrency.html#architecture-layers",
    "title": "8¬† Concurrency",
    "section": "Architecture Layers",
    "text": "Architecture Layers\nflowchart TB\n    subgraph Request\n    D[deref Cached]\n    end\n    subgraph Synchronization\n    CHM[ConcurrentHashMapin-flight]\n    DEL[delay]\n    end\n    subgraph Caching\n    MEM[Memory Cachecore.cache]\n    DISK[Disk CacheNippy files]\n    end\n    D --&gt; CHM\n    CHM --&gt;|one delay per key| DEL\n    DEL --&gt;|on miss| MEM\n    MEM --&gt;|on miss| DISK\n    DISK --&gt;|on miss| COMP[Compute]\n    COMP --&gt; DISK\n    DISK --&gt; MEM\n    MEM --&gt; D\n\n\n\nLayer\nPurpose\nGuarantee\n\n\n\n\nConcurrentHashMap\nDelay creation\nOne delay per key\n\n\ndelay\nComputation\nOne execution per delay\n\n\ncore.cache (mem-cache)\nIn-memory caching\nFast repeated access\n\n\nDisk cache\nPersistence\nCross-session caching",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#concurrency-scenarios",
    "href": "pocket_book.concurrency.html#concurrency-scenarios",
    "title": "8¬† Concurrency",
    "section": "Concurrency Scenarios",
    "text": "Concurrency Scenarios\nThe following scenarios demonstrate Pocket‚Äôs thread-safety guarantees with various timing patterns.\n\nSetup\n\n(def test-dir \"/tmp/pocket-concurrency-test\")\n\n\n(pocket/set-base-cache-dir! test-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:38.108 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-concurrency-test\n\n\n\n\n\n\"/tmp/pocket-concurrency-test\"\n\nA counter to track how many times computation actually runs:\n\n(def computation-count (atom 0))\n\n\n(defn slow-computation\n  \"A computation that takes 300ms and increments a counter.\"\n  [x]\n  (swap! computation-count inc)\n  (Thread/sleep 300)\n  (* x x))\n\nConvenience function to reset state before each scenario:\n\n(defn fresh-scenario!\n  \"Reset counters and caches for a fresh scenario.\n   Returns the start time for timing measurements.\"\n  ([]\n   (fresh-scenario! {}))\n  ([{:keys [mem-cache-opts]\n     :or {mem-cache-opts {:policy :lru :threshold 3}}}]\n   (reset! computation-count 0)\n   (pocket/cleanup!)\n   (pocket/set-mem-cache-options! mem-cache-opts)\n   {:started-at (java.time.LocalTime/now)\n    :mem-cache mem-cache-opts}))\n\n\n\n\nScenario 1: Concurrent Deref of Same Value\nMultiple threads deref the same Cached object while the computation is still running. All should receive the same result from a single computation.\nTimeline (ms):   0         100        300        400\n                 ‚îÇ          ‚îÇ          ‚îÇ          ‚îÇ\nThread A:       [‚îÄ‚îÄ‚îÄ request ‚îÄ‚îÄ‚îÄ][‚îÄ‚îÄ‚îÄ computing ‚îÄ‚îÄ‚îÄ]‚îÄ‚îÄ‚Üí result\nThread B:                  [‚îÄ‚îÄ‚îÄ request ‚îÄ‚îÄ‚îÄ][ wait ]‚îÄ‚îÄ‚Üí result\n                                             ‚Üë\n                             B waits for A's computation\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:38.114 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:38.114 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n10:06:38.114 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x3982132b \"10:06:38.114407663\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nLaunch 5 threads that all deref the same cached value:\n\n(let [cached-val (pocket/cached #'slow-computation 10)\n      futures (doall (for [_ (range 5)]\n                       (future @cached-val)))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:38.119 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:38.421 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/93/(pocket-book.concurrency_slow-computation 10)\n\n\n\n\n\n{:results [100 100 100 100 100], :computation-count 1}\n\n\n\n\nScenario 2: Memory Cache Hit\nAfter the first computation, subsequent requests hit the memory cache instantly (no disk I/O, no recomputation).\nTimeline:\nThread A:  [‚îÄ‚îÄ computing ‚îÄ‚îÄ]\n                          ‚Üì\n                     mem-cache populated\nThread B:                         [request]‚îÄ‚îÄ‚Üí instant result\n                                      ‚Üë\n                                memory cache hit\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:38.427 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:38.427 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n10:06:38.427 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x26f32bcb \"10:06:38.427547918\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nFirst request computes, second is instant (memory hit):\n\n(let [;; First request - computes\n      result-1 @(pocket/cached #'slow-computation 20)\n      count-after-first @computation-count\n      ;; Second request - should hit memory cache\n      start (System/currentTimeMillis)\n      result-2 @(pocket/cached #'slow-computation 20)\n      elapsed (- (System/currentTimeMillis) start)\n      count-after-second @computation-count]\n  {:first-result result-1\n   :second-result result-2\n   :second-elapsed-ms elapsed\n   :computations-after-first count-after-first\n   :computations-after-second count-after-second})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:38.429 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:38.731 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/23/(pocket-book.concurrency_slow-computation 20)\n\n\n\n\n\n{:first-result 400,\n :second-result 400,\n :second-elapsed-ms 0,\n :computations-after-first 1,\n :computations-after-second 1}\n\n\n\n\nScenario 3: Disk Cache Hit After Memory Eviction\nFill the memory cache to evict our entry, then verify the next request reads from disk (not recomputes).\nTimeline:\n1. Compute value for arg=30          ‚Üí stored in mem + disk\n2. Compute 3 more values (31,32,33)  ‚Üí arg=30 evicted from mem (LRU)\n3. Request arg=30 again              ‚Üí disk cache hit (no recompute)\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:38.737 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:38.737 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n10:06:38.738 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x4f82e2e7 \"10:06:38.738048307\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nStep 1: Compute initial value, then fill cache to cause eviction:\n\n(let [;; Compute arg=30\n      _ @(pocket/cached #'slow-computation 30)\n      ;; Fill cache to evict arg=30 (threshold=3)\n      _ @(pocket/cached #'slow-computation 31)\n      _ @(pocket/cached #'slow-computation 32)\n      _ @(pocket/cached #'slow-computation 33)\n      count-before-retry @computation-count\n      ;; Request arg=30 again - should hit disk\n      result @(pocket/cached #'slow-computation 30)\n      count-after-retry @computation-count]\n  {:result result\n   :computations-before-retry count-before-retry\n   :computations-after-retry count-after-retry\n   :disk-hit? (= count-before-retry count-after-retry)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:38.740 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:39.041 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/f4/(pocket-book.concurrency_slow-computation 30)\n10:06:39.041 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:39.343 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/35/(pocket-book.concurrency_slow-computation 31)\n10:06:39.344 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:39.645 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/61/(pocket-book.concurrency_slow-computation 32)\n10:06:39.646 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:39.947 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/f6/(pocket-book.concurrency_slow-computation 33)\n10:06:39.948 DEBUG scicloj.pocket.impl.cache - Cache hit (disk): pocket-book.concurrency/slow-computation /tmp/pocket-concurrency-test/f4/(pocket-book.concurrency_slow-computation 30)\n\n\n\n\n\n{:result 900,\n :computations-before-retry 4,\n :computations-after-retry 4,\n :disk-hit? true}\n\n\n\n\nScenario 4: Failure and Retry\nWhen a computation fails, the exception is not cached. The next caller gets a fresh attempt.\nTimeline:\n1. Thread A requests ‚Üí computation fails (exception)\n2. Thread B requests ‚Üí fresh computation succeeds\n3. Thread C requests ‚Üí cache hit (no recompute)\n\n(def failure-count (atom 0))\n\n\n(defn flaky-computation\n  \"Fails on first call, succeeds thereafter.\"\n  [x]\n  (if (zero? @failure-count)\n    (do (swap! failure-count inc)\n        (throw (ex-info \"Temporary failure\" {:x x})))\n    (do (swap! failure-count inc)\n        (* x 100))))\n\n\n(do\n  (reset! failure-count 0)\n  (pocket/cleanup!)\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:39.956 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n\n\n\n\n\n:ready\n\nFirst attempt fails, second succeeds, third hits cache:\n\n(let [;; First attempt - fails\n      attempt-1 (try\n                  @(pocket/cached #'flaky-computation 5)\n                  (catch Exception e {:error (.getMessage e)}))\n      count-after-1 @failure-count\n      ;; Second attempt - succeeds\n      attempt-2 @(pocket/cached #'flaky-computation 5)\n      count-after-2 @failure-count\n      ;; Third attempt - cache hit\n      attempt-3 @(pocket/cached #'flaky-computation 5)\n      count-after-3 @failure-count]\n  {:attempt-1 attempt-1\n   :attempt-2 attempt-2\n   :attempt-3 attempt-3\n   :counts [count-after-1 count-after-2 count-after-3]})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:39.958 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/flaky-computation\n10:06:39.959 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/flaky-computation\n10:06:39.960 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/53/(pocket-book.concurrency_flaky-computation 5)\n\n\n\n\n\n{:attempt-1 {:error \"Temporary failure\"},\n :attempt-2 500,\n :attempt-3 500,\n :counts [1 2 2]}\n\n\n\n\nScenario 5: Different Arguments Compute in Parallel\nRequests with different arguments run in parallel (no unnecessary serialization).\nTimeline (ms):   0                   300\n                 ‚îÇ                    ‚îÇ\nThread A (x=40): [‚îÄ‚îÄ‚îÄ‚îÄ computing ‚îÄ‚îÄ‚îÄ‚îÄ]‚îÄ‚îÄ‚Üí 1600\nThread B (x=41): [‚îÄ‚îÄ‚îÄ‚îÄ computing ‚îÄ‚îÄ‚îÄ‚îÄ]‚îÄ‚îÄ‚Üí 1681\nThread C (x=42): [‚îÄ‚îÄ‚îÄ‚îÄ computing ‚îÄ‚îÄ‚îÄ‚îÄ]‚îÄ‚îÄ‚Üí 1764\n                  ‚Üë\n            All start ~simultaneously, run in parallel\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:39.963 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:39.964 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n10:06:39.964 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x1034d35 \"10:06:39.964193892\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\n\n(let [start (System/currentTimeMillis)\n      futures (mapv #(future @(pocket/cached #'slow-computation %))\n                    [40 41 42])\n      results (mapv deref futures)\n      elapsed (- (System/currentTimeMillis) start)]\n  {:results results\n   :elapsed-ms elapsed\n   :parallel? (&lt; elapsed 500)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:39.966 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:39.966 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:39.966 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:40.268 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/19/(pocket-book.concurrency_slow-computation 40)\n10:06:40.268 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/cb/(pocket-book.concurrency_slow-computation 42)\n10:06:40.268 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/b2/(pocket-book.concurrency_slow-computation 41)\n\n\n\n\n\n{:results [1600 1681 1764], :elapsed-ms 304, :parallel? true}\n\n\n\n\nScenario 6: Disk Hit with Empty Memory Cache\nClear memory cache while keeping disk cache. All requests should read from disk without recomputing.\nSetup: value for arg=50 is on disk but NOT in memory\n\nThreads A, B, C all request x=50\n‚Üí All read from disk (no computation)\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:40.275 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:40.275 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n10:06:40.275 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x24a41a48 \"10:06:40.276009583\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nCompute, clear memory, then hit disk:\n\n(let [;; Compute and cache arg=50\n      _ @(pocket/cached #'slow-computation 50)\n      count-after-compute @computation-count\n      ;; Clear only memory cache (disk remains)\n      _ (pocket/clear-mem-cache!)\n      ;; Multiple threads hit disk cache\n      futures (mapv (fn [_] (future @(pocket/cached #'slow-computation 50)))\n                    (range 3))\n      results (mapv deref futures)\n      count-after-disk-hits @computation-count]\n  {:results results\n   :count-after-compute count-after-compute\n   :count-after-disk-hits count-after-disk-hits\n   :no-recompute? (= count-after-compute count-after-disk-hits)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:40.278 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:40.580 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/3a/(pocket-book.concurrency_slow-computation 50)\n10:06:40.582 DEBUG scicloj.pocket.impl.cache - Cache hit (disk): pocket-book.concurrency/slow-computation /tmp/pocket-concurrency-test/3a/(pocket-book.concurrency_slow-computation 50)\n\n\n\n\n\n{:results [2500 2500 2500],\n :count-after-compute 1,\n :count-after-disk-hits 1,\n :no-recompute? true}\n\n\n\n\nScenario 7: Full Cache Hierarchy Test\nA comprehensive scenario testing all cache layers:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Step 1: Request x=60         ‚Üí COMPUTE (miss everywhere)    ‚îÇ\n‚îÇ Step 2: Request x=60 again   ‚Üí MEMORY HIT (instant)         ‚îÇ\n‚îÇ Step 3: Evict from memory    ‚Üí (fill cache with other vals) ‚îÇ\n‚îÇ Step 4: Request x=60         ‚Üí DISK HIT (read from disk)    ‚îÇ\n‚îÇ Step 5: Delete disk cache    ‚Üí invalidate!                  ‚îÇ\n‚îÇ Step 6: Request x=60         ‚Üí COMPUTE (miss everywhere)    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n(fresh-scenario! {:mem-cache-opts {:policy :lru :threshold 2}})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:40.588 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:40.588 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 2}\n10:06:40.588 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 2}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0xaea1770 \"10:06:40.588915678\"],\n :mem-cache {:policy :lru, :threshold 2}}\n\n\n(let [;; Step 1: Initial computation\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-1 @computation-count\n\n      ;; Step 2: Memory hit (should be instant)\n      start-2 (System/currentTimeMillis)\n      _ @(pocket/cached #'slow-computation 60)\n      elapsed-2 (- (System/currentTimeMillis) start-2)\n      count-step-2 @computation-count\n\n      ;; Step 3: Evict from memory by filling cache\n      _ @(pocket/cached #'slow-computation 61)\n      _ @(pocket/cached #'slow-computation 62)\n      count-step-3 @computation-count\n\n      ;; Step 4: Disk hit (memory miss)\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-4 @computation-count\n\n      ;; Step 5: Delete disk cache\n      _ (pocket/invalidate! #'slow-computation 60)\n      _ (pocket/clear-mem-cache!)\n\n      ;; Step 6: Recompute (miss everywhere)\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-6 @computation-count]\n  {:count-step-1 count-step-1\n   :elapsed-step-2 elapsed-2\n   :count-step-2 count-step-2\n   :count-step-3 count-step-3\n   :count-step-4 count-step-4\n   :count-step-6 count-step-6})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:40.591 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:40.892 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/f4/(pocket-book.concurrency_slow-computation 60)\n10:06:40.893 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:41.195 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/28/(pocket-book.concurrency_slow-computation 61)\n10:06:41.195 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:41.497 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/49/(pocket-book.concurrency_slow-computation 62)\n10:06:41.497 DEBUG scicloj.pocket.impl.cache - Cache hit (disk): pocket-book.concurrency/slow-computation /tmp/pocket-concurrency-test/f4/(pocket-book.concurrency_slow-computation 60)\n10:06:41.498 INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-concurrency-test/f4/(pocket-book.concurrency_slow-computation 60) existed= true\n10:06:41.498 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:41.800 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/f4/(pocket-book.concurrency_slow-computation 60)\n\n\n\n\n\n{:count-step-1 1,\n :elapsed-step-2 1,\n :count-step-2 1,\n :count-step-3 3,\n :count-step-4 3,\n :count-step-6 4}\n\n\n\nScenario 8: Synchronized Start (Barrier)\nA stricter variant of Scenario 1 that uses a CyclicBarrier to guarantee all threads enter deref at the same instant. This is the direct contrast to the core.cache demonstration above.\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:41.806 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:41.806 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n10:06:41.806 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x98668aa \"10:06:41.806727908\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @(pocket/cached #'slow-computation 70))))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:41.812 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:42.113 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/24/(pocket-book.concurrency_slow-computation 70)\n\n\n\n\n\n{:results [4900 4900 4900 4900 4900], :computation-count 1}\n\n\n\n\nScenario 9: Concurrent Pipeline Deref\nA pipeline where step 2 takes a Cached step 1 result as an argument. Multiple threads deref step 2 concurrently ‚Äî both steps should compute exactly once.\n\n(def step-a-count (atom 0))\n\n\n(def step-b-count (atom 0))\n\n\n(defn pipeline-step-a\n  \"First pipeline step: slow transform.\"\n  [x]\n  (swap! step-a-count inc)\n  (Thread/sleep 200)\n  (* x 10))\n\n\n(defn pipeline-step-b\n  \"Second pipeline step: depends on step-a result.\"\n  [data]\n  (swap! step-b-count inc)\n  (Thread/sleep 200)\n  (+ data 1))\n\n\n(do\n  (reset! step-a-count 0)\n  (reset! step-b-count 0)\n  (pocket/cleanup!)\n  (pocket/set-mem-cache-options! {:policy :lru :threshold 10})\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:42.123 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:42.124 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 10}\n10:06:42.124 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 10}\n\n\n\n\n\n:ready\n\nBuild a two-step pipeline, then deref from 5 threads:\n\n(let [cached-a (pocket/cached #'pipeline-step-a 7)\n      cached-b (pocket/cached #'pipeline-step-b cached-a)\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @cached-b)))\n      results (mapv deref futures)]\n  {:results results\n   :step-a-count @step-a-count\n   :step-b-count @step-b-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:42.129 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/pipeline-step-b\n10:06:42.129 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/pipeline-step-a\n10:06:42.330 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/8f/(pocket-book.concurrency_pipeline-step-a 7)\n10:06:42.532 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/79/(pocket-book.concurrency_pipeline-step-b (pocket-book.concurrency_pipeline-step-a 7))\n\n\n\n\n\n{:results [71 71 71 71 71], :step-a-count 1, :step-b-count 1}\n\n\n\n\nScenario 10: Concurrent Failure\nMultiple threads hit a computation that throws. All threads should see the exception. A subsequent attempt should succeed (fresh delay).\n\n(def concurrent-fail-count (atom 0))\n\n\n(defn fail-once-computation\n  \"Fails when concurrent-fail-count is 0, succeeds after.\"\n  [x]\n  (let [n (swap! concurrent-fail-count inc)]\n    (when (= 1 n)\n      (Thread/sleep 200)\n      (throw (ex-info \"Transient error\" {:x x})))\n    (Thread/sleep 100)\n    (* x x)))\n\n\n(do\n  (reset! concurrent-fail-count 0)\n  (pocket/cleanup!)\n  (pocket/set-mem-cache-options! {:policy :lru :threshold 10})\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:42.541 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:42.542 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 10}\n10:06:42.542 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 10}\n\n\n\n\n\n:ready\n\n5 threads hit the failing computation simultaneously:\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         (try\n                           {:value @(pocket/cached #'fail-once-computation 8)}\n                           (catch Exception e\n                             {:error (.getMessage e)})))))\n      first-results (mapv deref futures)\n      errors (filterv :error first-results)\n      successes (filterv :value first-results)]\n  {:first-round-errors (count errors)\n   :first-round-successes (count successes)\n   :retry @(pocket/cached #'fail-once-computation 8)\n   :total-calls @concurrent-fail-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:42.548 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/fail-once-computation\n10:06:42.750 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/fail-once-computation\n10:06:42.851 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/4a/(pocket-book.concurrency_fail-once-computation 8)\n\n\n\n\n\n{:first-round-errors 5,\n :first-round-successes 0,\n :retry 64,\n :total-calls 2}\n\n\n\n\nScenario 11: Eviction Under Contention\nWith a very small cache (threshold=2) and many concurrent requests, memory eviction happens frequently. The in-flight map still prevents duplicate computation for the same key.\n\n(fresh-scenario! {:mem-cache-opts {:policy :lru :threshold 2}})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:42.858 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:42.858 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 2}\n10:06:42.858 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 2}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x1ecdd971 \"10:06:42.858262987\"],\n :mem-cache {:policy :lru, :threshold 2}}\n\nLaunch 4 threads per key, for 3 different keys. Each key should compute exactly once despite eviction pressure.\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 12)\n      futures (doall\n               (for [x [80 81 82]\n                     _ (range 4)]\n                 (future\n                   (.await barrier)\n                   @(pocket/cached #'slow-computation x))))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count\n   :expected-results (vec (for [x [80 81 82]\n                                _ (range 4)]\n                            (* x x)))})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:42.868 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:42.868 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:42.869 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:43.170 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/31/(pocket-book.concurrency_slow-computation 80)\n10:06:43.170 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/63/(pocket-book.concurrency_slow-computation 81)\n10:06:43.170 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/e0/(pocket-book.concurrency_slow-computation 82)\n\n\n\n\n\n{:results\n [6400 6400 6400 6400 6561 6561 6561 6561 6724 6724 6724 6724],\n :computation-count 3,\n :expected-results\n [6400 6400 6400 6400 6561 6561 6561 6561 6724 6724 6724 6724]}\n\n\n\n\nScenario 12: Rapid Deref After Invalidation\nInvalidate a cached value and immediately re-request from multiple threads. The re-request should compute exactly once.\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:43.177 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n10:06:43.177 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n10:06:43.177 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x7f4b3601 \"10:06:43.177168992\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nCompute and cache a value:\n\n(let [_ @(pocket/cached #'slow-computation 90)\n      count-after-first @computation-count\n      ;; Invalidate\n      _ (pocket/invalidate! #'slow-computation 90)\n      ;; Immediately re-request from 5 concurrent threads\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @(pocket/cached #'slow-computation 90))))\n      results (mapv deref futures)\n      count-after-retry @computation-count]\n  {:results results\n   :count-after-first count-after-first\n   :count-after-retry count-after-retry})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:43.181 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:43.482 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/22/(pocket-book.concurrency_slow-computation 90)\n10:06:43.483 INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-concurrency-test/22/(pocket-book.concurrency_slow-computation 90) existed= true\n10:06:43.484 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n10:06:43.785 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-concurrency-test/22/(pocket-book.concurrency_slow-computation 90)\n\n\n\n\n\n{:results [8100 8100 8100 8100 8100],\n :count-after-first 1,\n :count-after-retry 2}",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#design-notes",
    "href": "pocket_book.concurrency.html#design-notes",
    "title": "8¬† Concurrency",
    "section": "Design Notes",
    "text": "Design Notes\n\nWhy Not Use Caffeine?\nCaffeine (via Cloffeine) provides LoadingCache with built-in computeIfAbsent synchronization. This would eliminate the need for our explicit in-flight map.\nWe chose core.cache because:\n\nLighter dependency (pure Clojure data structures)\nPluggable, immutable cache implementations\nFamiliar to the Clojure ecosystem\n\nTrade-off: We need the explicit ConcurrentHashMap synchronization layer.\n\n\nThe computeIfAbsent Contract\nFrom the Java documentation:\n\nThe mapping function should not modify this map during computation.\n\nOur implementation is safe: the mapping function only creates a delay (cheap, instantaneous). The actual computation happens when the delay is dereferenced, outside of computeIfAbsent.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#cleanup",
    "href": "pocket_book.concurrency.html#cleanup",
    "title": "8¬† Concurrency",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:43.792 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n\n\n\n\n\n{:dir \"/tmp/pocket-concurrency-test\", :existed true}\n\n\n(pocket/reset-mem-cache-options!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:43.793 INFO scicloj.pocket - Mem-cache options reset to defaults: {:policy :lru, :threshold 256}\n10:06:43.794 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\nsource: notebooks/pocket_book/concurrency.clj",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html",
    "href": "pocket_book.extending_pocket.html",
    "title": "9¬† Extending Pocket",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#setup",
    "href": "pocket_book.extending_pocket.html#setup",
    "title": "9¬† Extending Pocket",
    "section": "",
    "text": "(def cache-dir \"/tmp/pocket-extending\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:43.918 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-extending\n\n\n\n\n\n\"/tmp/pocket-extending\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:43.919 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending\n\n\n\n\n\n{:dir \"/tmp/pocket-extending\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#the-pidentifiable-protocol",
    "href": "pocket_book.extending_pocket.html#the-pidentifiable-protocol",
    "title": "9¬† Extending Pocket",
    "section": "The PIdentifiable protocol",
    "text": "The PIdentifiable protocol\nPocket derives cache keys from the identity of the function and its arguments. The PIdentifiable protocol controls how each value contributes to the cache key:\n\n(kind/doc #'pocket/-&gt;id)\n\n\n-&gt;id\n[x]\nReturn a cache key representation of a value. Dispatches via the PIdentifiable protocol.\nFor derefed Cached values, returns the same lightweight identity as the original Cached reference ‚Äî the origin registry preserves the link automatically (see cache_keys notebook for details).",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#default-behaviors",
    "href": "pocket_book.extending_pocket.html#default-behaviors",
    "title": "9¬† Extending Pocket",
    "section": "Default behaviors",
    "text": "Default behaviors\nPocket provides default implementations for common types:\nA var‚Äôs identity is its fully-qualified name:\n\n(pocket/-&gt;id #'clojure.core/map)\n\n\nclojure.core/map\n\nA map‚Äôs identity is itself (keys are deep-sorted later for stable cache paths):\n\n(pocket/-&gt;id {:b 2 :a 1})\n\n\n{:b 2, :a 1}\n\nA Cached object‚Äôs identity captures the full computation graph:\n\n(defn add [x y] (+ x y))\n\n\n(pocket/-&gt;id (pocket/cached #'add 1 2))\n\n\n(pocket-book.extending-pocket/add 1 2)\n\nA derefed Cached value carries its origin identity ‚Äî see Under the hood: cache keys for details. This works for maps, vectors, sets, and datasets:\n\n(defn make-pair [a b] {:a a :b b})\n\n\n(let [c (pocket/cached #'make-pair 1 2)]\n  (= (pocket/-&gt;id (deref c)) (pocket/-&gt;id c)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:43.925 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/make-pair\n10:06:43.926 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/55/(pocket-book.extending-pocket_make-pair 1 2)\n\n\n\n\n\ntrue\n\nnil is handled:\n\n(pocket/-&gt;id nil)\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#built-in-dataset-support",
    "href": "pocket_book.extending_pocket.html#built-in-dataset-support",
    "title": "9¬† Extending Pocket",
    "section": "Built-in dataset support",
    "text": "Built-in dataset support\nPocket recognizes tech.ml.dataset datasets (the type behind tablecloth) and derives their identity from the actual column data and metadata ‚Äî including annotations like inference targets.\nA dataset‚Äôs identity is a map of column names to {:data [...] :meta {...}}:\n\n(def example-ds\n  (-&gt; (tc/dataset {:x (range 30) :y (range 30)})\n      (ds-mod/set-inference-target :y)))\n\n\n(pocket/-&gt;id example-ds)\n\n\n{:x\n {:data\n  [0\n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29],\n  :meta {:name :x, :datatype :int64, :n-elems 30}},\n :y\n {:data\n  [0\n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29],\n  :meta\n  {:name :y, :datatype :int64, :n-elems 30, :inference-target? true}}}\n\nTwo datasets with identical content produce the same identity, even when the default toString representation would truncate rows:\n\n(def ds-a (tc/dataset {:x (range 30) :y (range 30)}))\n\n\n(def ds-b (tc/dataset {:x (range 30) :y (range 30)}))\n\n\n(= (pocket/-&gt;id ds-a) (pocket/-&gt;id ds-b))\n\n\ntrue\n\nDatasets with different content produce different identities, even when the difference falls in rows that toString would elide:\n\n(def ds-c (tc/dataset {:x (range 30)\n                       :y (concat (range 15) [999] (range 16 30))}))\n\n\n(= (pocket/-&gt;id ds-a) (pocket/-&gt;id ds-c))\n\n\nfalse\n\nThis means caching functions that take datasets as arguments (like ml/train) works correctly regardless of dataset size.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#extending-for-custom-types",
    "href": "pocket_book.extending_pocket.html#extending-for-custom-types",
    "title": "9¬† Extending Pocket",
    "section": "Extending for custom types",
    "text": "Extending for custom types\nIf you have domain-specific types, you can control how they appear in cache keys by extending PIdentifiable. This is useful when the default behavior (which uses the object itself) doesn‚Äôt produce stable or meaningful cache keys.\nFor example, suppose you have a record representing a dataset reference:\n\n(defrecord DatasetRef [source version])\n\nWithout extending the protocol, a DatasetRef would be treated as a plain map ‚Äî its identity would be something like {:source \"census\", :version 3}, which works but isn‚Äôt very readable in cache directory names.\nLet‚Äôs give it a concise, meaningful identity:\n\n(extend-protocol pocket/PIdentifiable\n  DatasetRef\n  (-&gt;id [this]\n    (symbol (str (:source this) \"-v\" (:version this)))))\n\nNow the identity is a clean symbol:\n\n(pocket/-&gt;id (-&gt;DatasetRef \"census\" 3))\n\n\ncensus-v3",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#using-custom-types-in-cached-computations",
    "href": "pocket_book.extending_pocket.html#using-custom-types-in-cached-computations",
    "title": "9¬† Extending Pocket",
    "section": "Using custom types in cached computations",
    "text": "Using custom types in cached computations\n\n(defn analyze-dataset\n  \"Simulate analyzing a dataset.\"\n  [dataset-ref opts]\n  (println \"  Analyzing\" (:source dataset-ref) \"v\" (:version dataset-ref) \"...\")\n  (Thread/sleep 200)\n  {:source (:source dataset-ref)\n   :version (:version dataset-ref)\n   :rows 1000\n   :method (:method opts)})\n\nThe cache key now includes our custom identity:\n\n(def analysis\n  (pocket/cached #'analyze-dataset\n                 (-&gt;DatasetRef \"census\" 3)\n                 {:method :regression}))\n\n\n(pocket/-&gt;id analysis)\n\n\n(pocket-book.extending-pocket/analyze-dataset\n census-v3\n {:method :regression})\n\nFirst deref computes:\n\n(deref analysis)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:43.951 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset\n  Analyzing census v 3 ...\n10:06:44.153 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/62/(pocket-book.extending-pocket_analyze-dataset census-v3 {:method :regression})\n\n\n\n\n\n{:source \"census\", :version 3, :rows 1000, :method :regression}\n\nSecond deref loads from cache:\n\n(deref analysis)\n\n\n{:source \"census\", :version 3, :rows 1000, :method :regression}\n\nA different version creates a different cache entry:\n\n(deref (pocket/cached #'analyze-dataset\n                      (-&gt;DatasetRef \"census\" 4)\n                      {:method :regression}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.158 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset\n  Analyzing census v 4 ...\n10:06:44.360 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/f6/(pocket-book.extending-pocket_analyze-dataset census-v4 {:method :regression})\n\n\n\n\n\n{:source \"census\", :version 4, :rows 1000, :method :regression}",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#whats-on-disk",
    "href": "pocket_book.extending_pocket.html#whats-on-disk",
    "title": "9¬† Extending Pocket",
    "section": "What‚Äôs on disk?",
    "text": "What‚Äôs on disk?\nThe cache directory names reflect our custom identities:\n\n(pocket/dir-tree)\n\n\npocket-extending\n‚îú‚îÄ‚îÄ 55\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.extending-pocket_make-pair 1 2)\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 62\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.extending-pocket_analyze-dataset census-v3 {:method :regression})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îî‚îÄ‚îÄ f6\n    ‚îî‚îÄ‚îÄ (pocket-book.extending-pocket_analyze-dataset census-v4 {:method :regression})\n        ‚îú‚îÄ‚îÄ meta.edn\n        ‚îî‚îÄ‚îÄ value.nippy",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#guidelines",
    "href": "pocket_book.extending_pocket.html#guidelines",
    "title": "9¬† Extending Pocket",
    "section": "Guidelines",
    "text": "Guidelines\nWhen extending PIdentifiable:\n\nReturn stable values. The identity must be the same across JVM sessions for the same logical input. Avoid including timestamps, random values, or object addresses.\nReturn distinct values. Two logically different inputs must produce different identities. If they don‚Äôt, Pocket will treat them as the same computation and return stale results.\nKeep it readable. The identity becomes part of the cache directory name. Symbols and short strings work well.\nPrefer symbols or keywords over complex nested structures. They produce clean, short directory names.\nRecords and plain maps can collide. A record like (-&gt;DatasetRef \"census\" 3) and a plain map {:source \"census\" :version 3} produce the same default cache key (both are maps with the same keys). If you use records as cache arguments, extend PIdentifiable to give them a distinct identity ‚Äî as shown above.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#custom-nippy-serialization",
    "href": "pocket_book.extending_pocket.html#custom-nippy-serialization",
    "title": "9¬† Extending Pocket",
    "section": "Custom Nippy serialization",
    "text": "Custom Nippy serialization\nPocket uses Nippy for fast binary serialization. Most Clojure data structures and many Java objects serialize automatically. However, if we cache values containing custom types, we may need to extend Nippy.\nCommon types that work out of the box:\n\nAll Clojure collections (vectors, maps, sets, lists)\nPrimitives, strings, keywords, symbols\nJava Date, UUID, BigDecimal, BigInteger\nRecords and deftypes (if all fields are serializable)\nTribuo ML models\ntech.ml.dataset datasets\n\nTypes that require extension:\n\nObjects with unserializable fields (e.g., open file handles, database connections, thread pools)\nCustom Java classes from external libraries ‚Äî even if they implement Serializable, Nippy 3 checks a thaw allowlist and will quarantine classes not on it. Extending Nippy directly (as shown below) avoids this issue entirely.\n\n\nExample: a custom model type\nSuppose we have a record that wraps model weights. Out of the box, Nippy can freeze records whose fields are all serializable ‚Äî but let‚Äôs say our record contains a Java array or another type that Nippy doesn‚Äôt handle natively. We extend freeze and thaw explicitly:\n\n(defrecord MyModel [weights bias])\n\n\n(nippy/extend-freeze MyModel :my-model\n                     [x data-output]\n                     (nippy/freeze-to-out! data-output (:weights x))\n                     (nippy/freeze-to-out! data-output (:bias x)))\n\n\nnil\n\n\n(do (nippy/extend-thaw :my-model\n                       [data-input]\n                       (-&gt;MyModel (nippy/thaw-from-in! data-input)\n                                  (nippy/thaw-from-in! data-input)))\n    :done)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\nWarning: resetting Nippy thaw for custom type with id: :my-model\n\n\n\n\n\n:done\n\nWe can verify the round-trip works:\n\n(def original (-&gt;MyModel [0.5 -0.3 1.2] 0.1))\n\n\n(= original (nippy/thaw (nippy/freeze original)))\n\n\ntrue\n\nNow caching a function that returns a MyModel works seamlessly:\n\n(defn train-my-model [data]\n  (-&gt;MyModel (mapv #(* % 0.01) data) 0.42))\n\n\n(let [result (deref (pocket/cached #'train-my-model [10 20 30]))]\n  result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.387 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/train-my-model\n10:06:44.388 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/ac/(pocket-book.extending-pocket_train-my-model [10 20 30])\n\n\n\n\n\n{:weights [0.1 0.2 0.3], :bias 0.42}\n\nSee the Nippy documentation for more details.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#cleanup",
    "href": "pocket_book.extending_pocket.html#cleanup",
    "title": "9¬† Extending Pocket",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.391 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending\n\n\n\n\n\n{:dir \"/tmp/pocket-extending\", :existed true}\n\n\nsource: notebooks/pocket_book/extending_pocket.clj",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html",
    "href": "pocket_book.ml_workflows.html",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nThis chapter demonstrates Pocket in a realistic machine learning scenario. If you‚Äôre new to ML, don‚Äôt worry ‚Äî we‚Äôll explain the concepts as we go. The focus is on how caching helps when you‚Äôre exploring many combinations of data, features, and models.\nThe problem: We want to predict a numeric value (like house prices or temperature) from input data. This is called regression. We‚Äôll generate synthetic data, try different ways of preparing it, and compare two learning algorithms.\nWhy caching matters: Training models can be slow. When you‚Äôre experimenting ‚Äî tweaking parameters, trying new features ‚Äî you don‚Äôt want to recompute everything each time. Pocket caches each step independently, so only the parts you changed get recomputed.\nWhat we‚Äôll cover:\nNote: This notebook uses tablecloth for data manipulation, metamorph.ml and tribuo for ML, and Plotly.js for visualization. These are not Pocket dependencies ‚Äî they illustrate a realistic ML workflow. All output is shown inline; to reproduce it, add noj to your project dependencies.\nWhy synthetic data? Working with synthetic data is a standard practice in machine learning. Because we define the true relationship (\\(y = \\sin(x) \\cdot x\\)), we can measure exactly how well each model recovers it ‚Äî something impossible with real-world data where the ground truth is unknown. Synthetic experiments let us isolate one variable at a time: does feature engineering help? How does noise affect each algorithm? These controlled comparisons build intuition that transfers to real problems. In our case, we‚Äôll see that a linear model is helpless against a nonlinear target unless we give it the right features, while a decision tree handles the shape on its own but pays a different price when noise increases.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#setup",
    "href": "pocket_book.ml_workflows.html#setup",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "",
    "text": "(ns pocket-book.ml-workflows\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Data processing:\n   [tablecloth.api :as tc]\n   [tablecloth.column.api :as tcc]\n   [tech.v3.dataset :as ds]\n   [tech.v3.dataset.modelling :as ds-mod]\n   ;; Machine learning:\n   [scicloj.metamorph.ml :as ml]\n   [scicloj.metamorph.ml.loss :as loss]\n   [scicloj.ml.tribuo]))\n\n\n(def cache-dir \"/tmp/pocket-regression\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.475 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-regression\n\n\n\n\n\n\"/tmp/pocket-regression\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.477 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#pipeline-functions",
    "href": "pocket_book.ml_workflows.html#pipeline-functions",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Pipeline functions",
    "text": "Pipeline functions\nThese are the steps of our ML pipeline ‚Äî plain Clojure functions that know nothing about caching. Pocket will wrap them later.\nData generation: make-regression-data creates a synthetic dataset from a ground-truth function. We control the sample size, noise level, and random seed ‚Äî all of which become part of the cache key, so changing any parameter triggers recomputation.\n\n(defn make-regression-data\n  \"Generate a synthetic regression dataset.\n  `f` is a function from x to y (the ground truth).\n  Optional `outlier-fraction` (0‚Äì1) and `outlier-scale` inject\n  corrupted x values to simulate sensor glitches.\"\n  [{:keys [f n noise-sd seed outlier-fraction outlier-scale]\n    :or {outlier-fraction 0 outlier-scale 10}}]\n  (let [rng (java.util.Random. (long seed))\n        xs (vec (repeatedly n #(* 10.0 (.nextDouble rng))))\n        xs-final (if (pos? outlier-fraction)\n                   (let [out-rng (java.util.Random. (+ (long seed) 7919))]\n                     (mapv (fn [x]\n                             (if (&lt; (.nextDouble out-rng) outlier-fraction)\n                               (+ x (* (double outlier-scale) (.nextGaussian out-rng)))\n                               x))\n                           xs))\n                   xs)\n        ys (mapv (fn [x] (+ (double (f x))\n                            (* (double noise-sd) (.nextGaussian rng))))\n                 xs)]\n    (-&gt; (tc/dataset {:x xs-final :y ys})\n        (ds-mod/set-inference-target :y))))\n\nSplitting: split-dataset divides data into training and test sets. This is a cached step so the full provenance chain ‚Äî from parameters through data generation to the split ‚Äî is captured in the DAG.\n\n(defn split-dataset\n  \"Split a dataset into train/test using holdout.\"\n  [ds {:keys [seed]}]\n  (first (tc/split-&gt;seq ds :holdout {:seed seed})))\n\nFeature engineering: prepare-features transforms raw data by adding derived columns. The choice of feature set is a key hyperparameter ‚Äî a linear model with only :raw features can‚Äôt learn nonlinear patterns, but :trig or :poly+trig features give it the building blocks it needs.\n\n(defn prepare-features\n  \"Add derived columns to a dataset according to `feature-set`.\n  Supported feature sets:\n\n  - `:raw`       ‚Äî no extra columns\n  - `:quadratic` ‚Äî add x¬≤\n  - `:trig`      ‚Äî add sin(x) and cos(x)\n  - `:poly+trig` ‚Äî add x¬≤, sin(x), and cos(x)\"\n  [ds feature-set]\n  (let [x (:x ds)]\n    (-&gt; (case feature-set\n          :raw ds\n          :quadratic (tc/add-columns ds {:x2 (tcc/sq x)})\n          :trig (tc/add-columns ds {:sin-x (tcc/sin x)\n                                    :cos-x (tcc/cos x)})\n          :poly+trig (tc/add-columns ds {:x2 (tcc/sq x)\n                                         :sin-x (tcc/sin x)\n                                         :cos-x (tcc/cos x)}))\n        (ds-mod/set-inference-target :y))))\n\nTraining and evaluation: train-model fits a model to prepared data, and predict-and-rmse measures how well it generalizes to unseen test data. These are thin wrappers around metamorph.ml ‚Äî the caching value comes from avoiding redundant retraining when only downstream parameters change.\n\n(defn train-model\n  \"Train a model on a dataset.\"\n  [train-ds model-spec]\n  (ml/train train-ds model-spec))\n\n\n(defn predict-and-rmse\n  \"Predict on test data and return RMSE.\"\n  [test-ds model]\n  (let [pred (ml/predict test-ds model)]\n    (loss/rmse (:y test-ds) (:y pred))))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#ground-truth",
    "href": "pocket_book.ml_workflows.html#ground-truth",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Ground truth",
    "text": "Ground truth\nWe need a function to predict. In real problems you don‚Äôt know the true relationship ‚Äî that‚Äôs what you‚Äôre trying to learn. Here we define it explicitly so we can measure how well our models do.\nOur target is \\(y = \\sin(x) \\cdot x\\) ‚Äî a wavy curve that grows with \\(x\\). A straight line can‚Äôt fit this shape, so a simple linear model will struggle unless we help it with better features.\n\n(defn nonlinear-fn\n  \"y = sin(x) ¬∑ x\"\n  [x]\n  (* (Math/sin x) x))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#model-specifications",
    "href": "pocket_book.ml_workflows.html#model-specifications",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Model specifications",
    "text": "Model specifications\nWe‚Äôll compare two fundamentally different algorithms:\nLinear model (gradient descent): Finds the best straight-line (or hyperplane) relationship between inputs and output. Simple and fast, but can only learn linear patterns. Needs good features.\nDecision tree (CART): Learns by splitting data into regions based on thresholds (‚Äúif x &gt; 5, go left‚Äù). Can capture complex patterns automatically, but may overfit noisy data.\nThese algorithms respond differently to feature engineering ‚Äî that contrast is the heart of Part 1.\n\n(def linear-sgd-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"squared\"\n                        :type \"org.tribuo.regression.sgd.objectives.SquaredLoss\"}\n                       {:name \"linear-sgd\"\n                        :type \"org.tribuo.regression.sgd.linear.LinearSGDTrainer\"\n                        :properties {:objective \"squared\"\n                                     :epochs \"50\"\n                                     :loggingInterval \"10000\"}}]\n   :tribuo-trainer-name \"linear-sgd\"})\n\n\n(def cart-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"cart\"\n                        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                        :properties {:maxDepth \"8\"}}]\n   :tribuo-trainer-name \"cart\"})",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-1-feature-engineering-matters-for-some-models",
    "href": "pocket_book.ml_workflows.html#part-1-feature-engineering-matters-for-some-models",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 1 ‚Äî Feature engineering matters (for some models)",
    "text": "Part 1 ‚Äî Feature engineering matters (for some models)\nFeature engineering means transforming raw inputs into forms that help models learn. For example, if the true relationship involves \\(x^2\\), adding a squared column gives the model that pattern directly instead of forcing it to discover it.\nWe‚Äôll test four feature sets:\n\n:raw ‚Äî just the original \\(x\\) value\n:quadratic ‚Äî add \\(x^2\\)\n:trig ‚Äî add \\(\\sin(x)\\) and \\(\\cos(x)\\)\n:poly+trig ‚Äî add all three\n\nCrossed with two model types, that‚Äôs eight combinations. Every step is cached, so re-running is instant.\n\nGenerate data\n\n(def data-c\n  (pocket/cached #'make-regression-data\n                 {:f #'nonlinear-fn :n 500 :noise-sd 0.5 :seed 42}))\n\n\n(tc/head (deref data-c))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.487 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n10:06:44.494 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/b4/(pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42})\n\n\n\n\n\n_unnamed [5 2]:\n\n\n\n:x\n:y\n\n\n\n\n7.27563680\n6.74555252\n\n\n6.83223472\n4.07224915\n\n\n3.08719455\n0.22904859\n\n\n2.77078490\n0.47163659\n\n\n6.65548952\n2.81816258\n\n\n\n\n\n\nSplit into train and test\n\n(def split-c\n  (pocket/cached #'split-dataset data-c {:seed 42}))\n\nExtract train and test sets ‚Äî using keywords as cached functions. The DAG now traces from numerical parameters through data generation to the split to each subset.\n\n(def train-c (pocket/cached :train split-c))\n\n\n(def test-c (pocket/cached :test split-c))\n\n\n\nFeature sets\n\n(def feature-sets [:raw :quadratic :trig :poly+trig])\n\n\n\nPrepare features (cached)\nEach feature set applied to each split half is a separate cached computation ‚Äî eight in total.\n\n(def prepared\n  (into {}\n        (for [fs feature-sets\n              [role ds-c] [[:train train-c] [:test test-c]]]\n          [[fs role]\n           (pocket/cached #'prepare-features ds-c fs)])))\n\n\n\nTrain models (cached)\nTwo models per feature set ‚Äî eight cached training runs.\n\n(def models\n  (into {}\n        (for [fs feature-sets\n              [model-name spec] [[:sgd linear-sgd-spec]\n                                 [:cart cart-spec]]]\n          [[fs model-name]\n           (pocket/cached #'train-model\n                          (prepared [fs :train])\n                          spec)])))\n\n\n\nResults\n\n(def feature-results\n  (vec (for [fs feature-sets\n             [model-name _] [[:sgd linear-sgd-spec]\n                             [:cart cart-spec]]]\n         {:feature-set fs\n          :model (name model-name)\n          :rmse (predict-and-rmse @(prepared [fs :test])\n                                  @(models [fs model-name]))})))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.516 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.516 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n10:06:44.516 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n10:06:44.521 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/e3/(pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42})\n10:06:44.522 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/23/(:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42}))\n10:06:44.523 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/05/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42})) :raw)\n10:06:44.523 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.523 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.524 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n10:06:44.524 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/04/(:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42}))\n10:06:44.525 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/79/(pocket-book.ml-workflows_prepare-features (:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42})) :raw)\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 7.061050130878382\n10:06:44.536 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/c6/c60324b3a114e8d5646efe7ec8bc1d78e743001b\n10:06:44.541 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.549 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/1e/1e01826f37666f143cccc6e1883455eb2562ed2e\n10:06:44.607 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.610 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/6d/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42})) :quadratic)\n10:06:44.610 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.610 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.612 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/06/0644c627bd9ef15c830deb29e333d06403c26a4f\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 7.746488252108407\n10:06:44.625 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/2f/2fdc6bcd8e2009e923d805ad1f2fdc52fc57948e\n10:06:44.628 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.636 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/cc/cc330e34b3221a68d7bb7649e629ad6b645e4f47\n10:06:44.638 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.640 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/98/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42})) :trig)\n10:06:44.640 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.640 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.642 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/9b/(pocket-book.ml-workflows_prepare-features (:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42})) :trig)\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 0.9717267353378612\n10:06:44.649 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/31/31897de14a3f45f4aaf19d0981053c5fb21403cb\n10:06:44.651 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.661 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/04/04527115901fc961e204e50922811c525652d96d\n10:06:44.664 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.666 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/99/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.5, :seed 42}) {:seed 42})) :poly+trig)\n10:06:44.666 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.666 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.669 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/d7/d737f05eb6b2fdcaf7508a2f74277ea684a788ac\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.5031022528715852\n10:06:44.679 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/9a/9af00491ae43878968b94538ab45619c1c58f0d9\n10:06:44.681 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.695 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/d1/d168df4bc60ad63e27c35709a7e8e2c6b8036407\n\n\n\n\n\nfeature-results\n\n\n[{:feature-set :raw, :model \"sgd\", :rmse 3.6917759873191685}\n {:feature-set :raw, :model \"cart\", :rmse 0.6334615055076024}\n {:feature-set :quadratic, :model \"sgd\", :rmse 3.576999082640806}\n {:feature-set :quadratic, :model \"cart\", :rmse 0.6334615055076024}\n {:feature-set :trig, :model \"sgd\", :rmse 1.4577701415666355}\n {:feature-set :trig, :model \"cart\", :rmse 0.6805569759436894}\n {:feature-set :poly+trig, :model \"sgd\", :rmse 1.3410184469297421}\n {:feature-set :poly+trig, :model \"cart\", :rmse 0.6805569759436894}]\n\nWhat the results show:\nThe linear model (SGD) has high error with raw features ‚Äî it‚Äôs trying to draw a straight line through a wavy curve. But give it \\(\\sin(x)\\) and \\(\\cos(x)\\) as features, and it can combine them to approximate the true shape. Feature engineering saved the day.\nThe decision tree (CART) doesn‚Äôt care. It discovers the wavy pattern by splitting the data into regions. Extra features don‚Äôt help because the tree already found the structure.\nTakeaway: Some models need feature engineering; others don‚Äôt. Caching lets you explore both without waiting.\n\n\nPredictions plot\nBest linear model (poly+trig) vs best tree (raw) vs actual values.\n\n(let [test-ds @(prepared [:raw :test])\n      sgd-pred (:y (ml/predict @(prepared [:poly+trig :test])\n                               @(models [:poly+trig :sgd])))\n      cart-pred (:y (ml/predict test-ds\n                                @(models [:raw :cart])))\n      xs (vec (:x test-ds))\n      actuals (vec (:y test-ds))\n      sgd-vals (vec sgd-pred)\n      cart-vals (vec cart-pred)]\n  (kind/plotly\n   {:data [{:x xs :y actuals :mode \"markers\" :name \"actual\"\n            :marker {:opacity 0.3 :color \"gray\"}}\n           {:x xs :y sgd-vals :mode \"markers\" :name \"Linear SGD (poly+trig)\"\n            :marker {:opacity 0.5 :color \"steelblue\"}}\n           {:x xs :y cart-vals :mode \"markers\" :name \"CART (raw)\"\n            :marker {:opacity 0.5 :color \"tomato\"}}]\n    :layout {:xaxis {:title \"x\"} :yaxis {:title \"y\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-2-how-models-handle-noisy-data",
    "href": "pocket_book.ml_workflows.html#part-2-how-models-handle-noisy-data",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 2 ‚Äî How models handle noisy data",
    "text": "Part 2 ‚Äî How models handle noisy data\nReal data is messy. Measurements have errors, inputs are approximate. Noise is the random variation that obscures the true pattern.\nHow do our models behave as noise increases? We‚Äôll test five levels, from nearly clean (0.1) to very noisy (5.0).\nNotice: the noise=0.5 dataset reuses the cache from Part 1 ‚Äî Pocket recognizes the same function and arguments.\n\n(def noise-levels [0.1 0.5 1.0 2.0 5.0])\n\n\n(def noise-results\n  (vec\n   (for [noise-sd noise-levels]\n     (let [data-c (pocket/cached #'make-regression-data\n                                 {:f #'nonlinear-fn :n 500 :noise-sd noise-sd :seed 42})\n           split-c (pocket/cached #'split-dataset data-c {:seed 42})\n           train-c (pocket/cached :train split-c)\n           test-c (pocket/cached :test split-c)\n           cart-train (pocket/cached #'prepare-features train-c :raw)\n           cart-test (pocket/cached #'prepare-features test-c :raw)\n           sgd-train (pocket/cached #'prepare-features train-c :poly+trig)\n           sgd-test (pocket/cached #'prepare-features test-c :poly+trig)\n           cart-model (pocket/cached #'train-model cart-train cart-spec)\n           sgd-model (pocket/cached #'train-model sgd-train linear-sgd-spec)]\n       {:noise-sd noise-sd\n        :cart-rmse (predict-and-rmse @cart-test @cart-model)\n        :sgd-rmse (predict-and-rmse @sgd-test @sgd-model)}))))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.714 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.714 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n10:06:44.714 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n10:06:44.714 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n10:06:44.716 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/6a/(pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.1, :seed 42})\n10:06:44.721 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/3a/(pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.1, :seed 42}) {:seed 42})\n10:06:44.722 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/94/(:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.1, :seed 42}) {:seed 42}))\n10:06:44.723 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/96/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.1, :seed 42}) {:seed 42})) :raw)\n10:06:44.723 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.723 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.723 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n10:06:44.724 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/55/(:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.1, :seed 42}) {:seed 42}))\n10:06:44.725 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/08/(pocket-book.ml-workflows_prepare-features (:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.1, :seed 42}) {:seed 42})) :raw)\n10:06:44.735 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/b8/b852ace3759232f1dec48d3e01572a918e9e31e6\n10:06:44.739 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.741 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/dd/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 0.1, :seed 42}) {:seed 42})) :poly+trig)\n10:06:44.741 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.741 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.744 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/bc/bcc1185d8c044fe468f72f058191a99f73c4ea91\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.106624,min=-5.332393,mean=0.805881,variance=15.304966})\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.4235088958624642\n10:06:44.756 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/82/82fcdba4291961e398a2dabf02049538d45de7ff\n10:06:44.765 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.765 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n10:06:44.765 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n10:06:44.765 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n10:06:44.767 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/53/(pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 1.0, :seed 42})\n10:06:44.772 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/68/(pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 1.0, :seed 42}) {:seed 42})\n10:06:44.773 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/85/(:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 1.0, :seed 42}) {:seed 42}))\n10:06:44.774 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/d1/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 1.0, :seed 42}) {:seed 42})) :raw)\n10:06:44.774 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.774 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.774 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n10:06:44.775 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/62/(:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 1.0, :seed 42}) {:seed 42}))\n10:06:44.776 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/ac/(pocket-book.ml-workflows_prepare-features (:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 1.0, :seed 42}) {:seed 42})) :raw)\n10:06:44.785 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/56/56b12a0b688bc09e6b02b1079e0b3db9e27780bb\n10:06:44.788 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.789 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/3d/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 1.0, :seed 42}) {:seed 42})) :poly+trig)\n10:06:44.789 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.789 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.791 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/21/2138858cf3d145d3b1dda31f1fbff57c42021903\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=9.816940,min=-6.625413,mean=0.883112,variance=15.979208})\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.8153008504655874\n10:06:44.799 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/af/afcc6439d95dc6b19a47d7bb13b405a6e3f7bf75\n10:06:44.802 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.802 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n10:06:44.802 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n10:06:44.802 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n10:06:44.803 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/1f/(pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 2.0, :seed 42})\n10:06:44.807 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/ec/(pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 2.0, :seed 42}) {:seed 42})\n10:06:44.808 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/a2/(:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 2.0, :seed 42}) {:seed 42}))\n10:06:44.809 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/b0/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 2.0, :seed 42}) {:seed 42})) :raw)\n10:06:44.809 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.809 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.809 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n10:06:44.810 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/be/(:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 2.0, :seed 42}) {:seed 42}))\n10:06:44.811 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/d8/(pocket-book.ml-workflows_prepare-features (:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 2.0, :seed 42}) {:seed 42})) :raw)\n10:06:44.818 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/42/4283017d384a0edb1360ed439ce2022cded0120a\n10:06:44.821 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.822 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/9a/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 2.0, :seed 42}) {:seed 42})) :poly+trig)\n10:06:44.823 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.823 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.824 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/c5/c596cf0eff32ed864e9956ede9b9f1a8ba604d8a\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=11.717291,min=-8.958664,mean=0.968924,variance=18.285525})\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 3.123027977933463\n10:06:44.835 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/e7/e73082ba807aa7585ee9bfe055500e1478428bfb\n10:06:44.838 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.838 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n10:06:44.838 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n10:06:44.838 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n10:06:44.840 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/16/(pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 5.0, :seed 42})\n10:06:44.843 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/33/(pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 5.0, :seed 42}) {:seed 42})\n10:06:44.844 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/f6/(:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 5.0, :seed 42}) {:seed 42}))\n10:06:44.845 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/1d/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 5.0, :seed 42}) {:seed 42})) :raw)\n10:06:44.845 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.845 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.845 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n10:06:44.846 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/b2/(:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 5.0, :seed 42}) {:seed 42}))\n10:06:44.847 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/c0/(pocket-book.ml-workflows_prepare-features (:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 5.0, :seed 42}) {:seed 42})) :raw)\n10:06:44.856 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/41/4125ad81cf3bdb18d7b227f84c899e30d5692f27\n10:06:44.860 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.862 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/2a/(pocket-book.ml-workflows_prepare-features (:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 500, :noise-sd 5.0, :seed 42}) {:seed 42})) :poly+trig)\n10:06:44.862 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.862 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n10:06:44.864 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/2a/2ab54b2e292bd3cd5f65f72be9ddd1b0a17c3de8\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=17.418345,min=-15.958416,mean=1.226360,variance=35.039175})\nFeb 09, 2026 10:06:44 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 12.1030268449752\n10:06:44.875 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/53/533425c770f1d0b6600c387d76730e7b41036713\n\n\n\n\n\nnoise-results\n\n\n[{:noise-sd 0.1,\n  :cart-rmse 0.18813079748027944,\n  :sgd-rmse 1.2744431229599325}\n {:noise-sd 0.5,\n  :cart-rmse 0.6334615055076024,\n  :sgd-rmse 1.3410184469297421}\n {:noise-sd 1.0,\n  :cart-rmse 1.2499664669902657,\n  :sgd-rmse 1.582298583473656}\n {:noise-sd 2.0,\n  :cart-rmse 2.453719422103725,\n  :sgd-rmse 2.352662287937308}\n {:noise-sd 5.0,\n  :cart-rmse 5.960858808406107,\n  :sgd-rmse 5.262029923696976}]\n\nWhat the results show:\nAt low noise, the tree wins ‚Äî it captures fine details the linear model smooths over. But as noise increases, the tree starts memorizing random wiggles (overfitting), and its error explodes.\nThe linear model degrades more gracefully. Its rigid structure (a weighted sum of features) acts as a built-in regularizer ‚Äî it can‚Äôt chase noise even if it wanted to.\nTakeaway: Flexible models (trees) excel with clean data but suffer with noise. Simple models (linear) are more robust.\n\nRMSE vs.¬†noise\n\n(let [noise-sds (vec (map :noise-sd noise-results))\n      cart-rmses (vec (map :cart-rmse noise-results))\n      sgd-rmses (vec (map :sgd-rmse noise-results))]\n  (kind/plotly\n   {:data [{:x noise-sds :y cart-rmses :mode \"lines+markers\" :name \"CART\"}\n           {:x noise-sds :y sgd-rmses :mode \"lines+markers\" :name \"Linear SGD\"}]\n    :layout {:xaxis {:title \"noise-sd\"} :yaxis {:title \"rmse\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-3-what-got-cached",
    "href": "pocket_book.ml_workflows.html#part-3-what-got-cached",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 3 ‚Äî What got cached?",
    "text": "Part 3 ‚Äî What got cached?\nWe‚Äôve run many combinations of data, features, and models. Each pocket/cached call created an independent cache entry. Let‚Äôs see what we accumulated:\n\n(:total-entries (pocket/cache-stats))\n\n\n60\n\n\n(:entries-per-fn (pocket/cache-stats))\n\n\n{\"pocket-book.ml-workflows/train-model\" 16,\n \"pocket-book.ml-workflows/prepare-features\" 24,\n \"pocket-book.ml-workflows/make-regression-data\" 5,\n \":test\" 5,\n \":train\" 5,\n \"pocket-book.ml-workflows/split-dataset\" 5}\n\nWith this small synthetic data, each step runs in milliseconds. But the structure is what matters. In real workflows ‚Äî large datasets, deep neural networks, hyperparameter searches ‚Äî the same cache graph saves hours or days.\nHere‚Äôs what happens when you change something:\n\n\n\n\n\n\n\nChange\nWhat recomputes\n\n\n\n\nEdit a feature set\nThat feature prep + its models\n\n\nChange a model hyperparameter\nOnly that model\n\n\nChange the noise level\nThat data + its features + its models\n\n\nRe-run the whole notebook\nNothing ‚Äî all cached",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#cleanup",
    "href": "pocket_book.ml_workflows.html#cleanup",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.907 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-4-sharing-computations-across-branches",
    "href": "pocket_book.ml_workflows.html#part-4-sharing-computations-across-branches",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 4 ‚Äî Sharing computations across branches",
    "text": "Part 4 ‚Äî Sharing computations across branches\nReal sensors glitch. A positioning system occasionally records a wildly wrong x value ‚Äî the physics (y) is unaffected, but the recorded input is corrupted. When we build polynomial features like x¬≤, these outlier x values get amplified: an errant x=50 gives x¬≤=2500 instead of the expected ~25 from a normal x‚âà5.\nThe fix is feature outlier clipping: compute what range of x is ‚Äúnormal‚Äù from training data, then clip both train and test inputs to those bounds ‚Äî before feature engineering.\nThe clipping threshold must come from training data alone. Using test data would leak future information.\nThis creates a diamond dependency ‚Äî one computation (the threshold) feeds into multiple downstream steps:\n make-regression-data (with x outliers)\n         |\n    split-dataset\n         |\n    +----+----+\n    v         v\n (:train)  (:test)\n    |         |\n    v         |\nfit-threshold |\n    |         |\n    +----+----+\n    v         v\nclip(train) clip(test)\n    |         |\n    v         v\nfeatures   features\n    |         |\n    v         |\ntrain-model   |\n    |         |\n    +----+----+\n    v\n  evaluate\nPocket handles this naturally. The threshold node is computed once and feeds both clipping steps. When you change the training data, the threshold recomputes, and both branches update.\n\nPipeline functions\nThese are plain functions. Each does one thing: fit a threshold, clip outliers, or evaluate. Pocket will wire them together.\n\n(defn fit-outlier-threshold\n  \"Compute IQR-based clipping bounds for :x from training data.\n  Returns {:lower &lt;bound&gt; :upper &lt;bound&gt;}.\"\n  [train-ds]\n  (println \"  Fitting outlier threshold from training data...\")\n  (let [xs (sort (vec (:x train-ds)))\n        n (count xs)\n        q1 (nth xs (int (* 0.25 n)))\n        q3 (nth xs (int (* 0.75 n)))\n        iqr (- q3 q1)]\n    {:lower (- q1 (* 1.5 iqr))\n     :upper (+ q3 (* 1.5 iqr))}))\n\n\n(defn clip-outliers\n  \"Clip :x values using pre-computed threshold bounds.\"\n  [ds threshold]\n  (println \"  Clipping outliers with bounds:\" (select-keys threshold [:lower :upper]))\n  (let [{:keys [lower upper]} threshold]\n    (tc/add-column ds :x (-&gt; (:x ds) (tcc/max lower) (tcc/min upper)))))\n\n\n(defn evaluate-model\n  \"Evaluate a model on test data.\"\n  [test-ds model]\n  (println \"  Evaluating model...\")\n  (let [pred (ml/predict test-ds model)]\n    {:rmse (loss/rmse (:y test-ds) (:y pred))}))\n\n\n\nBuild the DAG with mixed storage policies\nNot every step needs disk persistence. We use caching-fn with per-function storage policies:\n\n:mem for cheap shared computations (threshold, clipping, feature engineering) ‚Äî no disk I/O, but in-memory dedup ensures each runs only once persists across JVM sessions\n:none for trivial steps (evaluation) ‚Äî just tracks identity in the DAG without any shared caching\n\n\n(def c-fit-threshold\n  (pocket/caching-fn #'fit-outlier-threshold {:storage :mem}))\n\n\n(def c-clip\n  (pocket/caching-fn #'clip-outliers {:storage :mem}))\n\n\n(def c-prepare\n  (pocket/caching-fn #'prepare-features {:storage :mem}))\n\n\n(def c-train\n  (pocket/caching-fn #'train-model))\n\n\n(def c-evaluate\n  (pocket/caching-fn #'evaluate-model {:storage :none}))\n\nGenerate data with outliers for this demo ‚Äî 10% of the x values are corrupted by large random spikes, simulating sensor glitches. The y values (physics) are computed from the clean x, then noise is added normally ‚Äî so only the input is corrupted.\n\n(def dag-data-c\n  (pocket/cached #'make-regression-data\n                 {:f #'nonlinear-fn :n 200 :noise-sd 0.3 :seed 99\n                  :outlier-fraction 0.1 :outlier-scale 15}))\n\n\n(def dag-split-c\n  (pocket/cached #'split-dataset dag-data-c {:seed 99}))\n\n\n(def dag-train-c (pocket/cached :train dag-split-c))\n\n\n(def dag-test-c (pocket/cached :test dag-split-c))\n\nNow wire the pipeline. The threshold is fitted once from training data (in memory) and feeds both clipping steps ‚Äî a diamond dependency handled naturally.\n\n(def threshold-c\n  (c-fit-threshold dag-train-c))\n\n\n(def train-clipped-c\n  (c-clip dag-train-c threshold-c))\n\n\n(def test-clipped-c\n  (c-clip dag-test-c threshold-c))\n\n\n(def train-prepped-c\n  (c-prepare train-clipped-c :poly+trig))\n\n\n(def test-prepped-c\n  (c-prepare test-clipped-c :poly+trig))\n\n\n(def model-c\n  (c-train train-prepped-c cart-spec))\n\n\n(def metrics-c\n  (c-evaluate test-prepped-c model-c))\n\n\n\nVisualize the DAG\nPocket provides three functions for DAG introspection, each suited to different use cases.\norigin-story returns a nested tree structure. Each cached node has :fn, :args, and :id. The :id is unique; when the same Cached instance appears multiple times (diamond pattern), subsequent occurrences become {:ref &lt;id&gt;} pointers. This avoids infinite recursion and makes the diamond explicit:\n\n(pocket/origin-story metrics-c)\n\n\n{:fn #'pocket-book.ml-workflows/evaluate-model,\n :args\n [{:fn #'pocket-book.ml-workflows/prepare-features,\n   :args\n   [{:fn #'pocket-book.ml-workflows/clip-outliers,\n     :args\n     [{:fn :test,\n       :args\n       [{:fn #'pocket-book.ml-workflows/split-dataset,\n         :args\n         [{:fn #'pocket-book.ml-workflows/make-regression-data,\n           :args\n           [{:value\n             {:f #'pocket-book.ml-workflows/nonlinear-fn,\n              :n 200,\n              :noise-sd 0.3,\n              :seed 99,\n              :outlier-fraction 0.1,\n              :outlier-scale 15}}],\n           :id \"c6\"}\n          {:value {:seed 99}}],\n         :id \"c5\"}],\n       :id \"c4\"}\n      {:fn #'pocket-book.ml-workflows/fit-outlier-threshold,\n       :args [{:fn :train, :args [{:ref \"c5\"}], :id \"c8\"}],\n       :id \"c7\"}],\n     :id \"c3\"}\n    {:value :poly+trig}],\n   :id \"c2\"}\n  {:fn #'pocket-book.ml-workflows/train-model,\n   :args\n   [{:fn #'pocket-book.ml-workflows/prepare-features,\n     :args\n     [{:fn #'pocket-book.ml-workflows/clip-outliers,\n       :args [{:ref \"c8\"} {:ref \"c7\"}],\n       :id \"c11\"}\n      {:value :poly+trig}],\n     :id \"c10\"}\n    {:value\n     {:model-type :scicloj.ml.tribuo/regression,\n      :tribuo-components\n      [{:name \"cart\",\n        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\",\n        :properties {:maxDepth \"8\"}}],\n      :tribuo-trainer-name \"cart\"}}],\n   :id \"c9\"}],\n :id \"c1\"}\n\nNotice how the threshold node appears as a :ref in one branch ‚Äî it‚Äôs the same computation feeding both train and test clipping.\norigin-story-graph normalizes the tree into a flat {:nodes ... :edges ...} structure suitable for graph algorithms:\n\n(pocket/origin-story-graph metrics-c)\n\n\n{:nodes\n {\"c9\" {:fn #'pocket-book.ml-workflows/fit-outlier-threshold},\n  \"c10\" {:fn :train},\n  \"c13\" {:fn #'pocket-book.ml-workflows/prepare-features},\n  \"c14\" {:fn #'pocket-book.ml-workflows/clip-outliers},\n  \"v15\" {:value :poly+trig},\n  \"v7\"\n  {:value\n   {:f #'pocket-book.ml-workflows/nonlinear-fn,\n    :n 200,\n    :noise-sd 0.3,\n    :seed 99,\n    :outlier-fraction 0.1,\n    :outlier-scale 15}},\n  \"v8\" {:value {:seed 99}},\n  \"c2\" {:fn #'pocket-book.ml-workflows/prepare-features},\n  \"v11\" {:value :poly+trig},\n  \"c12\" {:fn #'pocket-book.ml-workflows/train-model},\n  \"v16\"\n  {:value\n   {:model-type :scicloj.ml.tribuo/regression,\n    :tribuo-components\n    [{:name \"cart\",\n      :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\",\n      :properties {:maxDepth \"8\"}}],\n    :tribuo-trainer-name \"cart\"}},\n  \"c3\" {:fn #'pocket-book.ml-workflows/clip-outliers},\n  \"c4\" {:fn :test},\n  \"c5\" {:fn #'pocket-book.ml-workflows/split-dataset},\n  \"c6\" {:fn #'pocket-book.ml-workflows/make-regression-data},\n  \"c1\" {:fn #'pocket-book.ml-workflows/evaluate-model}},\n :edges\n [[\"c1\" \"c2\"]\n  [\"c2\" \"c3\"]\n  [\"c3\" \"c4\"]\n  [\"c4\" \"c5\"]\n  [\"c5\" \"c6\"]\n  [\"c6\" \"v7\"]\n  [\"c5\" \"v8\"]\n  [\"c3\" \"c9\"]\n  [\"c9\" \"c10\"]\n  [\"c10\" \"c5\"]\n  [\"c2\" \"v11\"]\n  [\"c1\" \"c12\"]\n  [\"c12\" \"c13\"]\n  [\"c13\" \"c14\"]\n  [\"c14\" \"c10\"]\n  [\"c14\" \"c9\"]\n  [\"c13\" \"v15\"]\n  [\"c12\" \"v16\"]]}\n\norigin-story-mermaid renders the DAG as a Mermaid flowchart, with arrows showing data flow direction (from inputs toward the final result). The diamond dependency is clearly visible ‚Äî the threshold feeds both clipping steps:\n\n(pocket/origin-story-mermaid metrics-c)\n\nflowchart TD\n  n0[\"evaluate-model\"]\n  n1[\"prepare-features\"]\n  n2[\"clip-outliers\"]\n  n3[\":test\"]\n  n4[\"split-dataset\"]\n  n5[\"make-regression-data\"]\n  n6[/\"{:f #'pocket-book.ml-workflows/nonlinear-fn,:n 200,:noise-sd 0.3,:seed 99,:outlier-fraction 0.1,:outlier-scale 15}\"/]\n  n6 --&gt; n5\n  n5 --&gt; n4\n  n7[/\"{:seed 99}\"/]\n  n7 --&gt; n4\n  n4 --&gt; n3\n  n3 --&gt; n2\n  n8[\"fit-outlier-threshold\"]\n  n9[\":train\"]\n  n4 --&gt; n9\n  n9 --&gt; n8\n  n8 --&gt; n2\n  n2 --&gt; n1\n  n10[/\":poly+trig\"/]\n  n10 --&gt; n1\n  n1 --&gt; n0\n  n11[\"train-model\"]\n  n12[\"prepare-features\"]\n  n13[\"clip-outliers\"]\n  n9 --&gt; n13\n  n8 --&gt; n13\n  n13 --&gt; n12\n  n14[/\":poly+trig\"/]\n  n14 --&gt; n12\n  n12 --&gt; n11\n  n15[/\"{:model-type :scicloj.ml.tribuo/regression,:tribuo-components [{:name 'cart',:type 'org.tribuo.regression.rtree.CARTRegressionTrainer',:properties {:maxDepth '8'}}],:tribuo-trainer-name 'cart'}\"/]\n  n15 --&gt; n11\n  n11 --&gt; n0\n\n\nExecute the pipeline\n\n(deref metrics-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.922 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n10:06:44.922 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/clip-outliers\n10:06:44.923 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n10:06:44.923 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n10:06:44.923 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n10:06:44.925 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/19/(pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 200, :noise-sd 0.3, :outlier-fraction 0.1, :outlier-scale 15, :seed 99})\n10:06:44.928 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/53/(pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 200, :noise-sd 0.3, :outlier-fraction 0.1, :outlier-scale 15, :seed 99}) {:seed 99})\n10:06:44.929 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/fb/(:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 200, :noise-sd 0.3, :outlier-fraction 0.1, :outlier-scale 15, :seed 99}) {:seed 99}))\n10:06:44.929 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/fit-outlier-threshold\n10:06:44.929 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n10:06:44.930 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/09/(:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 200, :noise-sd 0.3, :outlier-fraction 0.1, :outlier-scale 15, :seed 99}) {:seed 99}))\n  Fitting outlier threshold from training data...\n  Clipping outliers with bounds: {:lower -5.499694170624462, :upper 15.994051959902624}\n10:06:44.931 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.931 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n10:06:44.932 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/clip-outliers\n  Clipping outliers with bounds: {:lower -5.499694170624462, :upper 15.994051959902624}\n10:06:44.940 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/29/298735d4cc3dbde1964a5f86130dba60f3a9db43\n  Evaluating model...\n\n\n\n\n\n{:rmse 1.601302555211606}\n\nHow much did clipping help? Let‚Äôs compare three scenarios using the same cached building blocks.\nThe no-clip and clean-baseline pipelines are local ‚Äî they exist only for this comparison. Each still builds a cached DAG that shares steps with the clipped pipeline above.\n\n(let [;; No-clip: skip clipping, go straight from raw splits to features\n      noclip-train-c  (c-prepare dag-train-c :poly+trig)\n      noclip-test-c   (c-prepare dag-test-c :poly+trig)\n      noclip-model-c  (c-train noclip-train-c cart-spec)\n      noclip-metrics  @(c-evaluate noclip-test-c noclip-model-c)\n      ;; Clean baseline: same structure, data without outliers\n      clean-data-c    (pocket/cached #'make-regression-data\n                                     {:f #'nonlinear-fn :n 200 :noise-sd 0.3 :seed 99})\n      clean-split-c   (pocket/cached #'split-dataset clean-data-c {:seed 99})\n      clean-train-c   (c-prepare (pocket/cached :train clean-split-c) :poly+trig)\n      clean-test-c    (c-prepare (pocket/cached :test clean-split-c) :poly+trig)\n      clean-model-c   (c-train clean-train-c cart-spec)\n      clean-metrics   @(c-evaluate clean-test-c clean-model-c)]\n  {:clean            clean-metrics\n   :outliers-no-clip noclip-metrics\n   :outliers-clipped @metrics-c})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.946 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n10:06:44.947 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.947 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n10:06:44.955 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/81/81bd64358cce9b4ef112b6e4b16b04cb1cdfb14e\n  Evaluating model...\n10:06:44.959 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n10:06:44.959 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n10:06:44.959 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n10:06:44.959 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n10:06:44.961 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/55/(pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 200, :noise-sd 0.3, :seed 99})\n10:06:44.963 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/87/(pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 200, :noise-sd 0.3, :seed 99}) {:seed 99})\n10:06:44.964 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/80/(:test (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 200, :noise-sd 0.3, :seed 99}) {:seed 99}))\n10:06:44.965 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n10:06:44.965 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n10:06:44.965 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n10:06:44.966 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/54/(:train (pocket-book.ml-workflows_split-dataset (pocket-book.ml-workflows_make-regression-data {:f #'pocket-book.ml-workflows_nonlinear-fn, :n 200, :noise-sd 0.3, :seed 99}) {:seed 99}))\n10:06:44.973 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/a0/a076e329e7ab037718d99d2a664dfc9114879d46\n  Evaluating model...\n\n\n\n\n\n{:clean {:rmse 0.4263098047865239},\n :outliers-no-clip {:rmse 2.552495499444297},\n :outliers-clipped {:rmse 1.601302555211606}}\n\nClipping x before building polynomial features makes a visible difference ‚Äî the amplification through x¬≤ is tamed.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-5-comparing-many-experiments-at-once",
    "href": "pocket_book.ml_workflows.html#part-5-comparing-many-experiments-at-once",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 5 ‚Äî Comparing many experiments at once",
    "text": "Part 5 ‚Äî Comparing many experiments at once\nHyperparameters are settings you choose before training: tree depth, learning rate, which features to use. Finding good values usually means trying many combinations ‚Äî a hyperparameter sweep.\nPocket‚Äôs compare-experiments helps here. You pass a collection of cached experiments, and it extracts the parameters that vary across them (ignoring ones that are constant).\n\n(defn run-pipeline\n  \"Run a complete pipeline with given hyperparameters.\"\n  [{:keys [noise-sd feature-set max-depth]}]\n  (let [ds (make-regression-data {:f nonlinear-fn :n 200 :noise-sd noise-sd :seed 42})\n        sp (split-dataset ds {:seed 42})\n        train-prep (prepare-features (:train sp) feature-set)\n        test-prep (prepare-features (:test sp) feature-set)\n        spec {:model-type :scicloj.ml.tribuo/regression\n              :tribuo-components [{:name \"cart\"\n                                   :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                                   :properties {:maxDepth (str max-depth)}}]\n              :tribuo-trainer-name \"cart\"}\n        model (ml/train train-prep spec)\n        pred (ml/predict test-prep model)]\n    {:rmse (loss/rmse (:y test-prep) (:y pred))}))\n\nRun experiments across a grid of hyperparameters:\n\n(def experiments\n  (for [noise-sd [0.3 0.5]\n        feature-set [:raw :poly+trig]\n        max-depth [4 8]]\n    (pocket/cached #'run-pipeline\n                   {:noise-sd noise-sd\n                    :feature-set feature-set\n                    :max-depth max-depth})))\n\nCompare all experiments ‚Äî only varying parameters are shown:\n\n(def comparison\n  (pocket/compare-experiments experiments))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:44.985 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n10:06:44.993 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/0f/(pocket-book.ml-workflows_run-pipeline {:feature-set :raw, :max-depth 4, :noise-sd 0.3})\n10:06:44.993 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n10:06:45.001 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/23/(pocket-book.ml-workflows_run-pipeline {:feature-set :raw, :max-depth 8, :noise-sd 0.3})\n10:06:45.001 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n10:06:45.011 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/3f/(pocket-book.ml-workflows_run-pipeline {:feature-set :poly+trig, :max-depth 4, :noise-sd 0.3})\n10:06:45.011 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n10:06:45.024 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/40/(pocket-book.ml-workflows_run-pipeline {:feature-set :poly+trig, :max-depth 8, :noise-sd 0.3})\n10:06:45.024 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n10:06:45.034 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/c8/(pocket-book.ml-workflows_run-pipeline {:feature-set :raw, :max-depth 4, :noise-sd 0.5})\n10:06:45.035 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n10:06:45.045 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/01/(pocket-book.ml-workflows_run-pipeline {:feature-set :raw, :max-depth 8, :noise-sd 0.5})\n10:06:45.046 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n10:06:45.058 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/b3/(pocket-book.ml-workflows_run-pipeline {:feature-set :poly+trig, :max-depth 4, :noise-sd 0.5})\n10:06:45.059 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n10:06:45.072 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-regression/00/(pocket-book.ml-workflows_run-pipeline {:feature-set :poly+trig, :max-depth 8, :noise-sd 0.5})\n\n\n\n\n\n(tc/dataset comparison)\n\n\n_unnamed [8 4]:\n\n\n\n:noise-sd\n:feature-set\n:max-depth\n:result\n\n\n\n\n0.3\n:raw\n4\n{:rmse 0.7189521159338053}\n\n\n0.3\n:raw\n8\n{:rmse 0.41024324994778005}\n\n\n0.3\n:poly+trig\n4\n{:rmse 0.5297031491020386}\n\n\n0.3\n:poly+trig\n8\n{:rmse 0.4530388384300822}\n\n\n0.5\n:raw\n4\n{:rmse 0.8815492449083825}\n\n\n0.5\n:raw\n8\n{:rmse 0.6467985374993637}\n\n\n0.5\n:poly+trig\n4\n{:rmse 0.7728233864192875}\n\n\n0.5\n:poly+trig\n8\n{:rmse 0.6785270538736407}\n\n\n\n\nEach row shows the varying parameters plus the result. Parameters that were constant (like seed=42) are excluded automatically ‚Äî you see only what differs.\n\nResults visualization\n\n(let [rows (map (fn [exp]\n                  (merge (select-keys exp [:noise-sd :feature-set :max-depth])\n                         (:result exp)))\n                comparison)\n      ;; Group by both feature-set and noise-sd for legend entries\n      grouped (group-by (juxt :feature-set :noise-sd) rows)\n      feature-colors {:raw \"steelblue\" :poly \"tomato\" :poly+trig \"green\"}]\n  (kind/plotly\n   {:data (vec (for [[[feature-set noise-sd] pts] (sort-by first grouped)\n                     :let [max-depths (mapv :max-depth pts)\n                           rmses (mapv :rmse pts)]]\n                 {:x max-depths\n                  :y rmses\n                  :mode \"markers\"\n                  :name (str (name feature-set) \" (noise=\" noise-sd \")\")\n                  :legendgroup (name feature-set)\n                  :marker {:size (+ 8 (* 15 noise-sd))\n                           :color (feature-colors feature-set)}}))\n\n    :layout {:xaxis {:title \"max-depth\"} :yaxis {:title \"rmse\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#what-we-learned",
    "href": "pocket_book.ml_workflows.html#what-we-learned",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "What we learned",
    "text": "What we learned\nThis experiment revealed a clear story about the interplay between models, features, and noise:\n\nFeature engineering is decisive for linear models. With raw features, the linear model couldn‚Äôt capture the nonlinear target at all. Adding trigonometric features (sin, cos) ‚Äî which match the structure of the true function ‚Äî dramatically improved it. The model didn‚Äôt get smarter; we gave it the right vocabulary.\nDecision trees are self-sufficient but fragile. The CART model achieved low error regardless of feature set, because it can learn nonlinear splits on its own. But as noise increased, it began fitting the noise rather than the signal ‚Äî a classic overfitting pattern.\nThe crossover point matters. At low noise, the tree wins. At high noise, the well-featured linear model degrades more gracefully. Knowing where this crossover happens is exactly the kind of insight you get from systematic experimentation.\nCaching structures the workflow. In this small example, each step runs in milliseconds ‚Äî caching isn‚Äôt needed for speed. But the pattern scales: with real datasets and expensive training, the same pipeline structure ensures that only changed steps recompute. Meanwhile, compare-experiments extracted the varying parameters automatically, turning cached results into a comparison table ‚Äî useful at any scale.\nPreprocessing order matters. Outlier x values get amplified by polynomial features (x¬≤), so clipping must come before feature engineering. The diamond dependency ‚Äî one threshold feeding both train and test clipping ‚Äî is handled naturally by Pocket‚Äôs DAG.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#cleanup-1",
    "href": "pocket_book.ml_workflows.html#cleanup-1",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.084 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed true}\n\n\nsource: notebooks/pocket_book/ml_workflows.clj",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html",
    "href": "pocket_book.pocket_model.html",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "",
    "text": "Background\nLast modified: 2026-02-08\nThis chapter shows how to cache model training in a metamorph.ml pipeline using Pocket. We define a small pocket-model function ‚Äî a drop-in replacement for ml/model ‚Äî and use it with cross-validation, grid search, and multiple model types.\nmetamorph.ml is the Scicloj library for machine learning pipelines. It builds on metamorph, a data-transformation framework where each step is a function that takes a context map and returns an updated one. metamorph.ml distinguishes two modes ‚Äî :fit (learn from training data) and :transform (apply to new data) ‚Äî so a pipeline can be trained once and reused for prediction.\nOn top of this, metamorph.ml adds model training/prediction, cross-validation (evaluate-pipelines), loss functions, and hyperparameter search. A typical workflow looks like:",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#background",
    "href": "pocket_book.pocket_model.html#background",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "",
    "text": "Define a pipeline of preprocessing + model steps\nSplit data into folds\nCall evaluate-pipelines to train and score across folds\nCompare results, pick the best model",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#why-cache-with-pocket",
    "href": "pocket_book.pocket_model.html#why-cache-with-pocket",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Why cache with Pocket?",
    "text": "Why cache with Pocket?\nmetamorph.ml includes a built-in caching mechanism. This notebook explores what happens when we use Pocket‚Äôs caching instead, bringing a few things that are natural to Pocket‚Äôs design:\n\nDisk persistence ‚Äî cached models survive JVM restarts, so we can pick up where we left off across sessions\nContent-based keys ‚Äî cache keys derived from function identity and full argument values via SHA-1\nConcurrent dedup ‚Äî when multiple threads request the same computation, only one trains and the rest wait for the result\n\nThe integration is lightweight: a pocket-model function that is a drop-in replacement for ml/model. We swap one pipeline step and everything else ‚Äî evaluate-pipelines, preprocessing, grid search ‚Äî stays the same.\nWhat this gives us:\n\nSame pipeline code, same evaluate-pipelines\nModel training cached to disk (survives JVM restarts)\nGraceful fallback for non-serializable models\n\nWhat this notebook does not cover: because pocket-model plugs into metamorph.ml‚Äôs existing pipeline machinery, only the model-training step is cached through Pocket. Preprocessing, splitting, and evaluation happen outside Pocket‚Äôs awareness ‚Äî there is no computational DAG tracking the full pipeline, no per-step storage control (choosing whether each step caches to disk, memory, or not at all), and no provenance trail that connects a final metric back to the data and parameters that produced it. A companion notebook is in the works, exploring a deeper integration where every pipeline step is a Pocket caching-fn, giving us all of those things.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#setup",
    "href": "pocket_book.pocket_model.html#setup",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Setup",
    "text": "Setup\n\n(ns pocket-book.pocket-model\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Data processing:\n   [tablecloth.api :as tc]\n   [tablecloth.column.api :as tcc]\n   [tech.v3.dataset.modelling :as ds-mod]\n   [tech.v3.dataset.column-filters :as cf]\n   ;; Machine learning:\n   [scicloj.metamorph.ml :as ml]\n   [scicloj.metamorph.ml.loss :as loss]\n   [scicloj.metamorph.ml.regression]\n   [scicloj.metamorph.core :as mm]\n   [scicloj.ml.tribuo]))\n\n\n(def cache-dir \"/tmp/pocket-model\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.235 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-model\n\n\n\n\n\n\"/tmp/pocket-model\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.236 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#the-pocket-model-function",
    "href": "pocket_book.pocket_model.html#the-pocket-model-function",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "The pocket-model function",
    "text": "The pocket-model function\nThis is the core of the integration. It follows the same contract as ml/model ‚Äî a metamorph step that trains in :fit mode and predicts in :transform mode. The only difference: ml/train is wrapped with pocket/cached.\nIf Nippy can‚Äôt serialize a model (e.g., Apache Commons Math OLS), it falls back to uncached training automatically.\n\n(defn pocket-model\n  \"Drop-in replacement for ml/model that caches training via Pocket.\n  Falls back to uncached training if serialization fails.\"\n  [options]\n  (fn [{:metamorph/keys [id data mode] :as ctx}]\n    (case mode\n      :fit\n      (let [model (try\n                    (deref (pocket/cached #'ml/train data options))\n                    (catch Exception _e\n                      (ml/train data options)))]\n        (assoc ctx id (assoc model :scicloj.metamorph.ml/unsupervised?\n                             (get (ml/options-&gt;model-def options)\n                                  :unsupervised? false))))\n      :transform\n      (let [model (get ctx id)]\n        (if (get model :scicloj.metamorph.ml/unsupervised?)\n          ctx\n          (-&gt; ctx\n              (update id assoc\n                      :scicloj.metamorph.ml/feature-ds (cf/feature data)\n                      :scicloj.metamorph.ml/target-ds (cf/target data))\n              (assoc :metamorph/data (ml/predict data model))))))))",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#test-data",
    "href": "pocket_book.pocket_model.html#test-data",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Test data",
    "text": "Test data\nSimple synthetic regression: y = 3x + noise. 200 rows, enough for quick feedback.\n\n(def ds (-&gt; (let [rng (java.util.Random. 42)]\n              (tc/dataset\n               {:x (vec (repeatedly 200 #(* 10.0 (.nextDouble rng))))\n                :y (vec (repeatedly 200 #(+ (* 3.0 (* 10.0 (.nextDouble rng)))\n                                            (* 2.0 (.nextGaussian rng)))))}))\n            (ds-mod/set-inference-target :y)))\n\n\n(def splits (tc/split-&gt;seq ds :kfold {:k 3 :seed 42}))\n\n\n(count splits)\n\n\n3",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#basic-usage",
    "href": "pocket_book.pocket_model.html#basic-usage",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Basic usage",
    "text": "Basic usage\nUse pocket-model in place of ml/model. The {:metamorph/id :model} map step sets the step ID that evaluate-pipelines expects.\n\n(def cart-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"cart\"\n                        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                        :properties {:maxDepth \"8\"}}]\n   :tribuo-trainer-name \"cart\"})\n\n\n(def pipe-cart\n  (mm/pipeline\n   {:metamorph/id :model}\n   (pocket-model cart-spec)))\n\nFirst run ‚Äî trains 3 models (one per fold):\n\n(def results-1\n  (ml/evaluate-pipelines\n   [pipe-cart]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.249 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.255 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/7a/7a2371066976291d06fe1aad1b48bbeba167ff70\n10:06:45.258 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.264 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/9d/9d2799f31ec89ab47c28abaedf1a94632d6e4912\n10:06:45.268 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.274 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/75/752a5761fad71dd397dad959c21a078b67503a46\n\n\n\n\n\n(mapv #(-&gt; % :test-transform :metric) (flatten results-1))\n\n\n[10.938693265902357 11.23113067170221 12.12978921023711]\n\nCache now has 3 entries (one per fold):\n\n(pocket/cache-stats)\n\n\n{:total-entries 3,\n :total-size-bytes 53368,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 3}}\n\nSecond run ‚Äî all cache hits, same metrics:\n\n(def results-2\n  (ml/evaluate-pipelines\n   [pipe-cart]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n(= (mapv #(-&gt; % :test-transform :metric) (flatten results-1))\n   (mapv #(-&gt; % :test-transform :metric) (flatten results-2)))\n\n\ntrue",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#incremental-grid-search",
    "href": "pocket_book.pocket_model.html#incremental-grid-search",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Incremental grid search",
    "text": "Incremental grid search\nStart with 3 depth values, then add 3 more. Only new combinations train ‚Äî existing ones hit cache.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.302 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\n\n(defn cart-pipe [max-depth]\n  (mm/pipeline\n   {:metamorph/id :model}\n   (pocket-model\n    {:model-type :scicloj.ml.tribuo/regression\n     :tribuo-components [{:name \"cart\"\n                          :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                          :properties {:maxDepth (str max-depth)}}]\n     :tribuo-trainer-name \"cart\"})))\n\nBatch 1: depths 4, 8, 12\n\n(def batch-1\n  (ml/evaluate-pipelines\n   (mapv cart-pipe [4 8 12])\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.303 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.308 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/46/46551ba53c7214873653fd678fb5af5911fd74a8\n10:06:45.312 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.316 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/6f/6fbb7bae3b90b8268e38a91c951088c6cfa3cadb\n10:06:45.319 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.324 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/45/45b255de5fd11e966a46bb2bc197bd25e7dc3f6d\n10:06:45.328 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.335 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/7a/7a2371066976291d06fe1aad1b48bbeba167ff70\n10:06:45.339 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.345 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/9d/9d2799f31ec89ab47c28abaedf1a94632d6e4912\n10:06:45.350 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.357 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/75/752a5761fad71dd397dad959c21a078b67503a46\n10:06:45.362 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.381 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/3b/3b861196a2d47cb991e62014fd3765c71da240f1\n10:06:45.388 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.394 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/b9/b95687a74377288768e9d5b6046213e733681bd6\n10:06:45.399 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.406 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/78/78e74ef9c84789d8e65025fb80d4d14782a68ba3\n\n\n\n\n3 depths √ó 3 folds = 9 trainings:\n\n(pocket/cache-stats)\n\n\n{:total-entries 9,\n :total-size-bytes 158771,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 9}}\n\nBatch 2: depths 4, 6, 8, 10, 12, 16 Depths 4, 8, 12 already cached ‚Üí only 6, 10, 16 are new\n\n(def batch-2\n  (ml/evaluate-pipelines\n   (mapv cart-pipe [4 6 8 10 12 16])\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.438 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.446 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/fa/fa43248538238553b66d37050b738a274e96a914\n10:06:45.450 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.456 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/73/734a310323e487ea805c11c6c52bda4e9f95e81b\n10:06:45.459 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.463 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/ee/eecb6e24aaa957374028b36ad146f7cbde70d19e\n10:06:45.476 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.482 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/a1/a1e22191f6bb58b528e6f441dff21c21b53a6614\n10:06:45.485 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.490 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/8a/8a0abfef601073e2647c21be0e36785ef4621535\n10:06:45.493 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.501 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/3a/3a962b4c4929eecc8207ab8210d2761d069d7913\n10:06:45.535 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.544 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/b5/b5dd934981c42d27635da730d93b58cd25d29824\n10:06:45.549 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.555 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/ba/bacfed136727155cfce4b6aae389e18c5bccb87a\n10:06:45.558 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.564 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/9f/9f60d660ba8f69b08c04e5e0789fb8c963ebb49e\n\n\n\n\n3 new depths √ó 3 folds = 9 new + 9 cached = 18 total:\n\n(pocket/cache-stats)\n\n\n{:total-entries 18,\n :total-size-bytes 322365,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 18}}\n\nCombine results ‚Äî best depth by mean RMSE:\n\n(let [depths [4 6 8 10 12 16]\n      means (mapv (fn [pipeline-results]\n                    (tcc/mean (map #(-&gt; % :test-transform :metric) pipeline-results)))\n                  batch-2)]\n  (tc/dataset {:depth depths :mean-rmse means}))\n\n\n_unnamed [6 2]:\n\n\n\n:depth\n:mean-rmse\n\n\n\n\n4\n12.89681757\n\n\n6\n12.36344906\n\n\n8\n12.28048327\n\n\n10\n11.43320438\n\n\n12\n10.68677435\n\n\n16\n9.86061013",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#multiple-model-types",
    "href": "pocket_book.pocket_model.html#multiple-model-types",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Multiple model types",
    "text": "Multiple model types\nCompare CART, linear SGD, and fastmath OLS in the same evaluation. Each model type is cached independently.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.588 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\n\n(def sgd-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"squared\"\n                        :type \"org.tribuo.regression.sgd.objectives.SquaredLoss\"}\n                       {:name \"linear-sgd\"\n                        :type \"org.tribuo.regression.sgd.linear.LinearSGDTrainer\"\n                        :properties {:objective \"squared\"\n                                     :epochs \"50\"\n                                     :loggingInterval \"10000\"}}]\n   :tribuo-trainer-name \"linear-sgd\"})\n\n\n(def multi-results\n  (ml/evaluate-pipelines\n   [(mm/pipeline {:metamorph/id :model} (pocket-model cart-spec))\n    (mm/pipeline {:metamorph/id :model} (pocket-model sgd-spec))\n    (mm/pipeline {:metamorph/id :model} (pocket-model {:model-type :fastmath/ols}))]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.589 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.596 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/7a/7a2371066976291d06fe1aad1b48bbeba167ff70\n10:06:45.600 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.606 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/9d/9d2799f31ec89ab47c28abaedf1a94632d6e4912\n10:06:45.610 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.618 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/75/752a5761fad71dd397dad959c21a078b67503a46\n10:06:45.623 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 09, 2026 10:06:45 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 133 examples\nFeb 09, 2026 10:06:45 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=133,max=32.285163,min=-3.003255,mean=15.591786,variance=84.043799})\n10:06:45.632 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/6a/6ac08d75a9c1dfba5441528a6c2cb027b0986f6f\n10:06:45.635 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 09, 2026 10:06:45 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 133 examples\nFeb 09, 2026 10:06:45 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=133,max=31.652557,min=-1.736155,mean=15.631001,variance=80.557863})\n10:06:45.643 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/cf/cff2b9e4351565863c5cf69ac6a1aa7a626936af\n10:06:45.647 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 09, 2026 10:06:45 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 134 examples\nFeb 09, 2026 10:06:45 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=134,max=32.285163,min=-3.003255,mean=16.262557,variance=77.697467})\n10:06:45.658 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/21/2174cb3cdbabf34a7fd782c8efb1ab0084db8081\n10:06:45.663 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.673 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/c2/c2ccc1e0dcf1c2c00d9c621178aafc97ec23e85e\n10:06:45.676 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.681 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/42/42cb21d2dea2f78ba1450f2f2eb4c3683652e07f\n10:06:45.683 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.689 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/3c/3cb60cf5b7576d22ded8c276361bcc0eac5d3c40\n\n\n\n\n3 model types √ó 3 folds = 9 entries:\n\n(pocket/cache-stats)\n\n\n{:total-entries 9,\n :total-size-bytes 188853,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 9}}\n\nMean RMSE per model type:\n\n(let [model-names [\"CART\" \"SGD\" \"fastmath-OLS\"]\n      means (mapv (fn [pipeline-results]\n                    (tcc/mean (map #(-&gt; % :test-transform :metric) pipeline-results)))\n                  multi-results)]\n  (tc/dataset {:model model-names :mean-rmse means}))\n\n\n_unnamed [3 2]:\n\n\n\n:model\n:mean-rmse\n\n\n\n\nCART\n11.43320438\n\n\nSGD\n9.00886158\n\n\nfastmath-OLS\n9.01791979",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#graceful-fallback",
    "href": "pocket_book.pocket_model.html#graceful-fallback",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Graceful fallback",
    "text": "Graceful fallback\nThe built-in metamorph.ml/ols uses Apache Commons Math which Nippy can‚Äôt serialize. pocket-model catches the error and falls back to uncached training ‚Äî the pipeline still works, just without disk caching for that model.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.705 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\n\n(def fallback-results\n  (ml/evaluate-pipelines\n   [(mm/pipeline {:metamorph/id :model} (pocket-model cart-spec))\n    (mm/pipeline {:metamorph/id :model} (pocket-model {:model-type :metamorph.ml/ols}))]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.706 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.713 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/7a/7a2371066976291d06fe1aad1b48bbeba167ff70\n10:06:45.718 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.725 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/9d/9d2799f31ec89ab47c28abaedf1a94632d6e4912\n10:06:45.730 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.738 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/75/752a5761fad71dd397dad959c21a078b67503a46\n10:06:45.744 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.759 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.771 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n\n\n\n\nCART models are cached ‚Äî 3 entries, one per fold. OLS falls back to uncached training silently. The failed serialization attempts leave empty cache directories, which show up as entries with a nil function name:\n\n(pocket/cache-stats)\n\n\n{:total-entries 6,\n :total-size-bytes 53369,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 3, nil 3}}\n\nBoth model types produce valid metrics:\n\n(let [model-names [\"CART\" \"OLS-fallback\"]\n      means (mapv (fn [pipeline-results]\n                    (tcc/mean (map #(-&gt; % :test-transform :metric) pipeline-results)))\n                  fallback-results)]\n  (tc/dataset {:model model-names :mean-rmse means}))\n\n\n_unnamed [2 2]:\n\n\n\n:model\n:mean-rmse\n\n\n\n\nCART\n11.43320438\n\n\nOLS-fallback\n9.00886158",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#disk-persistence",
    "href": "pocket_book.pocket_model.html#disk-persistence",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Disk persistence",
    "text": "Disk persistence\nModels survive JVM restarts. After clearing the in-memory cache, models are loaded from disk on next access.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.791 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\nTrain fresh:\n\n(def persist-results-1\n  (ml/evaluate-pipelines\n   [(mm/pipeline {:metamorph/id :model} (pocket-model cart-spec))]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.792 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.800 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/7a/7a2371066976291d06fe1aad1b48bbeba167ff70\n10:06:45.805 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.813 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/9d/9d2799f31ec89ab47c28abaedf1a94632d6e4912\n10:06:45.817 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:45.824 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-model/75/752a5761fad71dd397dad959c21a078b67503a46\n\n\n\n\nClear in-memory cache (simulates JVM restart):\n\n(pocket/clear-mem-cache!)\n\n\nnil\n\nRe-evaluate ‚Äî loads from disk:\n\n(def persist-results-2\n  (ml/evaluate-pipelines\n   [(mm/pipeline {:metamorph/id :model} (pocket-model cart-spec))]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.831 DEBUG scicloj.pocket.impl.cache - Cache hit (disk): scicloj.metamorph.ml/train /tmp/pocket-model/7a/7a2371066976291d06fe1aad1b48bbeba167ff70\n10:06:45.837 DEBUG scicloj.pocket.impl.cache - Cache hit (disk): scicloj.metamorph.ml/train /tmp/pocket-model/9d/9d2799f31ec89ab47c28abaedf1a94632d6e4912\n10:06:45.841 DEBUG scicloj.pocket.impl.cache - Cache hit (disk): scicloj.metamorph.ml/train /tmp/pocket-model/75/752a5761fad71dd397dad959c21a078b67503a46\n\n\n\n\nSame metrics:\n\n(= (mapv #(-&gt; % :test-transform :metric) (flatten persist-results-1))\n   (mapv #(-&gt; % :test-transform :metric) (flatten persist-results-2)))\n\n\ntrue",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#discussion",
    "href": "pocket_book.pocket_model.html#discussion",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Discussion",
    "text": "Discussion\npocket-model is a thin wrapper ‚Äî about 20 lines of code ‚Äî that gives us disk-persistent model caching with zero changes to our pipeline structure. It works with evaluate-pipelines, preprocessing steps, learning curves, and grid search.\nSerialization compatibility (tested):\n\n\n\nBackend\nCacheable?\n\n\n\n\nTribuo regression (CART, SGD)\nYes\n\n\nTribuo classification\nYes\n\n\nfastmath/ols\nYes\n\n\nmetamorph.ml/ols (Commons Math)\nNo (falls back)\n\n\nmetamorph.ml/dummy-regressor\nYes\n\n\n\nWhen to use pocket-model:\n\nGrid search / hyperparameter tuning (train once, reuse)\nIterative notebook development (change downstream code, keep models)\nLearning curves (add new sizes, only new ones train)\nAny workflow where we re-evaluate with the same data + options\n\nCache key efficiency: When pocket-model receives a derefed dataset (e.g., from ml/evaluate-pipelines, which passes real datasets through :metamorph/data), Pocket‚Äôs origin registry recognizes it and uses the lightweight identity from the original Cached reference. This avoids hashing the full dataset content for the cache key ‚Äî the same efficiency as passing a Cached reference directly.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#cleanup",
    "href": "pocket_book.pocket_model.html#cleanup",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.848 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\n\nsource: notebooks/pocket_book/pocket_model.clj",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html",
    "href": "pocket_book.pocket_pipeline.html",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "",
    "text": "Background\nThe previous chapter (pocket-model) showed how to cache model training in a metamorph.ml pipeline by swapping one step. That approach is simple ‚Äî just replace ml/model with pocket-model ‚Äî but only the training step is cached through Pocket.\nThis chapter explores a deeper integration: building the entire pipeline as a chain of pocket/caching-fn calls, where every step ‚Äî data splitting, feature engineering, outlier clipping, training ‚Äî becomes a cached node. This gives us:\nThe key ingredient is Pocket‚Äôs origin registry: when a Cached value is derefed, the real result keeps its lightweight identity. This lets us deref at each pipeline step ‚Äî so real datasets flow through metamorph‚Äôs context ‚Äî while cache keys stay efficient. Because the data is always a real dataset, we can use metamorph.ml‚Äôs evaluate-pipelines directly for cross-validation and model comparison.\nmetamorph.ml is the Scicloj library for machine learning pipelines. It builds on metamorph, a data-transformation framework where each step is a function that takes a context map and returns an updated one. Metamorph distinguishes two modes ‚Äî :fit (learn from training data) and :transform (apply to new data) ‚Äî so a pipeline can be trained once and reused for prediction.\nOn top of this, metamorph.ml adds model training/prediction, cross-validation (evaluate-pipelines), loss functions, and hyperparameter search.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#how-this-chapter-relates-to-others",
    "href": "pocket_book.pocket_pipeline.html#how-this-chapter-relates-to-others",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "How this chapter relates to others",
    "text": "How this chapter relates to others\nThe ML Workflows chapter demonstrates Pocket caching with plain functions ‚Äî pocket/cached calls wired into a DAG. This chapter uses the same pipeline functions and the same DAG approach, but adds cross-validation and model comparison on top, reusing metamorph.ml‚Äôs evaluate-pipelines.\nThe pocket-model chapter takes the opposite approach: it plugs into metamorph.ml‚Äôs existing pipeline machinery with a single drop-in replacement. Simpler to adopt, but only the training step is cached through Pocket.\n\n\n\n\n\n\n\n\n\npocket-model\nThis chapter\n\n\n\n\nIntegration effort\nOne-line change\nBuild pipeline with caching-fn wrappers\n\n\nWhat‚Äôs cached\nTraining only\nEvery step\n\n\nProvenance\nTraining step only\nFull DAG ‚Äî any result to its parameters\n\n\nStorage control\nGlobal\nPer-step\n\n\nEvaluation\nml/evaluate-pipelines\nml/evaluate-pipelines (same)",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#setup",
    "href": "pocket_book.pocket_pipeline.html#setup",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Setup",
    "text": "Setup\n\n(ns pocket-book.pocket-pipeline\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Metamorph pipeline tools:\n   [scicloj.metamorph.core :as mm]\n   ;; Data processing:\n   [tablecloth.api :as tc]\n   [tablecloth.column.api :as tcc]\n   [tech.v3.dataset.modelling :as ds-mod]\n   ;; Column role filters (feature, target, prediction):\n   [tech.v3.dataset.column-filters :as cf]\n   ;; Machine learning:\n   [scicloj.metamorph.ml :as ml]\n   [scicloj.metamorph.ml.loss :as loss]\n   [scicloj.ml.tribuo]))\n\nOverride the default log level from debug to info. This notebook has many cached steps and debug output (cache hits, writes) would overwhelm the rendered output. Info level shows cache misses, invalidation, and cleanup ‚Äî enough to see when computation happens.\n\n(pocket-book.logging/set-slf4j-level! :info)\n\n\nnil\n\n\n(def cache-dir \"/tmp/pocket-metamorph\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.929 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-metamorph\n\n\n\n\n\n\"/tmp/pocket-metamorph\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.929 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-metamorph\n\n\n\n\n\n{:dir \"/tmp/pocket-metamorph\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#pipeline-functions",
    "href": "pocket_book.pocket_pipeline.html#pipeline-functions",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Pipeline functions",
    "text": "Pipeline functions\nThese are plain Clojure functions ‚Äî each takes data in and returns data out. They know nothing about caching or about metamorph‚Äôs context maps and fit/transform modes. Pocket will wrap them with caching-fn later to add caching; the evaluation loop will call them across folds to add cross-validation.\n\n(defn make-regression-data\n  \"Generate synthetic regression data: y = f(x) + noise.\n  Optional outlier injection on x values.\"\n  [{:keys [f n noise-sd seed outlier-fraction outlier-scale]\n    :or {outlier-fraction 0 outlier-scale 10}}]\n  (let [rng (java.util.Random. (long seed))\n        xs (repeatedly n #(* 10.0 (.nextDouble rng)))\n        xs-final (if (pos? outlier-fraction)\n                   (let [out-rng (java.util.Random. (+ (long seed) 7919))]\n                     (map (fn [x]\n                            (if (&lt; (.nextDouble out-rng) outlier-fraction)\n                              (+ x (* (double outlier-scale) (.nextGaussian out-rng)))\n                              x))\n                          xs))\n                   xs)\n        ys (map (fn [x] (+ (double (f x))\n                           (* (double noise-sd) (.nextGaussian rng))))\n                xs)]\n    (-&gt; (tc/dataset {:x xs-final :y ys})\n        (ds-mod/set-inference-target :y))))\n\n\n(defn nonlinear-fn [x] (* (Math/sin x) x))\n\n\n(defn split-dataset\n  \"Split into train/test using holdout.\"\n  [ds {:keys [seed]}]\n  (first (tc/split-&gt;seq ds :holdout {:seed seed})))\n\n\n(defn prepare-features\n  \"Add derived columns: :raw (none), :poly+trig (x¬≤, sin, cos).\"\n  [ds feature-set]\n  (let [x (:x ds)]\n    (-&gt; (case feature-set\n          :raw ds\n          :poly+trig (tc/add-columns ds {:x2 (tcc/sq x)\n                                         :sin-x (tcc/sin x)\n                                         :cos-x (tcc/cos x)}))\n        (ds-mod/set-inference-target :y))))\n\n\n(defn fit-outlier-threshold\n  \"Compute IQR-based clipping bounds for :x from training data.\"\n  [train-ds]\n  (let [xs (sort (:x train-ds))\n        n (count xs)\n        q1 (nth xs (int (* 0.25 n)))\n        q3 (nth xs (int (* 0.75 n)))\n        iqr (- q3 q1)]\n    {:lower (- q1 (* 1.5 iqr))\n     :upper (+ q3 (* 1.5 iqr))}))\n\n\n(defn clip-outliers\n  \"Clip :x values using pre-computed threshold bounds.\"\n  [ds threshold]\n  (let [{:keys [lower upper]} threshold]\n    (tc/add-column ds :x (-&gt; (:x ds) (tcc/max lower) (tcc/min upper)))))\n\n\n(defn predict-model\n  \"Predict on test data using a trained model.\"\n  [test-ds model]\n  (ml/predict test-ds model))",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#model-specifications",
    "href": "pocket_book.pocket_pipeline.html#model-specifications",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Model specifications",
    "text": "Model specifications\n\n(def cart-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"cart\"\n                        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                        :properties {:maxDepth \"8\"}}]\n   :tribuo-trainer-name \"cart\"})\n\n\n(def linear-sgd-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"squared\"\n                        :type \"org.tribuo.regression.sgd.objectives.SquaredLoss\"}\n                       {:name \"linear-sgd\"\n                        :type \"org.tribuo.regression.sgd.linear.LinearSGDTrainer\"\n                        :properties {:objective \"squared\"\n                                     :epochs \"50\"\n                                     :loggingInterval \"10000\"}}]\n   :tribuo-trainer-name \"linear-sgd\"})",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#caching-fn-wrappers",
    "href": "pocket_book.pocket_pipeline.html#caching-fn-wrappers",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Caching-fn wrappers",
    "text": "Caching-fn wrappers\nEach pipeline function gets a caching-fn wrapper with an appropriate storage policy:\n\n:mem for cheap shared steps (threshold, clipping, features, prediction) ‚Äî no disk I/O, but in-memory dedup ensures each runs once\n:mem+disk (default) for expensive steps (model training) ‚Äî persists to disk, survives JVM restarts\n\n\n(def c-fit-outlier-threshold\n  (pocket/caching-fn #'fit-outlier-threshold {:storage :mem}))\n\n\n(def c-clip-outliers\n  (pocket/caching-fn #'clip-outliers {:storage :mem}))\n\n\n(def c-prepare-features\n  (pocket/caching-fn #'prepare-features {:storage :mem}))\n\n\n(def c-predict-model\n  (pocket/caching-fn #'predict-model {:storage :mem}))",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#custom-pipeline-steps",
    "href": "pocket_book.pocket_pipeline.html#custom-pipeline-steps",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Custom pipeline steps",
    "text": "Custom pipeline steps\nmetamorph provides the pipeline machinery we need: mm/pipeline composes steps, mm/lift wraps stateless functions, mm/fit-pipe and mm/transform-pipe run pipelines in each mode.\nWe build on this with two custom step types. Each step uses caching-fn wrappers internally and derefs the Cached result, so :metamorph/data always holds a real dataset. The origin registry ensures these derefed datasets carry their lightweight identity, so the next step‚Äôs cache key stays efficient.\n\npocket-fitted\nCreates a stateful pipeline step from two functions: one that fits parameters on training data, and one that applies those parameters to any dataset. In :fit mode, both are called. In :transform mode, only the apply function runs, using the parameters saved during :fit.\nBoth functions should be caching-fn wrappers. Their Cached results are derefed before being stored in the context or in :metamorph/data.\n\n(defn pocket-fitted\n  \"Create a stateful pipeline step from fit and apply caching-fns.\n  In :fit mode, fits parameters from data and applies them.\n  In :transform mode, applies previously fitted parameters.\n  Results are derefed so real datasets flow through the pipeline.\"\n  [fit-caching-fn apply-caching-fn]\n  (fn [{:metamorph/keys [data mode id] :as ctx}]\n    (case mode\n      :fit (let [fitted (deref (fit-caching-fn data))]\n             (-&gt; ctx\n                 (assoc id fitted)\n                 (assoc :metamorph/data (deref (apply-caching-fn data fitted)))))\n      :transform (assoc ctx :metamorph/data\n                        (deref (apply-caching-fn data (get ctx id)))))))\n\n\n\npocket-model\nThe model step ‚Äî compatible with ml/evaluate-pipelines. Trains in :fit mode (cached via Pocket) and stores the model map under its step ID. In :transform mode, predicts using the stored model (also cached) and saves the preprocessed test data as :target (for our loss computation) and as :scicloj.metamorph.ml/target-ds (for evaluate-pipelines).\nThe Cached reference from training is also stored (under :pocket/model-cached) so we can trace provenance later.\n\n(defn pocket-model\n  \"Cached model step compatible with ml/evaluate-pipelines.\n  Caches training and prediction via pocket/cached. Stores the\n  training Cached reference at :pocket/model-cached for provenance.\"\n  [model-spec]\n  (fn [{:metamorph/keys [data mode id] :as ctx}]\n    (case mode\n      :fit\n      (let [model-c (pocket/cached #'ml/train data model-spec)\n            model (deref model-c)]\n        (assoc ctx id model\n               :pocket/model-cached model-c))\n      :transform\n      (let [model (get ctx id)]\n        (-&gt; ctx\n            (update id assoc\n                    :scicloj.metamorph.ml/feature-ds (cf/feature data)\n                    :scicloj.metamorph.ml/target-ds (cf/target data))\n            (assoc :metamorph/data (deref (c-predict-model data model))\n                   :target data))))))",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#composing-a-pipeline",
    "href": "pocket_book.pocket_pipeline.html#composing-a-pipeline",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Composing a pipeline",
    "text": "Composing a pipeline\nWith these tools, we can build a pipeline by composing steps. The pocket-fitted step handles stateful outlier clipping, mm/lift with (comp deref c-fn) handles stateless cached feature preparation, and pocket-model handles training.\n\n(def data-c\n  (pocket/cached #'make-regression-data\n                 {:f #'nonlinear-fn :n 500 :noise-sd 0.5 :seed 42\n                  :outlier-fraction 0.1 :outlier-scale 15}))\n\n\n(def split-c (pocket/cached #'split-dataset data-c {:seed 42}))\n\n\n(def train-c (pocket/cached :train split-c))\n\n\n(def test-c (pocket/cached :test split-c))\n\n\n(def pipe-cart\n  (mm/pipeline\n   {:metamorph/id :clip} (pocket-fitted c-fit-outlier-threshold c-clip-outliers)\n   {:metamorph/id :prep} (mm/lift (comp deref c-prepare-features) :poly+trig)\n   {:metamorph/id :model} (pocket-model cart-spec)))\n\nFit on training data. We deref the Cached split to get a real dataset ‚Äî the origin registry ensures our caching-fn wrappers still see a lightweight cache key:\n\n(def fit-ctx (mm/fit-pipe (deref train-c) pipe-cart))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.943 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n10:06:45.943 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/split-dataset\n10:06:45.943 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/make-regression-data\n10:06:45.953 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/fit-outlier-threshold\n10:06:45.953 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/clip-outliers\n10:06:45.956 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:45.957 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n\n\n\n\nTransform on test data (using fitted params from training):\n\n(def transform-ctx (mm/transform-pipe (deref test-c) pipe-cart fit-ctx))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.972 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n10:06:45.974 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/clip-outliers\n10:06:45.974 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:45.976 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n\n\n\n\nThe fitted context carries the model:\n\n(-&gt; fit-ctx\n    (get :model)\n    (update :model-data dissoc :model-as-bytes)\n    kind/pprint)\n\n\n{:model-data {:target-ds Group: 0 [333 1]:\n\n|          :y |\n|------------:|\n| -2.03959829 |\n|  1.97631359 |\n| -1.13244613 |\n| -0.28466023 |\n| -3.51203007 |\n|  1.56378543 |\n| -0.34817318 |\n|  3.95058332 |\n|  1.75833936 |\n|  6.90883052 |\n|         ... |\n|  5.94841143 |\n|  0.76281763 |\n|  6.72108056 |\n| -2.61412072 |\n| -0.47687264 |\n|  0.90381607 |\n|  6.37372487 |\n| -4.57928612 |\n|  0.72187253 |\n| -1.30560162 |\n|  1.86963826 |\n, :feature-ds Group: 0 [333 4]:\n\n|          :x |         :x2 |      :sin-x |      :cos-x |\n|------------:|------------:|------------:|------------:|\n|  3.56214010 | 12.68884212 | -0.40826026 | -0.91286557 |\n|  2.64156573 |  6.97786948 |  0.47944917 | -0.87756965 |\n|  9.51947133 | 90.62033446 | -0.09455192 | -0.99551993 |\n|  6.27079557 | 39.32287712 | -0.01238942 |  0.99992325 |\n|  5.62533957 | 31.64444532 | -0.61141358 |  0.79131121 |\n| -4.85326548 | 23.55418581 |  0.99009331 |  0.14041098 |\n|  0.28305731 |  0.08012144 |  0.27929260 |  0.96020604 |\n|  6.94559974 | 48.24135581 |  0.61502245 |  0.78850960 |\n|  6.46688990 | 41.82066494 |  0.18267307 |  0.98317371 |\n|  7.51301426 | 56.44538329 |  0.94243162 |  0.33439893 |\n|         ... |         ... |         ... |         ... |\n| -4.85326548 | 23.55418581 |  0.99009331 |  0.14041098 |\n|  1.03856897 |  1.07862551 |  0.86167893 |  0.50745386 |\n|  7.39090954 | 54.62554378 |  0.89468442 |  0.44669877 |\n|  3.90381073 | 15.23973824 | -0.69052749 | -0.72330615 |\n|  0.22759616 |  0.05180001 |  0.22563633 |  0.97421160 |\n| -4.85326548 | 23.55418581 |  0.99009331 |  0.14041098 |\n|  7.38225379 | 54.49767101 |  0.89078444 |  0.45442610 |\n|  4.66158402 | 21.73036562 | -0.99870971 | -0.05078310 |\n|  2.67983090 |  7.18149367 |  0.44552604 | -0.89526898 |\n|  3.47865983 | 12.10107420 | -0.33072073 | -0.94372867 |\n|  2.13681411 |  4.56597455 |  0.84404323 | -0.53627515 |\n},\n :options\n {:model-type :scicloj.ml.tribuo/regression,\n  :tribuo-components\n  [{:name \"cart\",\n    :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\",\n    :properties {:maxDepth \"8\"}}],\n  :tribuo-trainer-name \"cart\"},\n :train-input-hash nil,\n :id #uuid \"7a635726-06ac-4cab-b9f7-0e65d609d6ba\",\n :feature-columns [:x :x2 :sin-x :cos-x],\n :target-columns [:y],\n :target-datatypes {:y :float64}}\n\nPredictions:\n\n(tc/head (:metamorph/data transform-ctx))\n\n\n_unnamed [5 1]:\n\n\n\n:y\n\n\n\n\n7.49226834\n\n\n-1.63699192\n\n\n-4.08775473\n\n\n-3.85731359\n\n\n2.39153284\n\n\n\n\nCompute RMSE from the target and predictions:\n\n(loss/rmse (:y (get-in transform-ctx [:model :scicloj.metamorph.ml/target-ds]))\n           (:y (:metamorph/data transform-ctx)))\n\n\n1.6810603338440813\n\n\nTrain and test loss\nA single metric on test data tells us how well the model generalizes, but comparing train and test loss reveals whether the model is overfitting. We compute the loss separately for each, then gather both into a summary.\n\n(defn compute-loss\n  \"Compute RMSE between actual and predicted :y columns.\"\n  [actual-ds predicted-ds]\n  (loss/rmse (:y actual-ds) (:y predicted-ds)))\n\n\n(def c-compute-loss (pocket/caching-fn #'compute-loss {:storage :mem}))\n\nWe already have the test predictions from transform-ctx. For training loss, we also transform the training data through the fitted pipeline:\n\n(def train-transform-ctx (mm/transform-pipe (deref train-c) pipe-cart fit-ctx))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.987 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n\n\n\n\nNow we compute loss on each split independently:\n\n(def train-loss-c\n  (c-compute-loss (:target train-transform-ctx)\n                  (:metamorph/data train-transform-ctx)))\n\n\n(def test-loss-c\n  (c-compute-loss (:target transform-ctx)\n                  (:metamorph/data transform-ctx)))\n\nA report function gathers both into one summary:\n\n(defn report\n  \"Gather train and test loss into a summary map.\"\n  [train-loss test-loss]\n  {:train-rmse train-loss\n   :test-rmse test-loss})\n\n\n(def c-report (pocket/caching-fn #'report {:storage :mem}))\n\n\n(def summary-c (c-report train-loss-c test-loss-c))\n\n\n(deref summary-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.991 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/report\n10:06:45.991 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/compute-loss\n10:06:45.992 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/compute-loss\n\n\n\n\n\n{:train-rmse 0.9236365142505957, :test-rmse 1.6810603338440813}\n\n\n\nProvenance\nThe summary reference carries full provenance. The origin registry lets origin-story follow derefed values back through the caching chain ‚Äî so the DAG branches into train and test paths that share the same model node. This diamond dependency is traced naturally:\n\n(pocket/origin-story-mermaid summary-c)\n\nflowchart TD\n  n0[\"report\"]\n  n1[\"compute-loss\"]\n  n2[\"prepare-features\"]\n  n3[\"clip-outliers\"]\n  n4[\":train\"]\n  n5[\"split-dataset\"]\n  n6[\"make-regression-data\"]\n  n7[/\"{:f #'pocket-book.pocket-pipeline/nonlinear-fn,:n 500,:noise-sd 0.5,:seed 42,:outlier-fraction 0.1,:outlier-scale 15}\"/]\n  n7 --&gt; n6\n  n6 --&gt; n5\n  n8[/\"{:seed 42}\"/]\n  n8 --&gt; n5\n  n5 --&gt; n4\n  n4 --&gt; n3\n  n9[\"fit-outlier-threshold\"]\n  n4 --&gt; n9\n  n9 --&gt; n3\n  n3 --&gt; n2\n  n10[/\":poly+trig\"/]\n  n10 --&gt; n2\n  n2 --&gt; n1\n  n11[\"predict-model\"]\n  n2 --&gt; n11\n  n12[\"train\"]\n  n2 --&gt; n12\n  n13[/\"{:model-type :scicloj.ml.tribuo/regression,:tribuo-components [{:name 'cart',:type 'org.tribuo.regression.rtree.CARTRegressionTrainer',:properties {:maxDepth '8'}}],:tribuo-trainer-name 'cart'}\"/]\n  n13 --&gt; n12\n  n12 --&gt; n11\n  n11 --&gt; n1\n  n1 --&gt; n0\n  n14[\"compute-loss\"]\n  n15[\"prepare-features\"]\n  n16[\"clip-outliers\"]\n  n17[\":test\"]\n  n5 --&gt; n17\n  n17 --&gt; n16\n  n9 --&gt; n16\n  n16 --&gt; n15\n  n18[/\":poly+trig\"/]\n  n18 --&gt; n15\n  n15 --&gt; n14\n  n19[\"predict-model\"]\n  n15 --&gt; n19\n  n12 --&gt; n19\n  n19 --&gt; n14\n  n14 --&gt; n0\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:45.997 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-metamorph\n\n\n\n\n\n{:dir \"/tmp/pocket-metamorph\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#splits-as-cached-references",
    "href": "pocket_book.pocket_pipeline.html#splits-as-cached-references",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Splits as Cached references",
    "text": "Splits as Cached references\nFor cross-validation, we need k train/test splits. We create them as Cached references ‚Äî preserving provenance ‚Äî and then deref them to get real datasets for ml/evaluate-pipelines. The origin registry ensures the derefed datasets carry their lightweight identity.\n\n(defn nth-split-train\n  \"Extract the train set of the nth split.\"\n  [ds split-method split-params idx]\n  (:train (nth (tc/split-&gt;seq ds split-method split-params) idx)))\n\n\n(defn nth-split-test\n  \"Extract the test set of the nth split.\"\n  [ds split-method split-params idx]\n  (:test (nth (tc/split-&gt;seq ds split-method split-params) idx)))\n\n\n(defn- n-splits\n  \"Derive the number of splits from the method and params.\n  For :loo, derefs the dataset to get its row count.\"\n  [data-c split-method split-params]\n  (case split-method\n    :kfold (:k split-params 5)\n    :holdout 1\n    :bootstrap (:repeats split-params 1)\n    :loo (tc/row-count (deref data-c))))\n\n\n#'pocket-book.pocket-pipeline/n-splits\n\n\n(defn pocket-splits\n  \"Create k-fold splits as Cached references.\n  Returns [{:train Cached, :test Cached, :idx int} ...].\"\n  [data-c split-method split-params]\n  (for [idx (range (n-splits data-c split-method split-params))]\n    {:train (pocket/cached #'nth-split-train\n                           data-c split-method split-params idx)\n     :test (pocket/cached #'nth-split-test\n                          data-c split-method split-params idx)\n     :idx idx}))\n\nCreate Cached splits and deref them for ml/evaluate-pipelines. The derefed datasets are real (passing malli validation) while carrying their origin identity (for efficient cache keys):\n\n(def cached-splits (pocket-splits data-c :kfold {:k 3 :seed 42}))\n\n\n(def splits\n  (map (fn [{:keys [train test]}]\n         {:train (deref train) :test (deref test)})\n       cached-splits))",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#cross-validation-with-mlevaluate-pipelines",
    "href": "pocket_book.pocket_pipeline.html#cross-validation-with-mlevaluate-pipelines",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Cross-validation with ml/evaluate-pipelines",
    "text": "Cross-validation with ml/evaluate-pipelines\nBecause our pipeline steps deref their outputs, real datasets flow through :metamorph/data at every point. This makes our pipeline fully compatible with evaluate-pipelines, which needs real datasets for metric computation.\n\n(defn make-pipe [{:keys [feature-set model-spec]}]\n  (mm/pipeline\n   {:metamorph/id :clip} (pocket-fitted c-fit-outlier-threshold c-clip-outliers)\n   {:metamorph/id :prep} (mm/lift (comp deref c-prepare-features) feature-set)\n   {:metamorph/id :model} (pocket-model model-spec)))\n\n\n(def configs\n  [{:feature-set :poly+trig :model-spec cart-spec}\n   {:feature-set :raw :model-spec cart-spec}\n   {:feature-set :poly+trig :model-spec linear-sgd-spec}])\n\n\n(def results\n  (ml/evaluate-pipelines\n   (map make-pipe configs)\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.008 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/nth-split-train\n10:06:46.008 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/make-regression-data\n10:06:46.021 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/nth-split-test\n10:06:46.030 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/nth-split-train\n10:06:46.035 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/nth-split-test\n10:06:46.040 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/nth-split-train\n10:06:46.044 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.pocket-pipeline/nth-split-test\n10:06:46.049 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/fit-outlier-threshold\n10:06:46.049 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/clip-outliers\n10:06:46.049 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.050 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.066 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.070 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/clip-outliers\n10:06:46.070 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.071 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.073 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/fit-outlier-threshold\n10:06:46.074 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/clip-outliers\n10:06:46.074 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.075 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.089 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.091 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/clip-outliers\n10:06:46.092 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.092 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.094 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/fit-outlier-threshold\n10:06:46.094 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/clip-outliers\n10:06:46.094 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.095 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.108 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.110 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/clip-outliers\n10:06:46.111 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.112 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.115 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.115 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.123 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.126 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.126 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.128 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.128 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.135 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.137 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.138 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.140 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.140 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.149 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.152 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/prepare-features\n10:06:46.152 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.154 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.463754,min=-5.615639,mean=1.066586,variance=14.157836})\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 4.050872565748835\n10:06:46.163 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.165 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.166 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.739185,min=-5.756192,mean=0.898097,variance=14.475543})\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 3.2396946375069637\n10:06:46.175 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.177 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.179 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 334 examples\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=334,max=8.739185,min=-5.756192,mean=0.997828,variance=14.612461})\nFeb 09, 2026 10:06:46 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 3.473370043059974\n10:06:46.193 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.196 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n\n\n\n\n3 configs √ó 3 folds ‚Äî aggregate mean RMSE per config:\n\n(def summary\n  (map (fn [config pipeline-results]\n         {:feature-set (:feature-set config)\n          :model-type (-&gt; config :model-spec :tribuo-trainer-name)\n          :mean-rmse (tcc/mean (map #(-&gt; % :test-transform :metric)\n                                    pipeline-results))})\n       configs results))\n\n\n(tc/dataset summary)\n\n\n_unnamed [3 3]:\n\n\n\n:feature-set\n:model-type\n:mean-rmse\n\n\n\n\n:poly+trig\ncart\n1.65064791\n\n\n:raw\ncart\n1.63217429\n\n\n:poly+trig\nlinear-sgd\n2.13019778\n\n\n\n\nSecond run ‚Äî all training hits cache, same metrics:\n\n(def results-2\n  (ml/evaluate-pipelines\n   (map make-pipe configs)\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n(= (map #(-&gt; % first :test-transform :metric) results)\n   (map #(-&gt; % first :test-transform :metric) results-2))\n\n\ntrue",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#hyperparameter-sweep",
    "href": "pocket_book.pocket_pipeline.html#hyperparameter-sweep",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Hyperparameter sweep",
    "text": "Hyperparameter sweep\nVary tree depth √ó feature set. Each unique combination trains once and is cached. Re-running adds only new combinations.\n\n(def sweep-configs\n  (for [depth [4 6 8 12]\n        fs [:raw :poly+trig]]\n    {:feature-set fs\n     :model-spec {:model-type :scicloj.ml.tribuo/regression\n                  :tribuo-components [{:name \"cart\"\n                                       :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                                       :properties {:maxDepth (str depth)}}]\n                  :tribuo-trainer-name \"cart\"}}))\n\n\n(def sweep-results\n  (ml/evaluate-pipelines\n   (map make-pipe sweep-configs)\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.222 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.229 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.231 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.233 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.240 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.243 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.244 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.251 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.253 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.255 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.266 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.268 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.270 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.281 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.283 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.286 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.296 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.299 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.302 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.311 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.313 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.316 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.346 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.349 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.351 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.362 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.366 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.371 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.394 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.399 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.403 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.477 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.484 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.488 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.507 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.509 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.518 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.527 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.530 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.533 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.543 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.547 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.550 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.561 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.565 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.569 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.585 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.588 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.590 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.604 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.607 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.611 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n10:06:46.629 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n10:06:46.632 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.pocket-pipeline/predict-model\n\n\n\n\nResults by depth and feature set:\n\n(def sweep-summary\n  (-&gt;&gt; (map (fn [config pipeline-results]\n              {:depth (-&gt; config :model-spec :tribuo-components\n                          first :properties :maxDepth)\n               :feature-set (:feature-set config)\n               :mean-rmse (tcc/mean (map #(-&gt; % :test-transform :metric)\n                                         pipeline-results))})\n            sweep-configs sweep-results)\n       (sort-by :mean-rmse)))\n\n\n(tc/dataset sweep-summary)\n\n\n_unnamed [8 3]:\n\n\n\n:depth\n:feature-set\n:mean-rmse\n\n\n\n\n12\n:poly+trig\n1.52866093\n\n\n6\n:poly+trig\n1.63217429\n\n\n8\n:poly+trig\n1.64435595\n\n\n6\n:raw\n1.65064791\n\n\n4\n:poly+trig\n1.65350222\n\n\n4\n:raw\n1.66164890\n\n\n8\n:raw\n1.66262333\n\n\n12\n:raw\n1.71514296\n\n\n\n\nOn this synthetic data, deeper trees with engineered features (poly+trig) perform best, while shallower trees show similar results regardless of feature set.\n\nSweep provenance\nPick the best result and trace its full provenance. The DAG goes from the trained model back to the original scalar parameters (seed, noise-sd, outlier-fraction, etc.):\n\n(pocket/origin-story-mermaid\n (:pocket/model-cached\n  (-&gt; sweep-results first first :fit-ctx)))\n\nflowchart TD\n  n0[\"train\"]\n  n1[\"prepare-features\"]\n  n2[\"clip-outliers\"]\n  n3[\"nth-split-train\"]\n  n4[\"make-regression-data\"]\n  n5[/\"{:f #'pocket-book.pocket-pipeline/nonlinear-fn,:n 500,:noise-sd 0.5,:seed 42,:outlier-fraction 0.1,:outlier-scale 15}\"/]\n  n5 --&gt; n4\n  n4 --&gt; n3\n  n6[/\":kfold\"/]\n  n6 --&gt; n3\n  n7[/\"{:k 3,:seed 42}\"/]\n  n7 --&gt; n3\n  n8[/\"0\"/]\n  n8 --&gt; n3\n  n3 --&gt; n2\n  n9[\"fit-outlier-threshold\"]\n  n3 --&gt; n9\n  n9 --&gt; n2\n  n2 --&gt; n1\n  n10[/\":poly+trig\"/]\n  n10 --&gt; n1\n  n1 --&gt; n0\n  n11[/\"{:model-type :scicloj.ml.tribuo/regression,:tribuo-components [{:name 'cart',:type 'org.tribuo.regression.rtree.CARTRegressionTrainer',:properties {:maxDepth '12'}}],:tribuo-trainer-name 'cart'}\"/]\n  n11 --&gt; n0",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#discussion",
    "href": "pocket_book.pocket_pipeline.html#discussion",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Discussion",
    "text": "Discussion\nWhat the Pocket DAG approach brings to an ML workflow:\n\n\n\n\n\n\n\nAspect\nWhat Pocket adds\n\n\n\n\nCaching\nPer-step, configurable ‚Äî each step chooses :mem, :mem+disk, or :none\n\n\nProvenance\nFull DAG via origin-story ‚Äî trace any result to its parameters\n\n\nDisk persistence\nCached models and intermediates survive JVM restarts\n\n\nConcurrent dedup\nConcurrentHashMap ensures each computation runs once across threads\n\n\n\nReusing metamorph:\nWe use mm/pipeline, mm/lift, mm/fit-pipe, and mm/transform-pipe directly ‚Äî and now also ml/evaluate-pipelines for cross-validation and model comparison. Pocket only adds two custom step types:\n\npocket-model ‚Äî like ml/model, but caches training via pocket/cached so models persist to disk\npocket-fitted ‚Äî a general pattern for stateful steps\n\nThe deref-through pattern:\nEach pipeline step wraps a caching-fn and immediately derefs the Cached result. This means real datasets (not Cached references) flow through :metamorph/data at every point. The origin registry provides two benefits:\n\nEfficient cache keys ‚Äî each derefed dataset carries its lightweight identity, so the next step‚Äôs caching-fn avoids hashing full dataset content\nFull provenance ‚Äî origin-story follows derefed values back through the registry to their Cached origin, preserving the complete DAG (as seen in the diamond dependency above)\n\nBecause :metamorph/data is always a real dataset, ml/evaluate-pipelines can call cf/target, cf/prediction, and malli validation ‚Äî things that require concrete dataset types.\nWhat we write:\n\nPlain pipeline functions (data in, data out)\ncaching-fn wrappers with storage policies (one line each)\nPipeline composition via mm/pipeline with our custom steps\nml/evaluate-pipelines for cross-validation\n\nOpen question: where should the custom steps live? pocket-fitted and pocket-model are currently defined in this notebook. A future scicloj.pocket.ml namespace could provide them ‚Äî but only if the pattern proves stable across different use cases.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_pipeline.html#cleanup",
    "href": "pocket_book.pocket_pipeline.html#cleanup",
    "title": "12¬† üöß Draft: pocket-pipeline ‚Äî cached ML pipelines with evaluate-pipelines",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.646 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-metamorph\n\n\n\n\n\n{:dir \"/tmp/pocket-metamorph\", :existed true}\n\n\nsource: notebooks/pocket_book/pocket_pipeline.clj",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöß Draft: `pocket-pipeline` ‚Äî cached ML pipelines with `evaluate-pipelines`</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html",
    "href": "pocket_book.cache_keys.html",
    "title": "13¬† Under the hood: cache keys",
    "section": "",
    "text": "Setup\nWhen Pocket caches a function call, it builds a cache key from the function identity and all arguments. This chapter looks at how that works internally and what it costs ‚Äî especially for large arguments like datasets.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#setup",
    "href": "pocket_book.cache_keys.html#setup",
    "title": "13¬† Under the hood: cache keys",
    "section": "",
    "text": "(ns pocket-book.cache-keys\n  (:require\n   ;; Pocket API and internals:\n   [scicloj.pocket :as pocket]\n   [scicloj.pocket.impl.cache :as cache]\n   [scicloj.pocket.protocols :as proto]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Data processing:\n   [tablecloth.api :as tc]\n   [tech.v3.dataset.modelling :as ds-mod]))",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#the-four-steps",
    "href": "pocket_book.cache_keys.html#the-four-steps",
    "title": "13¬† Under the hood: cache keys",
    "section": "The four steps",
    "text": "The four steps\nEvery call to pocket/cached goes through four steps to produce a filesystem path for the cache entry:\n\n-&gt;id ‚Äî convert each argument to its identity representation via the PIdentifiable protocol. Vars become fully-qualified symbols; Cached references become lightweight references; datasets become their full column data + metadata.\ncanonical-id ‚Äî deep-sort maps and normalize the structure so that {:a 1 :b 2} and {:b 2 :a 1} produce the same key.\nstr ‚Äî serialize the canonical form to a string.\nsha ‚Äî SHA-1 hash for a fixed-length, filesystem-safe path.\n\nWhen a function‚Äôs arguments are small (scalars, keywords, or Cached references), all four steps are sub-millisecond. But when a raw dataset is passed directly, the full dataset content becomes part of the cache key.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#measuring-the-cost",
    "href": "pocket_book.cache_keys.html#measuring-the-cost",
    "title": "13¬† Under the hood: cache keys",
    "section": "Measuring the cost",
    "text": "Measuring the cost\nLet‚Äôs pass a 50,000-row dataset as a direct argument and time each step:\n\n(let [ds (-&gt; (tc/dataset {:x (vec (range 50000))\n                          :y (vec (range 50000))\n                          :z (repeatedly 50000 rand)})\n             (ds-mod/set-inference-target :y))\n      ;; Step 1: -&gt;id\n      t0 (System/nanoTime)\n      id (proto/-&gt;id ds)\n      t1 (System/nanoTime)\n      ;; Step 2: canonical-id\n      cid (cache/canonical-id id)\n      t2 (System/nanoTime)\n      ;; Step 3: str\n      s (str cid)\n      t3 (System/nanoTime)\n      ;; Step 4: sha\n      _ (cache/sha s)\n      t4 (System/nanoTime)]\n  {:rows 50000\n   :string-length (count s)\n   :-&gt;id-ms (/ (- t1 t0) 1e6)\n   :canonical-id-ms (/ (- t2 t1) 1e6)\n   :str-ms (/ (- t3 t2) 1e6)\n   :sha-ms (/ (- t4 t3) 1e6)})\n\n\n{:rows 50000,\n :string-length 1541262,\n :-&gt;id-ms 3.355993,\n :canonical-id-ms 5.730036,\n :str-ms 25.115645,\n :sha-ms 1.579439}\n\nThe str serialization step dominates ‚Äî it must walk the entire nested structure and produce a ~1.5 MB string. SHA-1 hashing that string is fast by comparison. Switching to a faster hash algorithm would not meaningfully help.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#why-cached-references-matter",
    "href": "pocket_book.cache_keys.html#why-cached-references-matter",
    "title": "13¬† Under the hood: cache keys",
    "section": "Why Cached references matter",
    "text": "Why Cached references matter\nWhen an argument is a Cached reference rather than a raw dataset, its identity is a lightweight reference to the computation that produced it ‚Äî not the data itself. Compare:\n\n(pocket/set-base-cache-dir! \"/tmp/pocket-cache-keys\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.813 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-cache-keys\n\n\n\n\n\n\"/tmp/pocket-cache-keys\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.814 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-cache-keys\n\n\n\n\n\n{:dir \"/tmp/pocket-cache-keys\", :existed false}\n\n\n(defn make-data [n]\n  (tc/dataset {:x (vec (range n))\n               :y (vec (range n))}))\n\nDirect dataset ‚Äî identity includes all 50,000 rows:\n\n(let [ds (make-data 50000)\n      t0 (System/nanoTime)\n      _ (str (cache/canonical-id (proto/-&gt;id ds)))\n      t1 (System/nanoTime)]\n  {:direct-ms (/ (- t1 t0) 1e6)})\n\n\n{:direct-ms 20.211526}\n\nCached reference ‚Äî identity is just (make-data 50000):\n\n(let [data-c (pocket/cached #'make-data 50000)\n      t0 (System/nanoTime)\n      _ (str (cache/canonical-id (proto/-&gt;id data-c)))\n      t1 (System/nanoTime)]\n  {:cached-reference-ms (/ (- t1 t0) 1e6)})\n\n\n{:cached-reference-ms 0.074606}\n\nThe Cached reference is orders of magnitude faster because its identity is a small form like (pocket-book.cache-keys/make-data 50000), regardless of how large the output dataset is.\nThis is one of the key reasons to chain pocket/cached calls in a pipeline: each step‚Äôs cache key references its inputs by identity rather than by content, keeping key generation fast and enabling full provenance through the DAG.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#origin-registry-derefed-values-keep-their-identity",
    "href": "pocket_book.cache_keys.html#origin-registry-derefed-values-keep-their-identity",
    "title": "13¬† Under the hood: cache keys",
    "section": "Origin registry: derefed values keep their identity",
    "text": "Origin registry: derefed values keep their identity\nSometimes we need to pass real values ‚Äî not Cached references ‚Äî to code that requires concrete types. For example, metamorph.ml‚Äôs evaluate-pipelines checks (instance? Dataset ds), which fails for Cached references. The natural solution is to deref the reference first, but that would lose the lightweight identity: the derefed dataset would need full content hashing for its cache key.\nPocket solves this with an origin registry. When a Cached value is derefed, the result is registered in a side channel that maps it back to the Cached identity. Later, when -&gt;id is called on that derefed value, the registry provides the lightweight identity instead of hashing the content.\nA derefed value has the same identity as its Cached reference:\n\n(let [data-c (pocket/cached #'make-data 50000)\n      data (deref data-c)]\n  (= (proto/-&gt;id data) (proto/-&gt;id data-c)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.848 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.cache-keys/make-data\n\n\n\n\n\ntrue\n\nAnd the performance is the same ‚Äî sub-millisecond, like a Cached reference, rather than the tens-of-milliseconds cost of hashing 50,000 rows:\n\n(let [data-c (pocket/cached #'make-data 50000)\n      data (deref data-c)\n      t0 (System/nanoTime)\n      _ (str (cache/canonical-id (proto/-&gt;id data)))\n      t1 (System/nanoTime)]\n  {:derefed-with-origin-ms (/ (- t1 t0) 1e6)})\n\n\n{:derefed-with-origin-ms 0.036806}\n\n\nWhat breaks the link\nTransforming a derefed value creates a new object. The new object is not in the registry, so -&gt;id falls back to content-based identity. This is intentional ‚Äî a transformed dataset is semantically different from its source, and its cache key should reflect its actual content.\n\n(let [data-c (pocket/cached #'make-data 100)\n      data (deref data-c)\n      transformed (tc/add-column data :z (repeat 100 0))]\n  {:original-has-origin (= (proto/-&gt;id data) (proto/-&gt;id data-c))\n   :transformed-has-origin (= (proto/-&gt;id transformed) (proto/-&gt;id data-c))})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.867 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.cache-keys/make-data\n\n\n\n\n\n{:original-has-origin true, :transformed-has-origin false}\n\n\n\nWhich values are registered\nOnly values implementing clojure.lang.IObj ‚Äî maps, vectors, sets, and datasets ‚Äî are registered. The JVM interns small integers and other primitives, meaning (Long/valueOf 1) always returns the same object. Registering such values would cause false origin matches across unrelated computations. Excluding them avoids this problem entirely.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#cleanup",
    "href": "pocket_book.cache_keys.html#cleanup",
    "title": "13¬† Under the hood: cache keys",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.875 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-cache-keys\n\n\n\n\n\n{:dir \"/tmp/pocket-cache-keys\", :existed true}\n\n\nsource: notebooks/pocket_book/cache_keys.clj",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html",
    "href": "pocket_book.developing_pocket.html",
    "title": "14¬† Developing Pocket",
    "section": "",
    "text": "Rendering notebooks\nLast modified: 2026-02-08\nThis chapter is for contributors and curious readers. It describes how Pocket‚Äôs documentation is built, how tests are structured, and the conventions the notebooks follow.\nPocket‚Äôs documentation is a Clay book ‚Äî a collection of Clojure source files that Clay evaluates and renders as HTML (via Quarto) or as GitHub Flavored Markdown.\nThe chapter list lives in notebooks/chapters.edn:\nEach entry maps to a file under notebooks/pocket_book/. For example, \"getting_started\" corresponds to notebooks/pocket_book/getting_started.clj.\nThe rendering helpers live in notebooks/dev.clj. From a REPL with the :dev alias:\nThe Quarto configuration is in clay.edn at the project root.",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#rendering-notebooks",
    "href": "pocket_book.developing_pocket.html#rendering-notebooks",
    "title": "14¬† Developing Pocket",
    "section": "",
    "text": "(-&gt;&gt; \"notebooks/chapters.edn\"\n     slurp\n     clojure.edn/read-string)\n\n\n[\"getting_started\"\n \"configuration\"\n \"logging\"\n \"recursive_caching_in_pipelines\"\n \"usage_practices\"\n \"real_world_walkthrough\"\n \"concurrency\"\n \"extending_pocket\"\n \"ml_workflows\"\n \"pocket_model\"\n \"pocket_pipeline\"\n \"cache_keys\"\n \"developing_pocket\"\n \"api_reference\"]\n\n\n\n(require '[dev :as dev] :reload)\n\n;; Render the full HTML book (opens a browser):\n(dev/make-book!)\n\n;; Render one or more chapters as GitHub Flavored Markdown\n;; (useful for reviewing in a terminal or diff tool):\n(dev/make-gfm! \"pocket_book/getting_started.clj\")",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#running-tests",
    "href": "pocket_book.developing_pocket.html#running-tests",
    "title": "14¬† Developing Pocket",
    "section": "Running tests",
    "text": "Running tests\nThe test suite combines hand-written tests with tests generated from notebooks:\n./run_tests.sh\nThis runs clojure -M:dev:test -m cognitect.test-runner, which scans the test/ directory recursively. It picks up:\n\ntest/scicloj/pocket_test.clj ‚Äî hand-written unit tests\ntest/pocket_book/*_generated_test.clj ‚Äî tests generated from notebook kind/test-last annotations (see below)",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#literate-testing-with-kindtest-last",
    "href": "pocket_book.developing_pocket.html#literate-testing-with-kindtest-last",
    "title": "14¬† Developing Pocket",
    "section": "Literate testing with kind/test-last",
    "text": "Literate testing with kind/test-last\nClay notebooks can embed inline assertions using kind/test-last. A form like:\n(+ 1 2)\n\n(kind/test-last [= 3])\nasserts that the result of the previous form equals 3. The kind/test-last form is invisible in the rendered documentation ‚Äî readers see only the code and its output.\nWhen Clay renders the notebook, it generates a standard clojure.test file as a side effect. For example, a notebook notebooks/pocket_book/foo.clj produces test/pocket_book/foo_generated_test.clj.\nHere is a live example:\n\n(def demo-value (+ 10 20))\n\n\ndemo-value\n\n\n30\n\nThe assertion above is invisible in the rendered output ‚Äî but it generated a deftest that runs with every test suite execution.\nThe predicate can be any function. Common patterns:\n\n(type demo-value)\n\n\njava.lang.Long\n\n\n(str \"result is \" demo-value)\n\n\n\"result is 30\"",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#api-reference-with-kinddoc",
    "href": "pocket_book.developing_pocket.html#api-reference-with-kinddoc",
    "title": "14¬† Developing Pocket",
    "section": "API Reference with kind/doc",
    "text": "API Reference with kind/doc\nThe API Reference chapter uses kind/doc to render a var‚Äôs docstring as formatted documentation:\n\n(kind/doc #'clojure.core/map)\n\n\nmap\n[f]\n[f coll]\n[f c1 c2]\n[f c1 c2 c3]\n[f c1 c2 c3 & colls]\nReturns a lazy sequence consisting of the result of applying f to the set of first items of each coll, followed by applying f to the set of second items in each coll, until any one of the colls is exhausted. Any remaining items in other colls are ignored. Function f should accept number-of-colls arguments. Returns a transducer when no collection is provided.\nEach kind/doc call produces a documentation block from the var‚Äôs metadata (docstring, arglists, etc.). Live code examples follow naturally after each block.\nThe API Reference namespace uses a metadata hint to hide the kind/doc source code in the rendered output:\n^{:kindly/hide-code true\n  :kindly/options {:kinds-that-hide-code #{:kind/doc}}}\n(ns pocket-book.api-reference ...)\nThis means readers see the formatted docstring but not the (kind/doc ...) call that produced it.\n\nsource: notebooks/pocket_book/developing_pocket.clj",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html",
    "href": "pocket_book.api_reference.html",
    "title": "15¬† API Reference",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nA few preparations for the code examples below:",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#setup",
    "href": "pocket_book.api_reference.html#setup",
    "title": "15¬† API Reference",
    "section": "",
    "text": "(require '[scicloj.pocket :as pocket])\n\n\n(def cache-dir \"/tmp/pocket-demo-reference\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.939 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-reference\n\n\n\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.939 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed false}\n\n\n(defn expensive-calculation\n  \"Simulates an expensive computation\"\n  [x y]\n  (println (str \"Computing \" x \" + \" y \" (this is expensive!)\"))\n  (Thread/sleep 400)\n  (+ x y))",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#reference",
    "href": "pocket_book.api_reference.html#reference",
    "title": "15¬† API Reference",
    "section": "Reference",
    "text": "Reference\n\n*base-cache-dir*\nBase directory for cache storage.\nResolved with precedence: binding &gt; set-base-cache-dir! &gt; POCKET_BASE_CACHE_DIR env var &gt; pocket.edn :base-cache-dir &gt; pocket-defaults.edn (library default: .cache/pocket).\nThe current value:\n\npocket/*base-cache-dir*\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n\nset-base-cache-dir!\n[dir]\nSet the base cache directory by altering *base-cache-dir*. Returns the directory path.\n\n(pocket/set-base-cache-dir! \"/tmp/pocket-demo-2\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.942 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-2\n\n\n\n\n\n\"/tmp/pocket-demo-2\"\n\n\npocket/*base-cache-dir*\n\n\n\"/tmp/pocket-demo-2\"\n\nRestore it for the rest of the notebook:\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.942 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-reference\n\n\n\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n\nconfig\n[]\nReturn the effective resolved configuration as a map. Useful for inspecting which cache directory, mem-cache policy, storage policy, and filename length limit are in effect after applying the precedence chain.\nInspect the current effective configuration:\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-reference\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\n\n\ncached\n[func & args]\nCreate a cached computation (returns IDeref).\nThe computation is executed on first deref and cached to disk. Subsequent derefs load from cache if available.\nfunc must be a var (e.g., #'my-fn) or keyword (e.g., :train) for stable cache keys. Keywords are useful for extracting from cached maps: (cached :train split-c).\nStorage policy is controlled by *storage* (see set-storage!). Use caching-fn with an opts map for per-function overrides.\ncached returns a Cached object ‚Äî the computation is not yet executed:\n\n(def my-result (pocket/cached #'expensive-calculation 100 200))\n\n\n(type my-result)\n\n\nscicloj.pocket.impl.cache.Cached\n\nThe computation runs when we deref:\n\n(deref my-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:46.945 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 100 + 200 (this is expensive!)\n\n\n\n\n\n300\n\nDerefing again loads from cache (no recomputation):\n\n(deref my-result)\n\n\n300\n\n\n\ncaching-fn\n[f]\n[f opts]\nWrap a function to automatically cache its results.\nReturns a new function where each call returns a Cached object (IDeref). Deref the result to trigger computation or load from cache. f must be a var (e.g., #'my-fn) or keyword for stable cache keys.\nOptionally accepts an options map to override configuration per-function:\n\n:storage ‚Äî :mem+disk, :mem, or :none (overrides *storage*)\n:cache-dir ‚Äî base cache directory (overrides *base-cache-dir*)\n:mem-cache ‚Äî in-memory cache options (overrides *mem-cache-options*)\n:filename-length-limit ‚Äî max filename length before SHA-1 fallback (overrides *filename-length-limit*)\n\ncaching-fn wraps a function so that every call returns a Cached object:\n\n(def my-caching-fn (pocket/caching-fn #'expensive-calculation))\n\n\n(deref (my-caching-fn 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.364 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\nSame args hit the cache:\n\n(deref (my-caching-fn 3 4))\n\n\n7\n\ncaching-fn accepts an optional map to override per-function configuration:\n(pocket/caching-fn #'f {:storage :mem})     ;; in-memory only\n(pocket/caching-fn #'f {:storage :none})    ;; identity tracking only\n(pocket/caching-fn #'f {:cache-dir \"/tmp/alt\"})  ;; alternate cache dir\nSee the Configuration chapter for details on storage modes and the full option map.\n\n\nmaybe-deref\n[x]\nDeref if x implements IDeref, otherwise return x as-is.\nUseful in pipeline functions that may receive either Cached or plain values.\nA plain value passes through unchanged:\n\n(pocket/maybe-deref 42)\n\n\n42\n\nA Cached value gets derefed:\n\n(pocket/maybe-deref (pocket/cached #'expensive-calculation 100 200))\n\n\n300\n\n\n\n-&gt;id\n[x]\nReturn a cache key representation of a value. Dispatches via the PIdentifiable protocol.\nFor derefed Cached values, returns the same lightweight identity as the original Cached reference ‚Äî the origin registry preserves the link automatically (see cache_keys notebook for details).\nA var‚Äôs identity is its fully-qualified name:\n\n(pocket/-&gt;id #'expensive-calculation)\n\n\npocket-book.api-reference/expensive-calculation\n\nA map‚Äôs identity is itself (maps are deep-sorted later for stable cache paths):\n\n(pocket/-&gt;id {:b 2 :a 1})\n\n\n{:b 2, :a 1}\n\nA Cached object‚Äôs identity captures the full computation ‚Äî function name and argument identities ‚Äî without running it:\n\n(pocket/-&gt;id (pocket/cached #'expensive-calculation 100 200))\n\n\n(pocket-book.api-reference/expensive-calculation 100 200)\n\nnil is handled as well:\n\n(pocket/-&gt;id nil)\n\n\nnil\n\nA derefed Cached value carries its origin identity (for maps, vectors, sets, and datasets):\n\n(defn make-config [x y] {:x x :y y})\n\n\n(let [c (pocket/cached #'make-config 100 200)]\n  (= (pocket/-&gt;id (deref c)) (pocket/-&gt;id c)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.778 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/make-config\n\n\n\n\n\ntrue\n\n\n\nset-mem-cache-options!\n[opts]\nConfigure the in-memory cache. Resets it, discarding any currently cached values.\nSupported keys:\n\n:policy ‚Äî :lru, :fifo, :lu, :ttl, :lirs, :soft, or :basic\n:threshold ‚Äî max entries for :lru, :fifo, :lu\n:ttl ‚Äî time-to-live in ms for :ttl policy\n:s-history-limit / :q-history-limit ‚Äî for :lirs policy\n\nDefaults come from pocket-defaults.edn.\nSwitch to a FIFO policy with 100 entries:\n\n(pocket/set-mem-cache-options! {:policy :fifo :threshold 100})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.781 INFO scicloj.pocket - Mem-cache options set: {:policy :fifo, :threshold 100}\n10:06:47.781 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :fifo, :threshold 100}\n\n\n\n\n\n{:policy :fifo, :threshold 100}\n\nReset to default:\n\n(pocket/set-mem-cache-options! {:policy :lru :threshold 256})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.782 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 256}\n10:06:47.782 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\n\nreset-mem-cache-options!\n[]\nReset the in-memory cache configuration to library defaults. Clears any options set by set-mem-cache-options! and reconfigures the mem-cache with the default policy from pocket-defaults.edn. Returns the default options.\nReset mem-cache configuration to library defaults:\n\n(pocket/reset-mem-cache-options!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.783 INFO scicloj.pocket - Mem-cache options reset to defaults: {:policy :lru, :threshold 256}\n10:06:47.783 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\n\n*storage*\nStorage policy for cached computations: :mem+disk, :mem, or :none.\n\n:mem+disk (default) ‚Äî in-memory cache backed by disk persistence\n:mem ‚Äî in-memory cache only, no disk I/O\n:none ‚Äî no shared cache; instance-local memoization only\n\nResolved with precedence: binding &gt; set-storage! &gt; POCKET_STORAGE env var &gt; pocket.edn :storage &gt; pocket-defaults.edn (library default: :mem+disk).\n\n\nset-storage!\n[storage]\nSet the storage policy by altering *storage*. Valid values: :mem+disk, :mem, :none. Returns the storage policy.\nSwitch to memory-only storage:\n\n(pocket/set-storage! :mem)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.784 INFO scicloj.pocket - Storage policy set to: :mem\n\n\n\n\n\n:mem\n\nReset to default:\n\n(pocket/set-storage! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.785 INFO scicloj.pocket - Storage policy set to: nil\n\n\n\n\n\nnil\n\n\n\ncleanup!\n[]\nDelete the cache directory, removing all cached values. Also clears the in-memory cache. Returns a map with :dir and :existed indicating what happened.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.787 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\nclear-mem-cache!\n[]\nClear all entries from the in-memory cache and the origin registry, without deleting the disk cache. The next deref of a cached value will reload from disk if available and re-register origin identity. Useful for testing scenarios that need to simulate memory eviction.\nClear in-memory cache without touching disk:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:47.788 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n(pocket/clear-mem-cache!)\n\n\nnil\n\n\n\ninvalidate!\n[func & args]\nInvalidate a specific cached computation, removing it from both disk and memory. Takes the same arguments as cached: a function var (or keyword) and its arguments. Returns a map with :path and :existed.\nRemove a specific cached entry:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n30\n\n\n(pocket/invalidate! #'expensive-calculation 10 20)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:48.194 INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20) existed= true\n\n\n\n\n\n{:path\n \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n :existed true}\n\nDerefing again will recompute:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:48.195 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n\ninvalidate-fn!\n[func]\nInvalidate all cached entries for a given function var (or keyword), regardless of arguments. Removes matching entries from both disk and memory. Returns a map with :fn-name, :count, and :paths.\nCache a few entries, then invalidate them all:\n\n(deref (pocket/cached #'expensive-calculation 1 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:48.599 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 1 + 2 (this is expensive!)\n\n\n\n\n\n3\n\n\n(deref (pocket/cached #'expensive-calculation 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:49.003 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\n\n(pocket/invalidate-fn! #'expensive-calculation)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:49.407 INFO scicloj.pocket.impl.cache - Invalidated 3 entries for pocket-book.api-reference/expensive-calculation\n\n\n\n\n\n{:fn-name \"pocket-book.api-reference/expensive-calculation\",\n :count 3,\n :paths\n [\"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\"\n  \"/tmp/pocket-demo-reference/d2/(pocket-book.api-reference_expensive-calculation 1 2)\"\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\"]}\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:49.408 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\ncache-entries\n[]\n[fn-name]\nScan the cache directory and return a sequence of metadata maps. Each entry contains :path, :id, :fn-name, :args-str, and :created-at (when metadata is available ‚Äî entries cached before metadata support will only have :path). Optionally filter by function name.\nList all cached entries:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:49.410 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n(deref (pocket/cached #'expensive-calculation 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:49.813 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 10 20)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[10 20]\",\n  :created-at \"2026-02-09T08:06:49.810916122Z\"}\n {:path\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 3 4)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[3 4]\",\n  :created-at \"2026-02-09T08:06:50.214225562Z\"}]\n\nFilter by function name:\n\n(pocket/cache-entries \"pocket-book.api-reference/expensive-calculation\")\n\n\n[{:path\n  \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 10 20)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[10 20]\",\n  :created-at \"2026-02-09T08:06:49.810916122Z\"}\n {:path\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 3 4)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[3 4]\",\n  :created-at \"2026-02-09T08:06:50.214225562Z\"}]\n\n\n\ncache-stats\n[]\nReturn aggregate statistics about the cache. Returns a map with :total-entries, :total-size-bytes, and :entries-per-fn.\n\n(pocket/cache-stats)\n\n\n{:total-entries 2,\n :total-size-bytes 388,\n :entries-per-fn {\"pocket-book.api-reference/expensive-calculation\" 2}}\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:50.223 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\norigin-story\n[x]\nGiven a value, return its computation DAG as a nested map.\nFor a Cached value, each node is {:fn &lt;var&gt; :args [&lt;nodes&gt;] :id &lt;string&gt;}, with :value included if the computation has been realized. Plain (non-Cached) arguments become {:value &lt;val&gt;} leaf nodes.\nWhen the same Cached instance appears multiple times in the tree, subsequent occurrences are represented as {:ref &lt;id&gt;} pointing to the first occurrence‚Äôs :id. This enables proper DAG representation for diamond dependencies.\nDoes not trigger computation ‚Äî only peeks at already-realized values. Works with all storage policies (:mem+disk, :mem, :none).\norigin-story returns a nested map describing a computation‚Äôs DAG. Each cached step is {:fn &lt;var&gt; :args [...]}, with :value if realized. Plain arguments become {:value ...} leaves.\n\n(defn step-a [x] (+ x 10))\n\n\n(defn step-b [x y] (* x y))\n\n\n(def a-c (pocket/cached #'step-a 5))\n\n\n(def b-c (pocket/cached #'step-b a-c 3))\n\nBefore deref ‚Äî no :value keys:\n\n(pocket/origin-story b-c)\n\n\n{:fn #'pocket-book.api-reference/step-b,\n :args\n [{:fn #'pocket-book.api-reference/step-a,\n   :args [{:value 5}],\n   :id \"c2\"}\n  {:value 3}],\n :id \"c1\"}\n\nDeref to trigger computation:\n\n(deref b-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:50.228 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/step-b\n10:06:50.228 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/step-a\n\n\n\n\n\n45\n\nAfter deref ‚Äî :value keys appear:\n\n(pocket/origin-story b-c)\n\n\n{:fn #'pocket-book.api-reference/step-b,\n :args\n [{:fn #'pocket-book.api-reference/step-a,\n   :args [{:value 5}],\n   :id \"c2\",\n   :value 15}\n  {:value 3}],\n :id \"c1\",\n :value 45}\n\n\n\norigin-story-mermaid\n[x]\nGiven a value, return a Mermaid flowchart string of its computation DAG.\nAccepts a Cached value (walks it via origin-story) or a tree map previously returned by origin-story.\nReturns a plain string. Wrap with (kind/mermaid ...) for Kindly rendering.\nReturns a Mermaid flowchart with kindly metadata for notebook rendering:\n\n(pocket/origin-story-mermaid b-c)\n\nflowchart TD\n  n0[\"step-b\"]\n  n1[\"step-a\"]\n  n2[/\"5\"/]\n  n2 --&gt; n1\n  n1 --&gt; n0\n  n3[/\"3\"/]\n  n3 --&gt; n0\n\n\norigin-story-graph\n[x]\nGiven a value, return its computation DAG as a normalized graph.\nReturns {:nodes {&lt;id&gt; &lt;node-map&gt;} :edges [[&lt;from&gt; &lt;to&gt;] ...]}.\nNode maps contain :fn (for cached steps) or :value (for leaves), plus :value if the cached computation has been realized.\nThis is the fully normalized (Format B) representation of the DAG. Use origin-story for the tree-with-refs representation (Format A).\norigin-story-graph returns a normalized {:nodes ... :edges ...} format, suitable for graph algorithms:\n\n(pocket/origin-story-graph b-c)\n\n\n{:nodes\n {\"c1\" {:fn #'pocket-book.api-reference/step-b, :value 45},\n  \"c2\" {:fn #'pocket-book.api-reference/step-a, :value 15},\n  \"v3\" {:value 5},\n  \"v4\" {:value 3}},\n :edges [[\"c1\" \"c2\"] [\"c2\" \"v3\"] [\"c1\" \"v4\"]]}\n\n\n\ncompare-experiments\n[cached-values]\nCompare multiple cached experiment results.\nTakes a seq of Cached values (typically final metrics from different hyperparameter configurations). Walks each experiment‚Äôs origin-story to extract parameter maps, identifies which parameters vary across experiments, and returns a seq of maps containing the varying params plus the experiment result.\nOnly parameters that differ across experiments are included. The :result key contains the derefed value of each Cached.\ncompare-experiments extracts varying parameters from multiple experiments. This is useful for hyperparameter sweeps where you want to see which parameters differ across experiments.\n\n(defn run-exp [config]\n  {:rmse (* 0.1 (:lr config))})\n\n\n(def exp1 (pocket/cached #'run-exp {:lr 0.01 :epochs 100}))\n\n\n(def exp2 (pocket/cached #'run-exp {:lr 0.001 :epochs 100}))\n\n\n(pocket/compare-experiments [exp1 exp2])\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:50.237 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/run-exp\n10:06:50.238 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/run-exp\n\n\n\n\n\n[{:lr 0.01, :result {:rmse 0.001}} {:lr 0.001, :result {:rmse 1.0E-4}}]\n\nNote: :epochs is not shown because it‚Äôs the same (100) in both experiments. Only varying parameters appear in the comparison.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n10:06:50.242 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#extending-pidentifiable",
    "href": "pocket_book.api_reference.html#extending-pidentifiable",
    "title": "15¬† API Reference",
    "section": "Extending PIdentifiable",
    "text": "Extending PIdentifiable\nYou can customize how your types contribute to cache keys by extending the PIdentifiable protocol. See the Extending Pocket chapter for a full walkthrough with examples.\n\nsource: notebooks/pocket_book/api_reference.clj",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>API Reference</span>"
    ]
  }
]