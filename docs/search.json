[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pocket",
    "section": "",
    "text": "1 Preface\nFilesystem-based caching for expensive Clojure computations",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-this-about",
    "href": "index.html#what-is-this-about",
    "title": "Pocket",
    "section": "What is this about?",
    "text": "What is this about?\nPocket makes it easy to cache expensive function calls to disk and reuse results across sessions. If a computation takes longer than disk I/O, Pocket can help ‚Äî wrap it once, and the result is saved for next time. This is especially useful for data science workflows with expensive intermediate steps that need to survive JVM restarts.\nUnder the hood, Pocket derives cache keys from the function identity and its arguments (so the same computation always maps to the same cache entry), uses Nippy for fast serialization, and provides an in-memory layer backed by core.cache with configurable eviction policies. Concurrent uses of the same computation are thread-safe ‚Äî the computation runs only once.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Pocket",
    "section": "Key features",
    "text": "Key features\n\nLazy evaluation ‚Äî cached returns a deref-able value; computation runs only when needed\nPipeline caching ‚Äî chain cached steps into pipelines with automatic provenance tracking\nStorage policies ‚Äî :mem+disk (default), :mem (no disk I/O), or :none (identity tracking only)\nDAG introspection ‚Äî reconstruct the full computation graph and render it as a flowchart\nThread-safe ‚Äî concurrent uses of the same computation run it exactly once\nConfigurable ‚Äî cache directory, eviction policy, and storage mode via pocket.edn, environment variables, or code",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#general-info",
    "href": "index.html#general-info",
    "title": "Pocket",
    "section": "General info",
    "text": "General info\n\n\n\nWebsite\nhttps://scicloj.github.io/pocket/\n\n\nSource\n\n\n\nDeps\n\n\n\nLicense\nMIT\n\n\nStatus\nüõ†alphaüõ†",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#quick-example",
    "href": "index.html#quick-example",
    "title": "Pocket",
    "section": "Quick example",
    "text": "Quick example\n(require '[scicloj.pocket :as pocket])\n\n(pocket/set-base-cache-dir! \"/tmp/my-cache\")\n\n(defn expensive-calculation [x y]\n  (Thread/sleep 5000)\n  (+ x y))\n\n;; Create a lazy cached computation\n(def result (pocket/cached #'expensive-calculation 10 20))\n\n@result  ;; =&gt; 30 (computes and caches ‚Äî takes 5 seconds)\n@result  ;; =&gt; 30 (loads from cache ‚Äî instant)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#discussion",
    "href": "index.html#discussion",
    "title": "Pocket",
    "section": "Discussion",
    "text": "Discussion\nThe best places to discuss this project are:\n\na topic thread under the #data-science channel at the Clojurians Zulip (more about chat channels here)\n\nIt is highly recommended to create separate topics for separate questions.\n\na github issue",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Pocket",
    "section": "License",
    "text": "License\nCopyright ¬© 2025-2026 Scicloj\nDistributed under the MIT License ‚Äî see LICENSE.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#chapters-in-this-book",
    "href": "index.html#chapters-in-this-book",
    "title": "Pocket",
    "section": "Chapters in this book",
    "text": "Chapters in this book\n\nGetting Started\nConfiguration\nLogging\nRecursive Caching in Pipelines\nUsage Practices\nReal-World Walkthrough: Weather Analysis Pipeline\nConcurrency\nExtending Pocket\nExample: Machine Learning Workflows\nüöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml\nUnder the hood: cache keys\nDeveloping Pocket\nAPI Reference\n\n\nsource: notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html",
    "href": "pocket_book.getting_started.html",
    "title": "2¬† Getting Started",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nPocket is a Clojure library for filesystem-based caching of expensive computations. It persists results to disk so they survive JVM restarts. Cache keys are derived from the function identity and its arguments, so the same computation always maps to the same cache entry.\nFirst, we set up a cache directory and define an expensive computation:\nStart fresh so the examples below run from a clean slate:",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#setup",
    "href": "pocket_book.getting_started.html#setup",
    "title": "2¬† Getting Started",
    "section": "",
    "text": "(ns pocket-book.getting-started\n  (:require\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]))\n\n\n\n(def cache-dir \"/tmp/pocket-demo\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:36.149 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo\n\n\n\n\n\n\"/tmp/pocket-demo\"\n\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:36.150 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo\n\n\n\n\n\n{:dir \"/tmp/pocket-demo\", :existed false}\n\n\n(defn expensive-calculation\n  \"Simulates an expensive computation\"\n  [x y]\n  (println (str \"Computing \" x \" + \" y \" (this is expensive!)\"))\n  (Thread/sleep 400)\n  (+ x y))",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#background-deref-in-clojure",
    "href": "pocket_book.getting_started.html#background-deref-in-clojure",
    "title": "2¬† Getting Started",
    "section": "Background: deref in Clojure",
    "text": "Background: deref in Clojure\nIn Clojure, deref extracts a value from a reference type. It can be written as (deref x) or with the shorthand reader macro @x ‚Äî both are equivalent. Pocket‚Äôs cached returns a Cached object that implements IDeref, so you use @ (or deref) to trigger the computation and retrieve the result.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#creating-a-cached-computation",
    "href": "pocket_book.getting_started.html#creating-a-cached-computation",
    "title": "2¬† Getting Started",
    "section": "Creating a cached computation",
    "text": "Creating a cached computation\ncached creates a lazy cached computation. It returns a Cached object ‚Äî the computation won‚Äôt run until we deref it:\n\n(def cached-result\n  (pocket/cached #'expensive-calculation 10 20))\n\n\n(type cached-result)\n\n\nscicloj.pocket.impl.cache.Cached\n\nFirst deref (computes and caches):\n\n(time @cached-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:36.154 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\"Elapsed time: 402.791765 msecs\"\n\n\n\n\n\n30\n\nSecond deref (loaded from cache, instant):\n\n(time @cached-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.238759 msecs\"\n\n\n\n\n\n30",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#wrapping-functions-with-caching-fn",
    "href": "pocket_book.getting_started.html#wrapping-functions-with-caching-fn",
    "title": "2¬† Getting Started",
    "section": "Wrapping functions with caching-fn",
    "text": "Wrapping functions with caching-fn\nFor convenience, caching-fn wraps a function so that every call returns a Cached object:\n\n(def cached-expensive\n  (pocket/caching-fn #'expensive-calculation))\n\nFirst call:\n\n(time @(cached-expensive 5 15))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:36.563 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 5 + 15 (this is expensive!)\n\"Elapsed time: 402.801079 msecs\"\n\n\n\n\n\n20\n\nSame args ‚Äî cache hit:\n\n(time @(cached-expensive 5 15))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.43273 msecs\"\n\n\n\n\n\n20\n\nDifferent args ‚Äî new computation:\n\n(time @(cached-expensive 7 8))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:36.971 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 7 + 8 (this is expensive!)\n\"Elapsed time: 402.277859 msecs\"\n\n\n\n\n\n15",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#nil-handling",
    "href": "pocket_book.getting_started.html#nil-handling",
    "title": "2¬† Getting Started",
    "section": "Nil handling",
    "text": "Nil handling\nPocket properly handles nil values. Since the cache uses files on disk, it needs to distinguish ‚Äúnever computed‚Äù from ‚Äúcomputed and got nil‚Äù. It does this with a special marker file:\n\n(defn returns-nil [] nil)\n\n\n(def nil-result (pocket/cached #'returns-nil))\n\nCached nil value:\n\n(deref nil-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.377 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/returns-nil\n\n\n\n\n\nnil\n\nLoading nil from cache:\n\n(deref nil-result)\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#important-use-vars-or-keywords-for-functions",
    "href": "pocket_book.getting_started.html#important-use-vars-or-keywords-for-functions",
    "title": "2¬† Getting Started",
    "section": "Important: use vars or keywords for functions",
    "text": "Important: use vars or keywords for functions\nAlways pass functions as vars (#'fn-name) or keywords, not as bare function objects. Vars have stable names that produce consistent cache keys across sessions. Keywords are useful for extracting from cached maps (e.g., (cached :train split-c)). Pocket throws an error if you pass a bare function:\n;; ‚úÖ (pocket/cached #'my-function args)\n;; ‚úÖ (pocket/cached :train cached-map)\n;; ‚ùå (pocket/cached my-function args)\nSee the Usage Practices chapter for a detailed explanation and more best practices.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#next-steps",
    "href": "pocket_book.getting_started.html#next-steps",
    "title": "2¬† Getting Started",
    "section": "Next steps",
    "text": "Next steps\n\nConfiguration ‚Äî cache directory, in-memory eviction policies, pocket.edn\nRecursive Caching in Pipelines ‚Äî chaining cached computations\nUsage Practices ‚Äî invalidation strategies, testing, serialization, and more",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#cleanup",
    "href": "pocket_book.getting_started.html#cleanup",
    "title": "2¬† Getting Started",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.381 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo\n\n\n\n\n\n{:dir \"/tmp/pocket-demo\", :existed true}\n\n\nsource: notebooks/pocket_book/getting_started.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html",
    "href": "pocket_book.configuration.html",
    "title": "3¬† Configuration",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nPocket resolves configuration using a precedence chain (for both cache directory and in-memory cache options), from highest to lowest priority:",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#setup",
    "href": "pocket_book.configuration.html#setup",
    "title": "3¬† Configuration",
    "section": "",
    "text": "binding (thread-local override)\nset-*! functions (set-base-cache-dir!, set-mem-cache-options!)\nEnvironment variable (POCKET_BASE_CACHE_DIR, POCKET_MEM_CACHE)\npocket.edn on classpath\nLibrary defaults (pocket-defaults.edn)\n\nflowchart TD\n    B(binding) --&gt;|if nil| S(set-*!)\n    S --&gt;|if nil| E(Environment variable)\n    E --&gt;|if nil| P(pocket.edn)\n    P --&gt;|if nil| D(Hardcoded default)\n    style B fill:#4a9,color:#fff\n    style D fill:#888,color:#fff",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#pocket.edn",
    "href": "pocket_book.configuration.html#pocket.edn",
    "title": "3¬† Configuration",
    "section": "pocket.edn",
    "text": "pocket.edn\nPlace a pocket.edn file on your classpath root for declarative, project-level configuration:\n{:base-cache-dir \"/tmp/my-project-cache\"\n :mem-cache {:policy :lru :threshold 256}}\nIt is re-read on each cache operation (with a 1-second TTL cache), so changes take effect quickly during REPL development. It provides defaults that can be overridden by environment variables, set-*! calls, or binding.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#library-defaults",
    "href": "pocket_book.configuration.html#library-defaults",
    "title": "3¬† Configuration",
    "section": "Library defaults",
    "text": "Library defaults\nPocket ships with pocket-defaults.edn containing the library defaults. These are used when no other configuration is provided:\n\n(-&gt; (clojure.java.io/resource \"pocket-defaults.edn\")\n    slurp\n    clojure.edn/read-string)\n\n\n{:base-cache-dir \".cache/pocket\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\nYou can override any of these via pocket.edn, environment variables, or the set-*! functions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cache-directory",
    "href": "pocket_book.configuration.html#cache-directory",
    "title": "3¬† Configuration",
    "section": "Cache directory",
    "text": "Cache directory\nThe cache directory can be set in several ways.\nEnvironment variable ‚Äî POCKET_BASE_CACHE_DIR:\nexport POCKET_BASE_CACHE_DIR=/path/to/cache\nProgrammatically with set-base-cache-dir!:\n\n(pocket/set-base-cache-dir! \"/tmp/pocket-demo-config\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.414 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-config\n\n\n\n\n\n\"/tmp/pocket-demo-config\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.414 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-config\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-config\", :existed false}\n\nYou can inspect the effective resolved configuration at any time:\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-config\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\nThread-local binding (useful for tests):\n(binding [pocket/*base-cache-dir* \"/tmp/test-cache\"]\n  @(pocket/cached #'my-fn args))",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#in-memory-cache-and-thread-safety",
    "href": "pocket_book.configuration.html#in-memory-cache-and-thread-safety",
    "title": "3¬† Configuration",
    "section": "In-memory cache and thread safety",
    "text": "In-memory cache and thread safety\nPocket maintains an in-memory cache in front of the disk layer, backed by core.cache.\nflowchart LR\n    D(deref) --&gt; MC{In-memory\ncache?}\n    MC --&gt;|hit| R[Return value]\n    MC --&gt;|miss| DC{Disk\ncache?}\n    DC --&gt;|hit| R\n    DC --&gt;|miss| C[Compute] --&gt; W[Write to disk] --&gt; R\nThis provides two benefits:\n\nPerformance ‚Äî repeated derefs of the same computation skip disk I/O entirely (until the entry is evicted from memory).\nThread safety ‚Äî when multiple threads deref the same Cached value concurrently, the computation runs exactly once. This is coordinated via a ConcurrentHashMap of delays, so no duplicate work is performed. See the Concurrency chapter for a detailed explanation.\n\nBy default, the in-memory layer uses an LRU (Least Recently Used) policy ‚Äî see defaults above.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cache-policies",
    "href": "pocket_book.configuration.html#cache-policies",
    "title": "3¬† Configuration",
    "section": "Cache policies",
    "text": "Cache policies\nSupported policies and their parameters:\n\n\n\nPolicy\nKey\nParameters\n\n\n\n\nLRU (Least Recently Used)\n:lru\n:threshold (see defaults above)\n\n\nFIFO (First In First Out)\n:fifo\n:threshold (see defaults above)\n\n\nLFU (Least Frequently Used)\n:lu\n:threshold (see defaults above)\n\n\nTTL (Time To Live)\n:ttl\n:ttl in ms (see defaults above)\n\n\nLIRS\n:lirs\n:s-history-limit, :q-history-limit\n\n\nSoft references\n:soft\n(none ‚Äî uses JVM garbage collection)\n\n\nBasic (unbounded)\n:basic\n(none)\n\n\n\nConfigure via set-mem-cache-options!:\n\n(pocket/set-mem-cache-options! {:policy :fifo :threshold 100})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.418 INFO scicloj.pocket - Mem-cache options set: {:policy :fifo, :threshold 100}\n18:23:37.419 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :fifo, :threshold 100}\n\n\n\n\n\n{:policy :fifo, :threshold 100}\n\nOr a TTL policy where entries expire after 60 seconds:\n\n(pocket/set-mem-cache-options! {:policy :ttl :ttl 60000})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.420 INFO scicloj.pocket - Mem-cache options set: {:policy :ttl, :ttl 60000}\n18:23:37.420 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :ttl, :ttl 60000}\n\n\n\n\n\n{:policy :ttl, :ttl 60000}\n\nReset to the default LRU policy:\n\n(pocket/set-mem-cache-options! {:policy :lru :threshold 256})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.421 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 256}\n18:23:37.421 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\nEnvironment variable ‚Äî POCKET_MEM_CACHE (EDN string):\nexport POCKET_MEM_CACHE='{:policy :lru :threshold 512}'\nThread-local binding (useful for tests):\n(binding [pocket/*mem-cache-options* {:policy :fifo :threshold 50}]\n  @(pocket/cached #'my-fn args))\nCaution: binding *mem-cache-options* reconfigures the shared global mem-cache, which affects all threads. This is useful for test fixtures but should be avoided in concurrent production use with different policies.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#storage-policies",
    "href": "pocket_book.configuration.html#storage-policies",
    "title": "3¬† Configuration",
    "section": "Storage policies",
    "text": "Storage policies\nPocket supports three storage modes, controlled by *storage*:\n\n\n\nMode\nBehavior\n\n\n\n\n:mem+disk\nIn-memory cache backed by disk persistence (default)\n\n\n:mem\nIn-memory cache only ‚Äî no disk I/O\n\n\n:none\nNo shared cache ‚Äî instance-local memoization only\n\n\n\n:mem is useful for cheap computations that are called many times with the same arguments. It avoids disk serialization overhead while still deduplicating concurrent access.\n:none is useful for trivially cheap functions that you want to participate in DAG identity tracking (see Recursive Caching in Pipelines) without any shared caching. Each Cached instance memoizes its own result (like a delay), but separate instances recompute.\nProgrammatically with set-storage!:\n\n(pocket/set-storage! :mem)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.422 INFO scicloj.pocket - Storage policy set to: :mem\n\n\n\n\n\n:mem\n\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-config\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem,\n :filename-length-limit 240}\n\nPer-function via caching-fn options:\n(def fast-fn* (pocket/caching-fn #'fast-fn {:storage :mem}))\n(def identity-fn* (pocket/caching-fn #'identity-fn {:storage :none}))\nThe option map can also override :cache-dir and :mem-cache:\n(pocket/caching-fn #'f {:storage :mem+disk\n                        :cache-dir \"/data/project-cache\"\n                        :mem-cache {:policy :ttl :ttl 60000}})\nThread-local binding:\n(binding [pocket/*storage* :mem]\n  @(pocket/cached #'my-fn args))\nEnvironment variable ‚Äî POCKET_STORAGE:\nexport POCKET_STORAGE=mem\nNote: :mem-only entries do not appear in cache-entries or cache-stats, which scan the disk cache. :none entries are not tracked anywhere ‚Äî they exist only as in-memory Cached objects.\nReset to default:\n\n(pocket/set-storage! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.424 INFO scicloj.pocket - Storage policy set to: nil\n\n\n\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#filename-length-limit-windows",
    "href": "pocket_book.configuration.html#filename-length-limit-windows",
    "title": "3¬† Configuration",
    "section": "Filename length limit (Windows)",
    "text": "Filename length limit (Windows)\nMost operating systems have a 255-character filename limit, which Pocket handles with its default threshold of 240. However, Windows has a 260-character full path limit (unless long path support is enabled). If your base cache directory is deep, the combined path may exceed this.\nWhen a cache key exceeds the configured limit, Pocket falls back to a SHA-1 hash as the directory name. The default (240) is safe for Linux and macOS, but Windows users with deep base directories may need to lower it.\nConfigure in pocket.edn:\n{:filename-length-limit 80}  ; for Windows with deep paths\nOr at runtime:\n\n(pocket/set-filename-length-limit! 80)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.426 INFO scicloj.pocket - Filename length limit set to: 80\n\n\n\n\n\n80\n\nOr via environment variable:\nexport POCKET_FILENAME_LENGTH_LIMIT=80\nThe current limit is included in config:\n\n(:filename-length-limit (pocket/config))\n\n\n80\n\nReset to default (240):\n\n(pocket/set-filename-length-limit! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.427 INFO scicloj.pocket - Filename length limit set to: nil\n\n\n\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#per-function-configuration-with-caching-fn",
    "href": "pocket_book.configuration.html#per-function-configuration-with-caching-fn",
    "title": "3¬† Configuration",
    "section": "Per-function configuration with caching-fn",
    "text": "Per-function configuration with caching-fn\nThe caching-fn wrapper accepts an optional options map. When provided, the wrapper binds the corresponding dynamic vars before calling cached. This is equivalent to wrapping the call in binding yourself:\n;; These two are equivalent:\n(def c-fn (pocket/caching-fn #'my-fn {:storage :mem}))\n\n(defn c-fn [& args]\n  (binding [pocket/*storage* :mem]\n    (apply pocket/cached #'my-fn args)))\n\nAvailable options\n\n\n\nOption\nBinds\n\n\n\n\n:storage\n*storage*\n\n\n:cache-dir\n*base-cache-dir*\n\n\n:mem-cache\n*mem-cache-options*\n\n\n:filename-length-limit\n*filename-length-limit*\n\n\n\n\n\nExample: Mixed storage policies\nA data science pipeline might use different storage for different steps:\n\n(defn load-data [path] (slurp path))\n\n\n(defn compute-stats [data] {:lines (count (clojure.string/split-lines data))})\n\n\n(defn train-model [data stats] {:model \"trained\" :stats stats})\n\nExpensive data loading ‚Äî default (disk + memory):\n\n(def c-load (pocket/caching-fn #'load-data))\n\nCheap stats ‚Äî memory only, no disk I/O:\n\n(def c-stats (pocket/caching-fn #'compute-stats {:storage :mem}))\n\nExpensive training ‚Äî shorter filenames for Windows compatibility:\n\n(def c-train (pocket/caching-fn #'train-model {:filename-length-limit 80}))",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cleanup",
    "href": "pocket_book.configuration.html#cleanup",
    "title": "3¬† Configuration",
    "section": "Cleanup",
    "text": "Cleanup\nTo delete all cached values (both disk and in-memory), use cleanup!:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.430 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-config\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-config\", :existed false}\n\n\nsource: notebooks/pocket_book/configuration.clj",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html",
    "href": "pocket_book.logging.html",
    "title": "4¬† Logging",
    "section": "",
    "text": "Log levels\nLast modified: 2026-02-08\nPocket uses clojure.tools.logging for cache lifecycle messages. It does not bundle a logging backend ‚Äî you provide your own (e.g., SLF4J with slf4j-simple or Logback, or Log4j2 directly). tools.logging auto-discovers a backend from the classpath; without one, logging is silently disabled.\nThis documentation was rendered using slf4j-simple as a dev dependency of the Pocket project, so the log output shown here is real.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html#log-levels",
    "href": "pocket_book.logging.html#log-levels",
    "title": "4¬† Logging",
    "section": "",
    "text": "Level\nMessages\n\n\n\n\n:debug\nCache hits (memory and disk), cache writes\n\n\n:info\nCache misses (computation), invalidation, mem-cache reconfiguration, cleanup",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html#setup-for-notebooks",
    "href": "pocket_book.logging.html#setup-for-notebooks",
    "title": "4¬† Logging",
    "section": "Setup for notebooks",
    "text": "Setup for notebooks\nThe following configures slf4j-simple for notebook use. These properties must be set before any logging occurs.\nShow debug-level messages (cache hits and writes):\n\n(System/setProperty \"org.slf4j.simpleLogger.defaultLogLevel\" \"debug\")\n\n\n\"debug\"\n\nHide thread names to reduce clutter:\n\n(System/setProperty \"org.slf4j.simpleLogger.showThreadName\" \"false\")\n\n\n\"false\"\n\nShow timestamps for each log message:\n\n(System/setProperty \"org.slf4j.simpleLogger.showDateTime\" \"true\")\n\n\n\"true\"\n\nUse hours:minutes:seconds.milliseconds format:\n\n(System/setProperty \"org.slf4j.simpleLogger.dateTimeFormat\" \"HH:mm:ss.SSS\")\n\n\n\"HH:mm:ss.SSS\"\n\nWrite to stdout so messages appear as OUT rather than ERR:\n\n(System/setProperty \"org.slf4j.simpleLogger.logFile\" \"System.out\")\n\n\n\"System.out\"\n\nIf slf4j-simple was already initialized (e.g., in a long-running REPL), the properties above won‚Äôt take effect because SimpleLogger reads them only once at class-load time. The following forces the output to stdout on the already-initialized configuration singleton:\n\n(try\n  (let [cp-field (.getDeclaredField org.slf4j.simple.SimpleLogger \"CONFIG_PARAMS\")]\n    (.setAccessible cp-field true)\n    (let [config (.get cp-field nil)\n          oc-field (.getDeclaredField (class config) \"outputChoice\")]\n      (.setAccessible oc-field true)\n      (let [sys-out (java.lang.Enum/valueOf\n                     org.slf4j.simple.OutputChoice$OutputChoiceType \"SYS_OUT\")\n            ctor (.getDeclaredConstructor\n                  org.slf4j.simple.OutputChoice\n                  (into-array Class [org.slf4j.simple.OutputChoice$OutputChoiceType]))]\n        (.setAccessible ctor true)\n        (.set oc-field config (.newInstance ctor (object-array [sys-out]))))))\n  (catch Exception _))\n\n\nnil\n\nSome libraries (e.g., Tribuo) use java.util.logging (JUL) directly instead of SLF4J. JUL defaults to stderr, which Clay renders as ## ERR sections. The following redirects JUL output to stdout:\n\n(let [root (java.util.logging.Logger/getLogger \"\")\n      handler (proxy [java.util.logging.StreamHandler]\n                     [System/out (java.util.logging.SimpleFormatter.)]\n                (publish [record]\n                  (proxy-super publish record)\n                  (.flush this))\n                (close [] (.flush this)))]\n  (doseq [h (.getHandlers root)]\n    (.removeHandler root h))\n  (.addHandler root handler))\n\n\nnil\n\nOther notebooks in this book require this namespace to activate logging. In your own projects, configure your preferred SLF4J backend instead.\n\nsource: notebooks/pocket_book/logging.clj",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html",
    "href": "pocket_book.recursive_caching_in_pipelines.html",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nWhen you pass a Cached value as an argument to another cached function, Pocket handles this recursively. The cache key for the outer computation is derived from the identity of the inner computation (its function name and arguments), not from its result. This means the entire pipeline‚Äôs cache key captures the full computation graph.\nPocket automatically derefs any Cached arguments before calling the function, so pipeline functions receive plain values and don‚Äôt need any special handling.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#setup",
    "href": "pocket_book.recursive_caching_in_pipelines.html#setup",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "",
    "text": "(ns pocket-book.recursive-caching-in-pipelines\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; String utilities:\n   [clojure.string :as str]))\n\n\n(def cache-dir \"/tmp/pocket-demo-pipelines\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.485 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-pipelines\n\n\n\n\n\n\"/tmp/pocket-demo-pipelines\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.486 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-pipelines\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-pipelines\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#a-three-step-pipeline",
    "href": "pocket_book.recursive_caching_in_pipelines.html#a-three-step-pipeline",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "A three-step pipeline",
    "text": "A three-step pipeline\nWe‚Äôll build a simple data science pipeline with three stages: load data, preprocess it, and train a model. Each stage is wrapped with caching-fn so every call returns a Cached object. Passing one Cached result into the next stage is what makes the caching recursive.\nflowchart LR\n    LD[load-dataset] --&gt; PP[preprocess]\n    PP --&gt; TM[train-model]",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#pipeline-functions",
    "href": "pocket_book.recursive_caching_in_pipelines.html#pipeline-functions",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Pipeline functions",
    "text": "Pipeline functions\n\n(defn load-dataset [path]\n  (println \"Loading dataset from\" path \"...\")\n  (Thread/sleep 300)\n  {:data [1 2 3 4 5] :source path})\n\n\n(defn preprocess [data opts]\n  (println \"Preprocessing with options:\" opts)\n  (Thread/sleep 300)\n  (update data :data #(map (fn [x] (* x (:scale opts))) %)))\n\n\n(defn train-model [data params]\n  (println \"Training model with params:\" params)\n  (Thread/sleep 300)\n  {:model :trained :accuracy 0.95 :data data})\n\nWrap each function with caching-fn so every call returns a Cached object:\n\n(def load-dataset* (pocket/caching-fn #'load-dataset))\n\n\n(def preprocess* (pocket/caching-fn #'preprocess))\n\n\n(def train-model* (pocket/caching-fn #'train-model))",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#running-the-pipeline",
    "href": "pocket_book.recursive_caching_in_pipelines.html#running-the-pipeline",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Running the pipeline",
    "text": "Running the pipeline\nChain cached computations in a pipeline:\nFirst pipeline run:\n\n(time\n (-&gt; \"data/raw.csv\"\n     (load-dataset*)\n     (preprocess* {:scale 2})\n     (train-model* {:epochs 100})\n     deref\n     (select-keys [:model :accuracy])))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:37.491 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/train-model\n18:23:37.492 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess\n18:23:37.492 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset\nLoading dataset from data/raw.csv ...\nPreprocessing with options: {:scale 2}\nTraining model with params: {:epochs 100}\n\"Elapsed time: 907.323822 msecs\"\n\n\n\n\n\n{:model :trained, :accuracy 0.95}\n\nRun the same pipeline again ‚Äî everything loads from cache:\nSecond pipeline run (all cached):\n\n(time\n (-&gt; \"data/raw.csv\"\n     (load-dataset*)\n     (preprocess* {:scale 2})\n     (train-model* {:epochs 100})\n     deref\n     (select-keys [:model :accuracy])))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.60708 msecs\"\n\n\n\n\n\n{:model :trained, :accuracy 0.95}\n\nNo log output above ‚Äî the result was served entirely from the in-memory cache, so no disk I/O or computation occurred. Each step caches independently. If you change only the last step (e.g., different training params), the upstream steps load from cache while only the final step recomputes.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#provenance-in-cache-entries",
    "href": "pocket_book.recursive_caching_in_pipelines.html#provenance-in-cache-entries",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Provenance in cache entries",
    "text": "Provenance in cache entries\nThe cache entries reveal the pipeline structure. Each entry‚Äôs identity encodes its full computation history ‚Äî not just the function name, but the nested identities of all its cached inputs.\n\n(-&gt;&gt; (pocket/cache-entries)\n     (mapv :id))\n\n\n[\"(pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\")\"\n \"(pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\") {:scale 2})\"\n \"(pocket-book.recursive-caching-in-pipelines/train-model (pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\") {:scale 2}) {:epochs 100})\"]\n\n\n(-&gt;&gt; (pocket/cache-entries)\n     (mapv :id)\n     (str/join \"\\n\")\n     kind/code)\n\n\n(pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\")\n(pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\") {:scale 2})\n(pocket-book.recursive-caching-in-pipelines/train-model (pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\") {:scale 2}) {:epochs 100})\n\nThe inner step appears as a literal sub-expression in the outer step‚Äôs identity. This is how Pocket tracks provenance: the cache key for train-model records that its input came from preprocess, which in turn came from load-dataset.\nThis happens automatically when you pass Cached objects (without derefing) from one cached step to the next. If you deref early with @ (or deref), the downstream step sees a plain value and the provenance link is lost ‚Äî the cache key is based on the value‚Äôs hash instead. Both patterns work; the choice is whether you need traceability.\nFor a fuller example with branching dependencies, see the Real-World Walkthrough.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#inspecting-the-dag",
    "href": "pocket_book.recursive_caching_in_pipelines.html#inspecting-the-dag",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Inspecting the DAG",
    "text": "Inspecting the DAG\nPocket provides three functions for DAG introspection:\n\norigin-story ‚Äî nested tree with :ref pointers for shared nodes\norigin-story-graph ‚Äî flat {:nodes ... :edges ...} for graph algorithms\norigin-story-mermaid ‚Äî Mermaid flowchart string for visualization\n\nBuild the pipeline keeping the intermediate Cached objects:\n\n(def data-c (load-dataset* \"data/experiment.csv\"))\n\n\n(def preprocessed-c (preprocess* data-c {:scale 2}))\n\n\n(def model-c (train-model* preprocessed-c {:epochs 100}))\n\n\norigin-story ‚Äî tree structure\nReturns a nested map where each cached step is {:fn &lt;var&gt; :args [...] :id &lt;string&gt;}. Plain arguments become {:value ...} leaves. If a step has been computed, :value is included.\nBefore any computation:\n\n(pocket/origin-story model-c)\n\n\n{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n :args\n [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :args\n   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n     :args [{:value \"data/experiment.csv\"}],\n     :id \"c3\"}\n    {:value {:scale 2}}],\n   :id \"c2\"}\n  {:value {:epochs 100}}],\n :id \"c1\"}\n\nNo :value keys yet. Now trigger computation:\n\n(deref model-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:38.411 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/train-model\n18:23:38.411 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess\n18:23:38.411 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset\nLoading dataset from data/experiment.csv ...\nPreprocessing with options: {:scale 2}\nTraining model with params: {:epochs 100}\n\n\n\n\n\n{:model :trained,\n :accuracy 0.95,\n :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}\n\nAfter deref, every node includes its :value:\n\n(pocket/origin-story model-c)\n\n\n{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n :args\n [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :args\n   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n     :args [{:value \"data/experiment.csv\"}],\n     :id \"c3\",\n     :value {:data [1 2 3 4 5], :source \"data/experiment.csv\"}}\n    {:value {:scale 2}}],\n   :id \"c2\",\n   :value {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}\n  {:value {:epochs 100}}],\n :id \"c1\",\n :value\n {:model :trained,\n  :accuracy 0.95,\n  :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}}\n\nWhen the same Cached instance appears multiple times (diamond pattern), subsequent occurrences are {:ref &lt;id&gt;} pointing to the first.\n\n\norigin-story-graph ‚Äî flat graph\nReturns {:nodes {&lt;id&gt; &lt;node-map&gt;} :edges [[&lt;from&gt; &lt;to&gt;] ...]}. Useful for graph algorithms or custom rendering.\n\n(pocket/origin-story-graph model-c)\n\n\n{:nodes\n {\"c1\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n   :value\n   {:model :trained,\n    :accuracy 0.95,\n    :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}},\n  \"c2\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :value {:data (2 4 6 8 10), :source \"data/experiment.csv\"}},\n  \"c3\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n   :value {:data [1 2 3 4 5], :source \"data/experiment.csv\"}},\n  \"v4\" {:value \"data/experiment.csv\"},\n  \"v5\" {:value {:scale 2}},\n  \"v6\" {:value {:epochs 100}}},\n :edges [[\"c1\" \"c2\"] [\"c2\" \"c3\"] [\"c3\" \"v4\"] [\"c2\" \"v5\"] [\"c1\" \"v6\"]]}\n\n\n\norigin-story-mermaid ‚Äî visualization\nReturns a Mermaid flowchart string. Arrows show data flow direction (from inputs toward the final result). It returns a kindly value that renders directly.\n\n(pocket/origin-story-mermaid model-c)\n\nflowchart TD\n  n0[\"train-model\"]\n  n1[\"preprocess\"]\n  n2[\"load-dataset\"]\n  n3[/\"'data/experiment.csv'\"/]\n  n3 --&gt; n2\n  n2 --&gt; n1\n  n4[/\"{:scale 2}\"/]\n  n4 --&gt; n1\n  n1 --&gt; n0\n  n5[/\"{:epochs 100}\"/]\n  n5 --&gt; n0",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#cleanup",
    "href": "pocket_book.recursive_caching_in_pipelines.html#cleanup",
    "title": "5¬† Recursive Caching in Pipelines",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.323 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-pipelines\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-pipelines\", :existed true}\n\n\nsource: notebooks/pocket_book/recursive_caching_in_pipelines.clj",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html",
    "href": "pocket_book.usage_practices.html",
    "title": "6¬† Usage Practices",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nThis chapter expands on the basics from Getting Started with practical patterns for day-to-day work: function identity in depth, cache invalidation strategies, testing, REPL introspection, serialization constraints, and debugging tips.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#setup",
    "href": "pocket_book.usage_practices.html#setup",
    "title": "6¬† Usage Practices",
    "section": "",
    "text": "(ns pocket-book.usage-practices\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]))\n\n\n(def test-dir \"/tmp/pocket-dev-practices\")\n\n\n(pocket/set-base-cache-dir! test-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.381 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-dev-practices\n\n\n\n\n\n\"/tmp/pocket-dev-practices\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#when-to-use-pocket",
    "href": "pocket_book.usage_practices.html#when-to-use-pocket",
    "title": "6¬† Usage Practices",
    "section": "When to Use Pocket",
    "text": "When to Use Pocket\n\nGood use cases\n\nData science pipelines with expensive intermediate steps (data loading, preprocessing, feature engineering, model training)\nReproducible research where cached intermediate results let you iterate on downstream steps without re-running upstream computations\nLong-running computations (minutes to hours) that need to survive JVM restarts, crashes, or machine reboots\nMulti-threaded workflows where multiple threads may request the same expensive computation ‚Äî Pocket ensures it runs only once\n\n\n\nComparison to alternatives\n\n\n\nFeature\nPocket\nclojure.core/memoize\ncore.memoize\n\n\n\n\nPersistence\nDisk + memory\nMemory only\nMemory only\n\n\nCross-session\nYes\nNo\nNo\n\n\nLazy evaluation\nIDeref\nEager\nEager\n\n\nEviction policies\nLRU, FIFO, TTL, etc.\nNone\nLRU, TTL, etc.\n\n\nThread-safe (single computation)\nYes\nNo\nYes\n\n\nPipeline caching\nYes (recursive)\nNo\nNo",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#function-identity-use-vars-or-keywords",
    "href": "pocket_book.usage_practices.html#function-identity-use-vars-or-keywords",
    "title": "6¬† Usage Practices",
    "section": "Function Identity: Use Vars or Keywords",
    "text": "Function Identity: Use Vars or Keywords\nPocket requires functions to be passed as vars (#'fn-name) or keywords (e.g., :train), not as bare function objects.\n;; ‚ùå WRONG - bare function, unstable identity\n(pocket/cached my-expensive-fn arg1 arg2)\n\n;; ‚úÖ CORRECT - var, stable identity\n(pocket/cached #'my-expensive-fn arg1 arg2)\n\n;; ‚úÖ CORRECT - keyword, stable identity\n(pocket/cached :train cached-split)\nWhy? Function objects have different identity across JVM sessions, making cache keys unpredictable. Vars provide stable symbol names that survive restarts. Keywords are inherently stable and work naturally as map accessors on cached values.\nPocket validates this and throws a clear error if you forget:\n\n(defn example-fn [x] (* x x))\n\n\n(try\n  (pocket/cached example-fn 5)\n  (catch Exception e\n    (ex-message e)))\n\n\n\"pocket/cached requires a var or keyword (e.g., #'my-fn or :my-key), got: class pocket_book.usage_practices$example_fn\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#cache-invalidation-strategies",
    "href": "pocket_book.usage_practices.html#cache-invalidation-strategies",
    "title": "6¬† Usage Practices",
    "section": "Cache Invalidation Strategies",
    "text": "Cache Invalidation Strategies\nPocket does not automatically detect when a function‚Äôs implementation changes. You must invalidate manually. Here are the strategies:\n\nStrategy 1: Manual Invalidation\nUse invalidate! for specific entries or invalidate-fn! for all entries of a function:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.385 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed false}\n\n\n(defn transform [x] (* x 2))\n\nCache a computation:\n\n(deref (pocket/cached #'transform 10))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.386 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n20\n\nFunction implementation changed ‚Äî invalidate a single entry:\n\n(pocket/invalidate! #'transform 10)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.389 INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-dev-practices/1c/(pocket-book.usage-practices_transform 10) existed= true\n\n\n\n\n\n{:path\n \"/tmp/pocket-dev-practices/1c/(pocket-book.usage-practices_transform 10)\",\n :existed true}\n\nOr invalidate all entries for a function:\n\n(deref (pocket/cached #'transform 1))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.390 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n2\n\n\n(deref (pocket/cached #'transform 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.391 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n4\n\n\n(pocket/invalidate-fn! #'transform)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.393 INFO scicloj.pocket.impl.cache - Invalidated 2 entries for pocket-book.usage-practices/transform\n\n\n\n\n\n{:fn-name \"pocket-book.usage-practices/transform\",\n :count 2,\n :paths\n [\"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\"\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\"]}\n\n\n\nStrategy 2: Versioning Pattern\nAdd a version key to your function‚Äôs input. Bumping the version creates new cache entries while preserving old ones for comparison:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.394 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn process-data [{:keys [data version]}]\n  {:result (reduce + data)\n   :version version})\n\nVersion 1:\n\n(deref (pocket/cached #'process-data {:data [1 2 3] :version 1}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.397 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-data\n\n\n\n\n\n{:result 6, :version 1}\n\nAfter changing the function, bump version:\n\n(deref (pocket/cached #'process-data {:data [1 2 3] :version 2}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.399 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-data\n\n\n\n\n\n{:result 6, :version 2}\n\nBoth versions coexist in cache ‚Äî useful for A/B comparison.\n\n\nStrategy 3: Full Cleanup\nFor a fresh start, use cleanup! to delete the entire cache:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.401 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#testing-with-pocket",
    "href": "pocket_book.usage_practices.html#testing-with-pocket",
    "title": "6¬† Usage Practices",
    "section": "Testing with Pocket",
    "text": "Testing with Pocket\nTests should be isolated from production caches and from each other. Use binding and cleanup fixtures:\n\nTest Fixture Pattern\n(def test-cache-dir \"/tmp/my-project-test-cache\")\n\n(defn cleanup-fixture [f]\n  (binding [pocket/*base-cache-dir* test-cache-dir]\n    (pocket/cleanup!)\n    (try\n      (f)\n      (finally\n        (pocket/cleanup!)))))\n\n(use-fixtures :each cleanup-fixture)\nThis ensures: 1. Tests use a separate cache directory 2. Cache is cleared before and after each test 3. Tests don‚Äôt affect each other\n\n\nVerifying Cache Behavior\nUse an atom to track computation calls:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.402 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed false}\n\n\n(def call-count (atom 0))\n\n\n(defn tracked-fn [x]\n  (swap! call-count inc)\n  (* x x))\n\nFirst call computes:\n\n(reset! call-count 0)\n\n\n0\n\n\n(let [result (deref (pocket/cached #'tracked-fn 5))\n      calls @call-count]\n  {:result result :calls calls})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.404 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/tracked-fn\n\n\n\n\n\n{:result 25, :calls 1}\n\nSecond call uses cache (no additional computation):\n\n(let [result (deref (pocket/cached #'tracked-fn 5))\n      calls @call-count]\n  {:result result :calls calls})\n\n\n{:result 25, :calls 1}",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#repl-development-workflow",
    "href": "pocket_book.usage_practices.html#repl-development-workflow",
    "title": "6¬† Usage Practices",
    "section": "REPL Development Workflow",
    "text": "REPL Development Workflow\n\nInspecting the Cache\nUse introspection functions to understand cache state:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.408 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(deref (pocket/cached #'transform 1))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.409 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n2\n\n\n(deref (pocket/cached #'transform 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.410 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n4\n\n\n(deref (pocket/cached #'tracked-fn 3))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.411 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/tracked-fn\n\n\n\n\n\n9\n\nSee all cached entries:\n\n(count (pocket/cache-entries))\n\n\n3\n\nGet aggregate statistics:\n\n(:total-entries (pocket/cache-stats))\n\n\n3\n\nVisualize cache structure:\n\n(pocket/dir-tree)\n\n\npocket-dev-practices\n‚îú‚îÄ‚îÄ db\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.usage-practices_transform 1)\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ e4\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.usage-practices_transform 2)\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îî‚îÄ‚îÄ e8\n    ‚îî‚îÄ‚îÄ (pocket-book.usage-practices_tracked-fn 3)\n        ‚îú‚îÄ‚îÄ meta.edn\n        ‚îî‚îÄ‚îÄ value.nippy\n\nEach directory contains a meta.edn file with metadata about the cached computation:\n\n(-&gt; (pocket/cache-entries)\n    first\n    :path\n    (str \"/meta.edn\")\n    slurp\n    clojure.edn/read-string)\n\n\n{:id \"(pocket-book.usage-practices/transform 1)\",\n :fn-name \"pocket-book.usage-practices/transform\",\n :args-str \"[1]\",\n :created-at \"2026-02-08T16:23:39.409524639Z\"}\n\nThis same information is available through the API:\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\",\n  :id \"(pocket-book.usage-practices/transform 1)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[1]\",\n  :created-at \"2026-02-08T16:23:39.409524639Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\",\n  :id \"(pocket-book.usage-practices/transform 2)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[2]\",\n  :created-at \"2026-02-08T16:23:39.410899061Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e8/(pocket-book.usage-practices_tracked-fn 3)\",\n  :id \"(pocket-book.usage-practices/tracked-fn 3)\",\n  :fn-name \"pocket-book.usage-practices/tracked-fn\",\n  :args-str \"[3]\",\n  :created-at \"2026-02-08T16:23:39.411846903Z\"}]\n\nFilter entries by function name:\n\n(pocket/cache-entries (str (ns-name *ns*) \"/transform\"))\n\n\n[{:path\n  \"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\",\n  :id \"(pocket-book.usage-practices/transform 1)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[1]\",\n  :created-at \"2026-02-08T16:23:39.409524639Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\",\n  :id \"(pocket-book.usage-practices/transform 2)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[2]\",\n  :created-at \"2026-02-08T16:23:39.410899061Z\"}]\n\n\n\nChecking Cached Status\nCached values print their status without forcing computation:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.422 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(def pending-value (pocket/cached #'transform 99))\n\nBefore deref:\n\n(pr-str pending-value)\n\n\n\"#&lt;Cached (pocket-book.usage-practices/transform 99) :pending&gt;\"\n\n\n(deref pending-value)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.425 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n198\n\nAfter deref:\n\n(pr-str pending-value)\n\n\n\"#&lt;Cached (pocket-book.usage-practices/transform 99) :cached&gt;\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#debugging-with-logging",
    "href": "pocket_book.usage_practices.html#debugging-with-logging",
    "title": "6¬† Usage Practices",
    "section": "Debugging with Logging",
    "text": "Debugging with Logging\nEnable debug logging to see cache hits, misses, and writes. See the Logging chapter for setup.\nWith debug logging enabled, you‚Äôll see:\n\nCache miss, computing: ... ‚Äî computation triggered\nCache hit (memory): ... ‚Äî served from in-memory cache\nCache hit (disk): ... ‚Äî loaded from disk\nCache write: ... ‚Äî written to disk",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#long-cache-keys",
    "href": "pocket_book.usage_practices.html#long-cache-keys",
    "title": "6¬† Usage Practices",
    "section": "Long Cache Keys",
    "text": "Long Cache Keys\nWhen a cache key string exceeds 240 characters, Pocket falls back to using a SHA-1 hash as the directory name. This ensures the filesystem can handle arbitrarily complex arguments while maintaining correct caching behavior.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.428 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn process-long-text [text]\n  (str \"Processed: \" (count text) \" chars\"))\n\n\n(def long-text (apply str (repeat 300 \"x\")))\n\n\n(deref (pocket/cached #'process-long-text long-text))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.430 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-long-text\n\n\n\n\n\n\"Processed: 300 chars\"\n\nThe entry is stored with a hash-based directory name:\n\n(pocket/dir-tree)\n\n\npocket-dev-practices\n‚îî‚îÄ‚îÄ 6d\n    ‚îî‚îÄ‚îÄ 6d7a9c06574c78354a8235a2e77b6ed27348e404\n        ‚îú‚îÄ‚îÄ meta.edn\n        ‚îî‚îÄ‚îÄ value.nippy\n\nBut meta.edn inside still contains the full details, so cache-entries and invalidate-fn! work correctly:\n\n(-&gt; (pocket/cache-entries (str (ns-name *ns*) \"/process-long-text\"))\n    first\n    :fn-name)\n\n\n\"pocket-book.usage-practices/process-long-text\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#serialization-constraints",
    "href": "pocket_book.usage_practices.html#serialization-constraints",
    "title": "6¬† Usage Practices",
    "section": "Serialization Constraints",
    "text": "Serialization Constraints\nPocket uses Nippy for serialization. Most Clojure data structures work, but some don‚Äôt:\n\n‚úÖ Safe to Cache\n\nPrimitive types (numbers, strings, keywords, symbols)\nCollections (vectors, maps, sets, lists)\nRecords and most deftypes\nJava Serializable objects\n\n\n\n‚ö†Ô∏è Requires Care\n\nLazy sequences ‚Äî Nippy fully realizes them during serialization, which means infinite lazy seqs will hang or OOM. Force lazy seqs with doall inside your function (see below) to keep realization explicit and catch errors early. The round-trip type may also change (a LazySeq comes back as a regular seq).\n\n\n\n‚ùå Cannot Cache\n\nOpen file handles, streams\nNetwork connections, sockets\nFunctions, closures (use vars instead)\nAtoms, refs, agents (stateful references)\n\n\n\nLazy Sequences\nUse doall or vec to force evaluation inside your function:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.436 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn generate-data [n]\n  ;; doall forces full evaluation of the lazy sequence\n  (doall (range n)))\n\n\n(deref (pocket/cached #'generate-data 5))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.438 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/generate-data\n\n\n\n\n\n(0 1 2 3 4)",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#known-limitations",
    "href": "pocket_book.usage_practices.html#known-limitations",
    "title": "6¬† Usage Practices",
    "section": "Known Limitations",
    "text": "Known Limitations\n\nNo automatic cache invalidation ‚Äî Pocket doesn‚Äôt detect when a function‚Äôs implementation changes. Use invalidate!, invalidate-fn!, or the versioning pattern described above.\nRequires serializable values ‚Äî Nippy handles most Clojure types, but you can‚Äôt cache functions, atoms, channels, file handles, or other stateful objects.\nDisk cache grows indefinitely ‚Äî The in-memory cache supports eviction policies (LRU, TTL, etc.), but the disk cache has no automatic cleanup. Use cleanup! or invalidate-fn! periodically if disk space is a concern.\nNo disk cache TTL ‚Äî Cached values on disk never expire automatically. If you need time-based expiration, you‚Äôll need to manage it externally or use cleanup!.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#summary",
    "href": "pocket_book.usage_practices.html#summary",
    "title": "6¬† Usage Practices",
    "section": "Summary",
    "text": "Summary\n\n\n\nPractice\nRecommendation\n\n\n\n\nFunction identity\nAlways use vars (#'fn-name)\n\n\nInvalidation\nManual, versioning, or full cleanup\n\n\nTesting\nUse binding + cleanup fixtures\n\n\nDebugging\nEnable logging, use introspection\n\n\nLong cache keys\nAuto-handled with SHA-1 fallback\n\n\nSerialization\nAvoid stateful objects; force lazy seqs with doall\n\n\nConfiguration\nUse pocket.edn ‚Äî see Configuration\n\n\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.441 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\nsource: notebooks/pocket_book/usage_practices.clj",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html",
    "href": "pocket_book.real_world_walkthrough.html",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "",
    "text": "Overview\nLast modified: 2026-02-08\nThis walkthrough demonstrates a realistic data pipeline with multiple stages and branching dependencies. We‚Äôll simulate a weather analysis workflow where raw sensor readings are cleaned, then fed into two independent analyses ‚Äî one for temperature trends and one for rainfall totals. Both analyses share the same cleaned data, so Pocket caches it once and reuses it.\nThis builds on the concepts from Recursive Caching in Pipelines, adding branching dependencies where two analyses share a common upstream computation.\nThe dependency graph: fetch-readings ‚Üí clean-data ‚Üí both temperature-trends and rainfall-totals ‚Üí summary.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#overview",
    "href": "pocket_book.real_world_walkthrough.html#overview",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "",
    "text": "flowchart TD\n    FR[fetch-readings] --&gt; CD[clean-data]\n    CD --&gt; TT[temperature-trends]\n    CD --&gt; RT[rainfall-totals]\n    TT --&gt; S[summary]\n    RT --&gt; S",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#setup",
    "href": "pocket_book.real_world_walkthrough.html#setup",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Setup",
    "text": "Setup\n\n(ns pocket-book.real-world-walkthrough\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Filesystem utilities:\n   [babashka.fs :as fs]))\n\n\n(def cache-dir \"/tmp/pocket-walkthrough\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.528 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-walkthrough\n\n\n\n\n\n\"/tmp/pocket-walkthrough\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.528 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-walkthrough\n\n\n\n\n\n{:dir \"/tmp/pocket-walkthrough\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#pipeline-functions",
    "href": "pocket_book.real_world_walkthrough.html#pipeline-functions",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Pipeline functions",
    "text": "Pipeline functions\nEach function simulates real work with a short delay. Note that these are plain Clojure functions ‚Äî they know nothing about caching.\n\n(defn fetch-readings\n  \"Simulate fetching raw sensor data for a city.\"\n  [opts]\n  (println \"  Fetching readings for\" (:city opts) \"...\")\n  (Thread/sleep 300)\n  {:city (:city opts)\n   :source (:source opts)\n   :readings (case (:city opts)\n               \"Paris\"\n               [{:day 1 :temp-c 15.0 :rain-mm 2.1}\n                {:day 2 :temp-c 17.3 :rain-mm 0.0}\n                {:day 3 :temp-c 14.6 :rain-mm 7.8}\n                {:day 4 :temp-c 18.1 :rain-mm 0.0}\n                {:day 5 :temp-c 13.9 :rain-mm 4.5}\n                {:day 6 :temp-c 16.7 :rain-mm 0.0}\n                {:day 7 :temp-c 19.2 :rain-mm 1.0}]\n               ;; default (London, etc.)\n               [{:day 1 :temp-c 18.2 :rain-mm 0.0}\n                {:day 2 :temp-c 21.5 :rain-mm 5.2}\n                {:day 3 :temp-c 19.8 :rain-mm 12.1}\n                {:day 4 :temp-c 22.0 :rain-mm 0.0}\n                {:day 5 :temp-c 16.3 :rain-mm 8.4}\n                {:day 6 :temp-c 20.1 :rain-mm 0.0}\n                {:day 7 :temp-c 23.7 :rain-mm 3.3}])})\n\n\n(defn clean-data\n  \"Remove readings with missing values and round numbers.\"\n  [raw-data opts]\n  (println \"  Cleaning data for\" (:city raw-data) \"with\" opts \"...\")\n  (Thread/sleep 200)\n  (let [precision (:precision opts 10)]\n    (update raw-data :readings\n            (fn [rs]\n              (-&gt;&gt; rs\n                   (filter #(and (:temp-c %) (:rain-mm %)))\n                   (mapv #(-&gt; %\n                              (update :temp-c (fn [t] (Math/round (* t (double precision)))))\n                              (update :rain-mm (fn [r] (Math/round (* r (double precision))))))))))))\n\n\n(defn temperature-trends\n  \"Compute temperature statistics from cleaned data.\"\n  [clean-data opts]\n  (println \"  Analyzing temperature for\" (:city clean-data) \"...\")\n  (Thread/sleep 300)\n  (let [temps (map :temp-c (:readings clean-data))\n        n (count temps)]\n    {:city (:city clean-data)\n     :unit (:unit opts)\n     :min-temp (apply min temps)\n     :max-temp (apply max temps)\n     :mean-temp (quot (reduce + temps) n)\n     :days n}))\n\n\n(defn rainfall-totals\n  \"Compute rainfall statistics from cleaned data.\"\n  [clean-data opts]\n  (println \"  Analyzing rainfall for\" (:city clean-data) \"...\")\n  (Thread/sleep 300)\n  (let [rains (map :rain-mm (:readings clean-data))\n        rainy-days (count (filter pos? rains))]\n    {:city (:city clean-data)\n     :unit (:unit opts)\n     :total-rain (reduce + rains)\n     :rainy-days rainy-days\n     :dry-days (- (count rains) rainy-days)}))\n\n\n(defn summary\n  \"Combine temperature and rainfall analyses into a report.\"\n  [temp-analysis rain-analysis]\n  (println \"  Generating summary for\" (:city temp-analysis) \"...\")\n  (Thread/sleep 200)\n  (merge temp-analysis rain-analysis\n         {:report (str (:city temp-analysis)\n                       \": temp range \"\n                       (:min-temp temp-analysis) \"‚Äì\"\n                       (:max-temp temp-analysis)\n                       \", total rain \"\n                       (:total-rain rain-analysis)\n                       \" over \" (:rainy-days rain-analysis) \" days\")}))",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#first-run-everything-computes",
    "href": "pocket_book.real_world_walkthrough.html#first-run-everything-computes",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "First run: everything computes",
    "text": "First run: everything computes\nWe build the pipeline using cached. Each call returns a Cached object that we pass directly to the next stage. Pocket derives cache keys from the computation graph, not from intermediate values.\n\n(println \"=== First run ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n=== First run ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"London\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:39.540 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/summary\n18:23:39.540 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/temperature-trends\n18:23:39.540 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/clean-data\n18:23:39.540 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/fetch-readings\n  Fetching readings for London ...\n  Cleaning data for London with {:precision 10, :remove-nulls true} ...\n  Analyzing temperature for London ...\n18:23:40.348 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/rainfall-totals\n  Analyzing rainfall for London ...\n  Generating summary for London ...\n\"Elapsed time: 1314.261118 msecs\"\n\n\n\n\n\n{:report \"London: temp range 163‚Äì237, total rain 290 over 4 days\",\n :max-temp 237,\n :dry-days 3,\n :unit :mm,\n :city \"London\",\n :days 7,\n :total-rain 290,\n :rainy-days 4,\n :mean-temp 202,\n :min-temp 163}\n\nEvery function ran. Notice the log messages showing cache misses, computations, and writes.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#second-run-everything-from-cache",
    "href": "pocket_book.real_world_walkthrough.html#second-run-everything-from-cache",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Second run: everything from cache",
    "text": "Second run: everything from cache\nRunning the exact same pipeline again ‚Äî nothing recomputes:\n\n(println \"\\n=== Second run (fully cached) ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Second run (fully cached) ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"London\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.190533 msecs\"\n\n\n\n\n\n{:report \"London: temp range 163‚Äì237, total rain 290 over 4 days\",\n :max-temp 237,\n :dry-days 3,\n :unit :mm,\n :city \"London\",\n :days 7,\n :total-rain 290,\n :rainy-days 4,\n :mean-temp 202,\n :min-temp 163}\n\nNo log output ‚Äî served entirely from the in-memory cache.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#changing-an-upstream-input",
    "href": "pocket_book.real_world_walkthrough.html#changing-an-upstream-input",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Changing an upstream input",
    "text": "Changing an upstream input\nNow suppose we want a different city. The entire pipeline recomputes because the root input changed:\n\n(println \"\\n=== Different city ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Different city ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"Paris\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:40.866 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/summary\n18:23:40.866 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/temperature-trends\n18:23:40.866 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/clean-data\n18:23:40.866 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/fetch-readings\n  Fetching readings for Paris ...\n  Cleaning data for Paris with {:precision 10, :remove-nulls true} ...\n  Analyzing temperature for Paris ...\n18:23:41.672 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/rainfall-totals\n  Analyzing rainfall for Paris ...\n  Generating summary for Paris ...\n\"Elapsed time: 1310.094543 msecs\"\n\n\n\n\n\n{:report \"Paris: temp range 139‚Äì192, total rain 154 over 4 days\",\n :max-temp 192,\n :dry-days 3,\n :unit :mm,\n :city \"Paris\",\n :days 7,\n :total-rain 154,\n :rainy-days 4,\n :mean-temp 164,\n :min-temp 139}\n\nBut running it again is instant ‚Äî Paris is now cached too:\n\n(println \"\\n=== Paris again (cached) ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Paris again (cached) ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"Paris\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.19468 msecs\"\n\n\n\n\n\n{:report \"Paris: temp range 139‚Äì192, total rain 154 over 4 days\",\n :max-temp 192,\n :dry-days 3,\n :unit :mm,\n :city \"Paris\",\n :days 7,\n :total-rain 154,\n :rainy-days 4,\n :mean-temp 164,\n :min-temp 139}\n\nNo log output ‚Äî served entirely from the in-memory cache.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#inspecting-the-cache-on-disk",
    "href": "pocket_book.real_world_walkthrough.html#inspecting-the-cache-on-disk",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Inspecting the cache on disk",
    "text": "Inspecting the cache on disk\nLet‚Äôs look at what Pocket stored. The cache directory is organized by a SHA-1 prefix, then a human-readable directory named after the function and arguments.\n\nCache entries\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-walkthrough/17/17db4a12cb5e1ba8da076b6148be68b333bc6a16\",\n  :id\n  \"(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius})\",\n  :fn-name \"pocket-book.real-world-walkthrough/temperature-trends\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}]\",\n  :created-at \"2026-02-08T16:23:40.347400117Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/be/be026e38b57ab3e7ce5623eff753a616df974e93\",\n  :id\n  \"(pocket-book.real-world-walkthrough/summary (pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}))\",\n  :fn-name \"pocket-book.real-world-walkthrough/summary\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})]\",\n  :created-at \"2026-02-08T16:23:42.174382934Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/2c/(pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :fn-name \"pocket-book.real-world-walkthrough/clean-data\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}]\",\n  :created-at \"2026-02-08T16:23:40.045059217Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/6d/(pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :fn-name \"pocket-book.real-world-walkthrough/rainfall-totals\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}]\",\n  :created-at \"2026-02-08T16:23:41.972669177Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/50/50a0ffd14b1b8fa3a7ba7a1fa3d75cf5b26f0c57\",\n  :id\n  \"(pocket-book.real-world-walkthrough/summary (pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}))\",\n  :fn-name \"pocket-book.real-world-walkthrough/summary\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})]\",\n  :created-at \"2026-02-08T16:23:40.852996082Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/36/(pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :fn-name \"pocket-book.real-world-walkthrough/clean-data\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}]\",\n  :created-at \"2026-02-08T16:23:41.368609323Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/49/(pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api})\",\n  :fn-name \"pocket-book.real-world-walkthrough/fetch-readings\",\n  :args-str \"[{:city \\\"Paris\\\", :days 7, :source :api}]\",\n  :created-at \"2026-02-08T16:23:41.166683989Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/29/(pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api})\",\n  :fn-name \"pocket-book.real-world-walkthrough/fetch-readings\",\n  :args-str \"[{:city \\\"London\\\", :days 7, :source :api}]\",\n  :created-at \"2026-02-08T16:23:39.841446444Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/a4/(pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :fn-name \"pocket-book.real-world-walkthrough/rainfall-totals\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}]\",\n  :created-at \"2026-02-08T16:23:40.650278216Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/4d/4d7d654476f96c5a4808c863dd3c29e845d4a9f6\",\n  :id\n  \"(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius})\",\n  :fn-name \"pocket-book.real-world-walkthrough/temperature-trends\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}]\",\n  :created-at \"2026-02-08T16:23:41.670654707Z\"}]\n\n\n\nCache statistics\n\n(pocket/cache-stats)\n\n\n{:total-entries 10,\n :total-size-bytes 16707,\n :entries-per-fn\n {\"pocket-book.real-world-walkthrough/temperature-trends\" 2,\n  \"pocket-book.real-world-walkthrough/summary\" 2,\n  \"pocket-book.real-world-walkthrough/clean-data\" 2,\n  \"pocket-book.real-world-walkthrough/rainfall-totals\" 2,\n  \"pocket-book.real-world-walkthrough/fetch-readings\" 2}}\n\n\n\nDirectory tree\nEach entry contains either a value.nippy file (serialized value) or a nil marker, plus a meta.edn with metadata. Here is the actual cache directory tree, generated dynamically.\nNotice that some entries use human-readable directory names while others fall back to SHA-1 hashes ‚Äî this happens when the cache key (which includes the full upstream computation chain) exceeds 240 characters. The meta.edn inside each entry always contains the full details.\n\n(pocket/dir-tree)\n\n\npocket-walkthrough\n‚îú‚îÄ‚îÄ 17\n‚îÇ   ‚îî‚îÄ‚îÄ 17db4a12cb5e1ba8da076b6148be68b333bc6a16\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 29\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 2c\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 36\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 49\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 4d\n‚îÇ   ‚îî‚îÄ‚îÄ 4d7d654476f96c5a4808c863dd3c29e845d4a9f6\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 50\n‚îÇ   ‚îî‚îÄ‚îÄ 50a0ffd14b1b8fa3a7ba7a1fa3d75cf5b26f0c57\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ 6d\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îú‚îÄ‚îÄ a4\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îî‚îÄ‚îÄ be\n    ‚îî‚îÄ‚îÄ be026e38b57ab3e7ce5623eff753a616df974e93\n        ‚îú‚îÄ‚îÄ meta.edn\n        ‚îî‚îÄ‚îÄ value.nippy",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#cleanup",
    "href": "pocket_book.real_world_walkthrough.html#cleanup",
    "title": "7¬† Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Cleanup",
    "text": "Cleanup\nRemove all cached data:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:42.194 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-walkthrough\n\n\n\n\n\n{:dir \"/tmp/pocket-walkthrough\", :existed true}\n\n\nsource: notebooks/pocket_book/real_world_walkthrough.clj",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html",
    "href": "pocket_book.concurrency.html",
    "title": "8¬† Concurrency",
    "section": "",
    "text": "The Challenge\nLast modified: 2026-02-08\nPocket guarantees that when multiple threads deref the same Cached value concurrently, the underlying computation executes exactly once. This chapter explains how that guarantee is achieved and demonstrates the concurrency scenarios it handles.\nThe naive approach to caching ‚Äî check if cached, compute if not ‚Äî has a race condition:\nBoth threads see the cache miss and both compute the value. For expensive computations (minutes, hours), this wastes resources.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#the-challenge",
    "href": "pocket_book.concurrency.html#the-challenge",
    "title": "8¬† Concurrency",
    "section": "",
    "text": "Thread A                    Thread B\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncheck cache ‚Üí miss          check cache ‚Üí miss\ncompute value               compute value     ‚Üê duplicate!\nstore result                store result",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#why-core.cache-alone-is-not-enough",
    "href": "pocket_book.concurrency.html#why-core.cache-alone-is-not-enough",
    "title": "8¬† Concurrency",
    "section": "Why core.cache Alone Is Not Enough",
    "text": "Why core.cache Alone Is Not Enough\nClojure‚Äôs core.cache provides lookup-or-miss which wraps the value function in a delay to prevent duplicate work across swap! retries within a single call. However, each call to lookup-or-miss creates its own delay, and the value function is evaluated inside the swap! body (via through-cache). This means concurrent callers racing into swap! can each see a miss and each start computing before any compare-and-swap succeeds:\nThread A                          Thread B\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nlookup-or-miss\n  create delay-A\n  swap!                           lookup-or-miss\n    through-cache ‚Üí miss            create delay-B\n    @delay-A ‚Üí computing...         swap!\n                                      through-cache ‚Üí miss\n                                      @delay-B ‚Üí computing... ‚Üê duplicate!\nThe swap! compare-and-swap ensures only one result enters the cache, but both computations have already started. The delay prevents redundant work across retries of a single swap! call ‚Äî it does not deduplicate across concurrent callers.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#seeing-the-problem",
    "href": "pocket_book.concurrency.html#seeing-the-problem",
    "title": "8¬† Concurrency",
    "section": "Seeing the Problem",
    "text": "Seeing the Problem\nWe can demonstrate this directly. Here we use core.cache.wrapped/lookup-or-miss with a slow computation and five concurrent threads. A CyclicBarrier synchronizes the threads so they all call lookup-or-miss at the same instant:\n\n(let [call-count (atom 0)\n      cache (cw/lru-cache-factory {} :threshold 32)\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      slow-fn (fn [_key]\n                (swap! call-count inc)\n                (Thread/sleep 500)\n                42)]\n  (let [futures (doall (for [_ (range 5)]\n                         (future\n                           (.await barrier)\n                           (cw/lookup-or-miss cache :same-key slow-fn))))\n        results (mapv deref futures)]\n    {:results results\n     :computation-count @call-count}))\n\n\n{:results [42 42 42 42 42], :computation-count 5}\n\nAll five threads computed the value independently ‚Äî computation-count is greater than 1 (typically 5). The delay inside lookup-or-miss prevented duplicate work on swap! retries within each thread, but concurrent callers each created and forced their own delay.\nScenario 1 (below) repeats this same pattern using Pocket, where the ConcurrentHashMap layer reduces the count to exactly 1.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#pockets-solution",
    "href": "pocket_book.concurrency.html#pockets-solution",
    "title": "8¬† Concurrency",
    "section": "Pocket‚Äôs Solution",
    "text": "Pocket‚Äôs Solution\nPocket adds a ConcurrentHashMap layer that ensures only one delay exists per cache key, regardless of how many threads request it:\n(def ^ConcurrentHashMap in-flight\n  (java.util.concurrent.ConcurrentHashMap.))\n\n;; Inside the lookup-or-miss miss-fn:\n(let [d (.computeIfAbsent\n          in-flight path\n          (fn [_]\n            (delay\n              (try\n                ;; disk check + computation\n                (finally\n                  (.remove in-flight path))))))]\n  @d)\ncomputeIfAbsent is atomic: the first thread creates and inserts the delay; all subsequent threads for the same key receive the same delay instance. Since a Clojure delay executes its body exactly once, the computation runs once and all threads share the result.\n\nFailure Handling\nThe finally block removes the entry from in-flight after computation (success or failure). If a computation throws, the next caller gets a fresh delay and a fresh attempt ‚Äî exceptions are never cached.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#architecture-layers",
    "href": "pocket_book.concurrency.html#architecture-layers",
    "title": "8¬† Concurrency",
    "section": "Architecture Layers",
    "text": "Architecture Layers\nflowchart TB\n    subgraph Request\n    D[deref Cached]\n    end\n    subgraph Synchronization\n    CHM[ConcurrentHashMapin-flight]\n    DEL[delay]\n    end\n    subgraph Caching\n    MEM[Memory Cachecore.cache]\n    DISK[Disk CacheNippy files]\n    end\n    D --&gt; CHM\n    CHM --&gt;|one delay per key| DEL\n    DEL --&gt;|on miss| MEM\n    MEM --&gt;|on miss| DISK\n    DISK --&gt;|on miss| COMP[Compute]\n    COMP --&gt; DISK\n    DISK --&gt; MEM\n    MEM --&gt; D\n\n\n\nLayer\nPurpose\nGuarantee\n\n\n\n\nConcurrentHashMap\nDelay creation\nOne delay per key\n\n\ndelay\nComputation\nOne execution per delay\n\n\ncore.cache (mem-cache)\nIn-memory caching\nFast repeated access\n\n\nDisk cache\nPersistence\nCross-session caching",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#concurrency-scenarios",
    "href": "pocket_book.concurrency.html#concurrency-scenarios",
    "title": "8¬† Concurrency",
    "section": "Concurrency Scenarios",
    "text": "Concurrency Scenarios\nThe following scenarios demonstrate Pocket‚Äôs thread-safety guarantees with various timing patterns.\n\nSetup\n\n(def test-dir \"/tmp/pocket-concurrency-test\")\n\n\n(pocket/set-base-cache-dir! test-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:42.978 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-concurrency-test\n\n\n\n\n\n\"/tmp/pocket-concurrency-test\"\n\nA counter to track how many times computation actually runs:\n\n(def computation-count (atom 0))\n\n\n(defn slow-computation\n  \"A computation that takes 300ms and increments a counter.\"\n  [x]\n  (swap! computation-count inc)\n  (Thread/sleep 300)\n  (* x x))\n\nConvenience function to reset state before each scenario:\n\n(defn fresh-scenario!\n  \"Reset counters and caches for a fresh scenario.\n   Returns the start time for timing measurements.\"\n  ([]\n   (fresh-scenario! {}))\n  ([{:keys [mem-cache-opts]\n     :or {mem-cache-opts {:policy :lru :threshold 3}}}]\n   (reset! computation-count 0)\n   (pocket/cleanup!)\n   (pocket/set-mem-cache-options! mem-cache-opts)\n   {:started-at (java.time.LocalTime/now)\n    :mem-cache mem-cache-opts}))\n\n\n\n\nScenario 1: Concurrent Deref of Same Value\nMultiple threads deref the same Cached object while the computation is still running. All should receive the same result from a single computation.\nTimeline (ms):   0         100        300        400\n                 ‚îÇ          ‚îÇ          ‚îÇ          ‚îÇ\nThread A:       [‚îÄ‚îÄ‚îÄ request ‚îÄ‚îÄ‚îÄ][‚îÄ‚îÄ‚îÄ computing ‚îÄ‚îÄ‚îÄ]‚îÄ‚îÄ‚Üí result\nThread B:                  [‚îÄ‚îÄ‚îÄ request ‚îÄ‚îÄ‚îÄ][ wait ]‚îÄ‚îÄ‚Üí result\n                                             ‚Üë\n                             B waits for A's computation\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:42.984 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:42.985 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n18:23:42.985 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0xae9dc3f \"18:23:42.985244610\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nLaunch 5 threads that all deref the same cached value:\n\n(let [cached-val (pocket/cached #'slow-computation 10)\n      futures (doall (for [_ (range 5)]\n                       (future @cached-val)))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:42.989 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [100 100 100 100 100], :computation-count 1}\n\n\n\n\nScenario 2: Memory Cache Hit\nAfter the first computation, subsequent requests hit the memory cache instantly (no disk I/O, no recomputation).\nTimeline:\nThread A:  [‚îÄ‚îÄ computing ‚îÄ‚îÄ]\n                          ‚Üì\n                     mem-cache populated\nThread B:                         [request]‚îÄ‚îÄ‚Üí instant result\n                                      ‚Üë\n                                memory cache hit\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:43.298 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:43.298 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n18:23:43.298 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x39acc1e3 \"18:23:43.298971385\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nFirst request computes, second is instant (memory hit):\n\n(let [;; First request - computes\n      result-1 @(pocket/cached #'slow-computation 20)\n      count-after-first @computation-count\n      ;; Second request - should hit memory cache\n      start (System/currentTimeMillis)\n      result-2 @(pocket/cached #'slow-computation 20)\n      elapsed (- (System/currentTimeMillis) start)\n      count-after-second @computation-count]\n  {:first-result result-1\n   :second-result result-2\n   :second-elapsed-ms elapsed\n   :computations-after-first count-after-first\n   :computations-after-second count-after-second})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:43.301 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:first-result 400,\n :second-result 400,\n :second-elapsed-ms 0,\n :computations-after-first 1,\n :computations-after-second 1}\n\n\n\n\nScenario 3: Disk Cache Hit After Memory Eviction\nFill the memory cache to evict our entry, then verify the next request reads from disk (not recomputes).\nTimeline:\n1. Compute value for arg=30          ‚Üí stored in mem + disk\n2. Compute 3 more values (31,32,33)  ‚Üí arg=30 evicted from mem (LRU)\n3. Request arg=30 again              ‚Üí disk cache hit (no recompute)\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:43.609 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:43.609 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n18:23:43.609 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x26d29317 \"18:23:43.609247542\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nStep 1: Compute initial value, then fill cache to cause eviction:\n\n(let [;; Compute arg=30\n      _ @(pocket/cached #'slow-computation 30)\n      ;; Fill cache to evict arg=30 (threshold=3)\n      _ @(pocket/cached #'slow-computation 31)\n      _ @(pocket/cached #'slow-computation 32)\n      _ @(pocket/cached #'slow-computation 33)\n      count-before-retry @computation-count\n      ;; Request arg=30 again - should hit disk\n      result @(pocket/cached #'slow-computation 30)\n      count-after-retry @computation-count]\n  {:result result\n   :computations-before-retry count-before-retry\n   :computations-after-retry count-after-retry\n   :disk-hit? (= count-before-retry count-after-retry)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:43.610 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:43.913 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:44.215 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:44.518 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:result 900,\n :computations-before-retry 4,\n :computations-after-retry 4,\n :disk-hit? true}\n\n\n\n\nScenario 4: Failure and Retry\nWhen a computation fails, the exception is not cached. The next caller gets a fresh attempt.\nTimeline:\n1. Thread A requests ‚Üí computation fails (exception)\n2. Thread B requests ‚Üí fresh computation succeeds\n3. Thread C requests ‚Üí cache hit (no recompute)\n\n(def failure-count (atom 0))\n\n\n(defn flaky-computation\n  \"Fails on first call, succeeds thereafter.\"\n  [x]\n  (if (zero? @failure-count)\n    (do (swap! failure-count inc)\n        (throw (ex-info \"Temporary failure\" {:x x})))\n    (do (swap! failure-count inc)\n        (* x 100))))\n\n\n(do\n  (reset! failure-count 0)\n  (pocket/cleanup!)\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:44.829 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n\n\n\n\n\n:ready\n\nFirst attempt fails, second succeeds, third hits cache:\n\n(let [;; First attempt - fails\n      attempt-1 (try\n                  @(pocket/cached #'flaky-computation 5)\n                  (catch Exception e {:error (.getMessage e)}))\n      count-after-1 @failure-count\n      ;; Second attempt - succeeds\n      attempt-2 @(pocket/cached #'flaky-computation 5)\n      count-after-2 @failure-count\n      ;; Third attempt - cache hit\n      attempt-3 @(pocket/cached #'flaky-computation 5)\n      count-after-3 @failure-count]\n  {:attempt-1 attempt-1\n   :attempt-2 attempt-2\n   :attempt-3 attempt-3\n   :counts [count-after-1 count-after-2 count-after-3]})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:44.831 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/flaky-computation\n18:23:44.832 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/flaky-computation\n\n\n\n\n\n{:attempt-1 {:error \"Temporary failure\"},\n :attempt-2 500,\n :attempt-3 500,\n :counts [1 2 2]}\n\n\n\n\nScenario 5: Different Arguments Compute in Parallel\nRequests with different arguments run in parallel (no unnecessary serialization).\nTimeline (ms):   0                   300\n                 ‚îÇ                    ‚îÇ\nThread A (x=40): [‚îÄ‚îÄ‚îÄ‚îÄ computing ‚îÄ‚îÄ‚îÄ‚îÄ]‚îÄ‚îÄ‚Üí 1600\nThread B (x=41): [‚îÄ‚îÄ‚îÄ‚îÄ computing ‚îÄ‚îÄ‚îÄ‚îÄ]‚îÄ‚îÄ‚Üí 1681\nThread C (x=42): [‚îÄ‚îÄ‚îÄ‚îÄ computing ‚îÄ‚îÄ‚îÄ‚îÄ]‚îÄ‚îÄ‚Üí 1764\n                  ‚Üë\n            All start ~simultaneously, run in parallel\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:44.839 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:44.840 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n18:23:44.840 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x3178206e \"18:23:44.840158120\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\n\n(let [start (System/currentTimeMillis)\n      futures (mapv #(future @(pocket/cached #'slow-computation %))\n                    [40 41 42])\n      results (mapv deref futures)\n      elapsed (- (System/currentTimeMillis) start)]\n  {:results results\n   :elapsed-ms elapsed\n   :parallel? (&lt; elapsed 500)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:44.842 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:44.842 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:44.842 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [1600 1681 1764], :elapsed-ms 303, :parallel? true}\n\n\n\n\nScenario 6: Disk Hit with Empty Memory Cache\nClear memory cache while keeping disk cache. All requests should read from disk without recomputing.\nSetup: value for arg=50 is on disk but NOT in memory\n\nThreads A, B, C all request x=50\n‚Üí All read from disk (no computation)\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:45.151 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:45.151 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n18:23:45.151 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x6a6e19c5 \"18:23:45.151958642\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nCompute, clear memory, then hit disk:\n\n(let [;; Compute and cache arg=50\n      _ @(pocket/cached #'slow-computation 50)\n      count-after-compute @computation-count\n      ;; Clear only memory cache (disk remains)\n      _ (pocket/clear-mem-cache!)\n      ;; Multiple threads hit disk cache\n      futures (mapv (fn [_] (future @(pocket/cached #'slow-computation 50)))\n                    (range 3))\n      results (mapv deref futures)\n      count-after-disk-hits @computation-count]\n  {:results results\n   :count-after-compute count-after-compute\n   :count-after-disk-hits count-after-disk-hits\n   :no-recompute? (= count-after-compute count-after-disk-hits)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:45.154 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [2500 2500 2500],\n :count-after-compute 1,\n :count-after-disk-hits 1,\n :no-recompute? true}\n\n\n\n\nScenario 7: Full Cache Hierarchy Test\nA comprehensive scenario testing all cache layers:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Step 1: Request x=60         ‚Üí COMPUTE (miss everywhere)    ‚îÇ\n‚îÇ Step 2: Request x=60 again   ‚Üí MEMORY HIT (instant)         ‚îÇ\n‚îÇ Step 3: Evict from memory    ‚Üí (fill cache with other vals) ‚îÇ\n‚îÇ Step 4: Request x=60         ‚Üí DISK HIT (read from disk)    ‚îÇ\n‚îÇ Step 5: Delete disk cache    ‚Üí invalidate!                  ‚îÇ\n‚îÇ Step 6: Request x=60         ‚Üí COMPUTE (miss everywhere)    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n(fresh-scenario! {:mem-cache-opts {:policy :lru :threshold 2}})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:45.463 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:45.464 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 2}\n18:23:45.464 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 2}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0xfd2c58b \"18:23:45.464197668\"],\n :mem-cache {:policy :lru, :threshold 2}}\n\n\n(let [;; Step 1: Initial computation\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-1 @computation-count\n\n      ;; Step 2: Memory hit (should be instant)\n      start-2 (System/currentTimeMillis)\n      _ @(pocket/cached #'slow-computation 60)\n      elapsed-2 (- (System/currentTimeMillis) start-2)\n      count-step-2 @computation-count\n\n      ;; Step 3: Evict from memory by filling cache\n      _ @(pocket/cached #'slow-computation 61)\n      _ @(pocket/cached #'slow-computation 62)\n      count-step-3 @computation-count\n\n      ;; Step 4: Disk hit (memory miss)\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-4 @computation-count\n\n      ;; Step 5: Delete disk cache\n      _ (pocket/invalidate! #'slow-computation 60)\n      _ (pocket/clear-mem-cache!)\n\n      ;; Step 6: Recompute (miss everywhere)\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-6 @computation-count]\n  {:count-step-1 count-step-1\n   :elapsed-step-2 elapsed-2\n   :count-step-2 count-step-2\n   :count-step-3 count-step-3\n   :count-step-4 count-step-4\n   :count-step-6 count-step-6})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:45.467 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:45.769 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:46.071 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:46.374 INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-concurrency-test/f4/(pocket-book.concurrency_slow-computation 60) existed= true\n18:23:46.374 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:count-step-1 1,\n :elapsed-step-2 0,\n :count-step-2 1,\n :count-step-3 3,\n :count-step-4 3,\n :count-step-6 4}\n\n\n\nScenario 8: Synchronized Start (Barrier)\nA stricter variant of Scenario 1 that uses a CyclicBarrier to guarantee all threads enter deref at the same instant. This is the direct contrast to the core.cache demonstration above.\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:46.683 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:46.683 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n18:23:46.683 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x65a2525e \"18:23:46.683336429\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @(pocket/cached #'slow-computation 70))))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:46.692 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [4900 4900 4900 4900 4900], :computation-count 1}\n\n\n\n\nScenario 9: Concurrent Pipeline Deref\nA pipeline where step 2 takes a Cached step 1 result as an argument. Multiple threads deref step 2 concurrently ‚Äî both steps should compute exactly once.\n\n(def step-a-count (atom 0))\n\n\n(def step-b-count (atom 0))\n\n\n(defn pipeline-step-a\n  \"First pipeline step: slow transform.\"\n  [x]\n  (swap! step-a-count inc)\n  (Thread/sleep 200)\n  (* x 10))\n\n\n(defn pipeline-step-b\n  \"Second pipeline step: depends on step-a result.\"\n  [data]\n  (swap! step-b-count inc)\n  (Thread/sleep 200)\n  (+ data 1))\n\n\n(do\n  (reset! step-a-count 0)\n  (reset! step-b-count 0)\n  (pocket/cleanup!)\n  (pocket/set-mem-cache-options! {:policy :lru :threshold 10})\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:47.003 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:47.004 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 10}\n18:23:47.004 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 10}\n\n\n\n\n\n:ready\n\nBuild a two-step pipeline, then deref from 5 threads:\n\n(let [cached-a (pocket/cached #'pipeline-step-a 7)\n      cached-b (pocket/cached #'pipeline-step-b cached-a)\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @cached-b)))\n      results (mapv deref futures)]\n  {:results results\n   :step-a-count @step-a-count\n   :step-b-count @step-b-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:47.009 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/pipeline-step-b\n18:23:47.009 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/pipeline-step-a\n\n\n\n\n\n{:results [71 71 71 71 71], :step-a-count 1, :step-b-count 1}\n\n\n\n\nScenario 10: Concurrent Failure\nMultiple threads hit a computation that throws. All threads should see the exception. A subsequent attempt should succeed (fresh delay).\n\n(def concurrent-fail-count (atom 0))\n\n\n(defn fail-once-computation\n  \"Fails when concurrent-fail-count is 0, succeeds after.\"\n  [x]\n  (let [n (swap! concurrent-fail-count inc)]\n    (when (= 1 n)\n      (Thread/sleep 200)\n      (throw (ex-info \"Transient error\" {:x x})))\n    (Thread/sleep 100)\n    (* x x)))\n\n\n(do\n  (reset! concurrent-fail-count 0)\n  (pocket/cleanup!)\n  (pocket/set-mem-cache-options! {:policy :lru :threshold 10})\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:47.421 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:47.422 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 10}\n18:23:47.422 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 10}\n\n\n\n\n\n:ready\n\n5 threads hit the failing computation simultaneously:\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         (try\n                           {:value @(pocket/cached #'fail-once-computation 8)}\n                           (catch Exception e\n                             {:error (.getMessage e)})))))\n      first-results (mapv deref futures)\n      errors (filterv :error first-results)\n      successes (filterv :value first-results)]\n  {:first-round-errors (count errors)\n   :first-round-successes (count successes)\n   :retry @(pocket/cached #'fail-once-computation 8)\n   :total-calls @concurrent-fail-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:47.426 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/fail-once-computation\n18:23:47.629 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/fail-once-computation\n\n\n\n\n\n{:first-round-errors 5,\n :first-round-successes 0,\n :retry 64,\n :total-calls 2}\n\n\n\n\nScenario 11: Eviction Under Contention\nWith a very small cache (threshold=2) and many concurrent requests, memory eviction happens frequently. The in-flight map still prevents duplicate computation for the same key.\n\n(fresh-scenario! {:mem-cache-opts {:policy :lru :threshold 2}})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:47.735 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:47.735 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 2}\n18:23:47.735 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 2}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x7e5efd28 \"18:23:47.735725870\"],\n :mem-cache {:policy :lru, :threshold 2}}\n\nLaunch 4 threads per key, for 3 different keys. Each key should compute exactly once despite eviction pressure.\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 12)\n      futures (doall\n               (for [x [80 81 82]\n                     _ (range 4)]\n                 (future\n                   (.await barrier)\n                   @(pocket/cached #'slow-computation x))))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count\n   :expected-results (vec (for [x [80 81 82]\n                                _ (range 4)]\n                            (* x x)))})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:47.744 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:47.744 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:47.744 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results\n [6400 6400 6400 6400 6561 6561 6561 6561 6724 6724 6724 6724],\n :computation-count 3,\n :expected-results\n [6400 6400 6400 6400 6561 6561 6561 6561 6724 6724 6724 6724]}\n\n\n\n\nScenario 12: Rapid Deref After Invalidation\nInvalidate a cached value and immediately re-request from multiple threads. The re-request should compute exactly once.\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:48.052 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n18:23:48.052 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n18:23:48.053 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x71a33c1f \"18:23:48.053124160\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nCompute and cache a value:\n\n(let [_ @(pocket/cached #'slow-computation 90)\n      count-after-first @computation-count\n      ;; Invalidate\n      _ (pocket/invalidate! #'slow-computation 90)\n      ;; Immediately re-request from 5 concurrent threads\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @(pocket/cached #'slow-computation 90))))\n      results (mapv deref futures)\n      count-after-retry @computation-count]\n  {:results results\n   :count-after-first count-after-first\n   :count-after-retry count-after-retry})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:48.057 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n18:23:48.360 INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-concurrency-test/22/(pocket-book.concurrency_slow-computation 90) existed= true\n18:23:48.362 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [8100 8100 8100 8100 8100],\n :count-after-first 1,\n :count-after-retry 2}",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#design-notes",
    "href": "pocket_book.concurrency.html#design-notes",
    "title": "8¬† Concurrency",
    "section": "Design Notes",
    "text": "Design Notes\n\nWhy Not Use Caffeine?\nCaffeine (via Cloffeine) provides LoadingCache with built-in computeIfAbsent synchronization. This would eliminate the need for our explicit in-flight map.\nWe chose core.cache because:\n\nLighter dependency (pure Clojure data structures)\nPluggable, immutable cache implementations\nFamiliar to the Clojure ecosystem\n\nTrade-off: We need the explicit ConcurrentHashMap synchronization layer.\n\n\nThe computeIfAbsent Contract\nFrom the Java documentation:\n\nThe mapping function should not modify this map during computation.\n\nOur implementation is safe: the mapping function only creates a delay (cheap, instantaneous). The actual computation happens when the delay is dereferenced, outside of computeIfAbsent.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#cleanup",
    "href": "pocket_book.concurrency.html#cleanup",
    "title": "8¬† Concurrency",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:48.671 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n\n\n\n\n\n{:dir \"/tmp/pocket-concurrency-test\", :existed true}\n\n\n(pocket/reset-mem-cache-options!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:48.673 INFO scicloj.pocket - Mem-cache options reset to defaults: {:policy :lru, :threshold 256}\n18:23:48.673 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\nsource: notebooks/pocket_book/concurrency.clj",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html",
    "href": "pocket_book.extending_pocket.html",
    "title": "9¬† Extending Pocket",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#setup",
    "href": "pocket_book.extending_pocket.html#setup",
    "title": "9¬† Extending Pocket",
    "section": "",
    "text": "(def cache-dir \"/tmp/pocket-extending\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:48.800 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-extending\n\n\n\n\n\n\"/tmp/pocket-extending\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:48.801 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending\n\n\n\n\n\n{:dir \"/tmp/pocket-extending\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#the-pidentifiable-protocol",
    "href": "pocket_book.extending_pocket.html#the-pidentifiable-protocol",
    "title": "9¬† Extending Pocket",
    "section": "The PIdentifiable protocol",
    "text": "The PIdentifiable protocol\nPocket derives cache keys from the identity of the function and its arguments. The PIdentifiable protocol controls how each value contributes to the cache key:\n\n(kind/doc #'pocket/-&gt;id)\n\n\n-&gt;id\n[x]\nReturn a cache key representation of a value. Dispatches via the PIdentifiable protocol.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#default-behaviors",
    "href": "pocket_book.extending_pocket.html#default-behaviors",
    "title": "9¬† Extending Pocket",
    "section": "Default behaviors",
    "text": "Default behaviors\nPocket provides default implementations for common types:\nA var‚Äôs identity is its fully-qualified name:\n\n(pocket/-&gt;id #'clojure.core/map)\n\n\nclojure.core/map\n\nA map‚Äôs identity is itself (keys are deep-sorted later for stable cache paths):\n\n(pocket/-&gt;id {:b 2 :a 1})\n\n\n{:b 2, :a 1}\n\nA Cached object‚Äôs identity captures the full computation graph:\n\n(defn add [x y] (+ x y))\n\n\n(pocket/-&gt;id (pocket/cached #'add 1 2))\n\n\n(pocket-book.extending-pocket/add 1 2)\n\nnil is handled:\n\n(pocket/-&gt;id nil)\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#built-in-dataset-support",
    "href": "pocket_book.extending_pocket.html#built-in-dataset-support",
    "title": "9¬† Extending Pocket",
    "section": "Built-in dataset support",
    "text": "Built-in dataset support\nPocket recognizes tech.ml.dataset datasets (the type behind tablecloth) and derives their identity from the actual column data and metadata ‚Äî including annotations like inference targets.\nA dataset‚Äôs identity is a map of column names to {:data [...] :meta {...}}:\n\n(def example-ds\n  (-&gt; (tc/dataset {:x (range 30) :y (range 30)})\n      (ds-mod/set-inference-target :y)))\n\n\n(pocket/-&gt;id example-ds)\n\n\n{:x\n {:data\n  [0\n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29],\n  :meta {:name :x, :datatype :int64, :n-elems 30}},\n :y\n {:data\n  [0\n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29],\n  :meta\n  {:name :y, :datatype :int64, :n-elems 30, :inference-target? true}}}\n\nTwo datasets with identical content produce the same identity, even when the default toString representation would truncate rows:\n\n(def ds-a (tc/dataset {:x (range 30) :y (range 30)}))\n\n\n(def ds-b (tc/dataset {:x (range 30) :y (range 30)}))\n\n\n(= (pocket/-&gt;id ds-a) (pocket/-&gt;id ds-b))\n\n\ntrue\n\nDatasets with different content produce different identities, even when the difference falls in rows that toString would elide:\n\n(def ds-c (tc/dataset {:x (range 30)\n                       :y (concat (range 15) [999] (range 16 30))}))\n\n\n(= (pocket/-&gt;id ds-a) (pocket/-&gt;id ds-c))\n\n\nfalse\n\nThis means caching functions that take datasets as arguments (like ml/train) works correctly regardless of dataset size.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#extending-for-custom-types",
    "href": "pocket_book.extending_pocket.html#extending-for-custom-types",
    "title": "9¬† Extending Pocket",
    "section": "Extending for custom types",
    "text": "Extending for custom types\nIf you have domain-specific types, you can control how they appear in cache keys by extending PIdentifiable. This is useful when the default behavior (which uses the object itself) doesn‚Äôt produce stable or meaningful cache keys.\nFor example, suppose you have a record representing a dataset reference:\n\n(defrecord DatasetRef [source version])\n\nWithout extending the protocol, a DatasetRef would be treated as a plain map ‚Äî its identity would be something like {:source \"census\", :version 3}, which works but isn‚Äôt very readable in cache directory names.\nLet‚Äôs give it a concise, meaningful identity:\n\n(extend-protocol pocket/PIdentifiable\n  DatasetRef\n  (-&gt;id [this]\n    (symbol (str (:source this) \"-v\" (:version this)))))\n\nNow the identity is a clean symbol:\n\n(pocket/-&gt;id (-&gt;DatasetRef \"census\" 3))\n\n\ncensus-v3",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#using-custom-types-in-cached-computations",
    "href": "pocket_book.extending_pocket.html#using-custom-types-in-cached-computations",
    "title": "9¬† Extending Pocket",
    "section": "Using custom types in cached computations",
    "text": "Using custom types in cached computations\n\n(defn analyze-dataset\n  \"Simulate analyzing a dataset.\"\n  [dataset-ref opts]\n  (println \"  Analyzing\" (:source dataset-ref) \"v\" (:version dataset-ref) \"...\")\n  (Thread/sleep 200)\n  {:source (:source dataset-ref)\n   :version (:version dataset-ref)\n   :rows 1000\n   :method (:method opts)})\n\nThe cache key now includes our custom identity:\n\n(def analysis\n  (pocket/cached #'analyze-dataset\n                 (-&gt;DatasetRef \"census\" 3)\n                 {:method :regression}))\n\n\n(pocket/-&gt;id analysis)\n\n\n(pocket-book.extending-pocket/analyze-dataset\n census-v3\n {:method :regression})\n\nFirst deref computes:\n\n(deref analysis)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:48.837 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset\n  Analyzing census v 3 ...\n\n\n\n\n\n{:source \"census\", :version 3, :rows 1000, :method :regression}\n\nSecond deref loads from cache:\n\n(deref analysis)\n\n\n{:source \"census\", :version 3, :rows 1000, :method :regression}\n\nA different version creates a different cache entry:\n\n(deref (pocket/cached #'analyze-dataset\n                      (-&gt;DatasetRef \"census\" 4)\n                      {:method :regression}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.054 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset\n  Analyzing census v 4 ...\n\n\n\n\n\n{:source \"census\", :version 4, :rows 1000, :method :regression}",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#whats-on-disk",
    "href": "pocket_book.extending_pocket.html#whats-on-disk",
    "title": "9¬† Extending Pocket",
    "section": "What‚Äôs on disk?",
    "text": "What‚Äôs on disk?\nThe cache directory names reflect our custom identities:\n\n(pocket/dir-tree)\n\n\npocket-extending\n‚îú‚îÄ‚îÄ 62\n‚îÇ   ‚îî‚îÄ‚îÄ (pocket-book.extending-pocket_analyze-dataset census-v3 {:method :regression})\n‚îÇ       ‚îú‚îÄ‚îÄ meta.edn\n‚îÇ       ‚îî‚îÄ‚îÄ value.nippy\n‚îî‚îÄ‚îÄ f6\n    ‚îî‚îÄ‚îÄ (pocket-book.extending-pocket_analyze-dataset census-v4 {:method :regression})\n        ‚îú‚îÄ‚îÄ meta.edn\n        ‚îî‚îÄ‚îÄ value.nippy",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#guidelines",
    "href": "pocket_book.extending_pocket.html#guidelines",
    "title": "9¬† Extending Pocket",
    "section": "Guidelines",
    "text": "Guidelines\nWhen extending PIdentifiable:\n\nReturn stable values. The identity must be the same across JVM sessions for the same logical input. Avoid including timestamps, random values, or object addresses.\nReturn distinct values. Two logically different inputs must produce different identities. If they don‚Äôt, Pocket will treat them as the same computation and return stale results.\nKeep it readable. The identity becomes part of the cache directory name. Symbols and short strings work well.\nPrefer symbols or keywords over complex nested structures. They produce clean, short directory names.\nRecords and plain maps can collide. A record like (-&gt;DatasetRef \"census\" 3) and a plain map {:source \"census\" :version 3} produce the same default cache key (both are maps with the same keys). If you use records as cache arguments, extend PIdentifiable to give them a distinct identity ‚Äî as shown above.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#custom-nippy-serialization",
    "href": "pocket_book.extending_pocket.html#custom-nippy-serialization",
    "title": "9¬† Extending Pocket",
    "section": "Custom Nippy serialization",
    "text": "Custom Nippy serialization\nPocket uses Nippy for fast binary serialization. Most Clojure data structures and many Java objects serialize automatically. However, if you cache values containing custom types, you may need to extend Nippy.\nCommon types that work out of the box:\n\nAll Clojure collections (vectors, maps, sets, lists)\nPrimitives, strings, keywords, symbols\nJava Date, UUID, BigDecimal, BigInteger\nRecords and deftypes (if all fields are serializable)\nTribuo ML models\ntech.ml.dataset datasets\n\nTypes that require extension:\n\nObjects with unserializable fields (e.g., open file handles, database connections, thread pools)\nCustom Java classes from external libraries (unless they implement Serializable)\n\nTo extend Nippy for a custom type, use nippy/extend-freeze and nippy/extend-thaw:\n(require '[taoensso.nippy :as nippy])\n\n(defrecord MyModel [weights bias])\n\n(nippy/extend-freeze MyModel :my-model\n  [x data-output]\n  (nippy/freeze-to-out! data-output (:weights x))\n  (nippy/freeze-to-out! data-output (:bias x)))\n\n(nippy/extend-thaw :my-model\n  [data-input]\n  (-&gt;MyModel (nippy/thaw-from-in! data-input)\n             (nippy/thaw-from-in! data-input)))\nSee the Nippy documentation for more details.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#cleanup",
    "href": "pocket_book.extending_pocket.html#cleanup",
    "title": "9¬† Extending Pocket",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.260 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending\n\n\n\n\n\n{:dir \"/tmp/pocket-extending\", :existed true}\n\n\nsource: notebooks/pocket_book/extending_pocket.clj",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html",
    "href": "pocket_book.ml_workflows.html",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nThis chapter demonstrates Pocket in a realistic machine learning scenario. If you‚Äôre new to ML, don‚Äôt worry ‚Äî we‚Äôll explain the concepts as we go. The focus is on how caching helps when you‚Äôre exploring many combinations of data, features, and models.\nThe problem: We want to predict a numeric value (like house prices or temperature) from input data. This is called regression. We‚Äôll generate synthetic data, try different ways of preparing it, and compare two learning algorithms.\nWhy caching matters: Training models can be slow. When you‚Äôre experimenting ‚Äî tweaking parameters, trying new features ‚Äî you don‚Äôt want to recompute everything each time. Pocket caches each step independently, so only the parts you changed get recomputed.\nWhat we‚Äôll cover:\nNote: This notebook uses tablecloth for data manipulation, metamorph.ml and tribuo for ML, and Plotly.js for visualization. These are not Pocket dependencies ‚Äî they illustrate a realistic ML workflow. All output is shown inline; to reproduce it, add noj to your project dependencies.\nWhy synthetic data? Working with synthetic data is a standard practice in machine learning. Because we define the true relationship (\\(y = \\sin(x) \\cdot x\\)), we can measure exactly how well each model recovers it ‚Äî something impossible with real-world data where the ground truth is unknown. Synthetic experiments let us isolate one variable at a time: does feature engineering help? How does noise affect each algorithm? These controlled comparisons build intuition that transfers to real problems. In our case, we‚Äôll see that a linear model is helpless against a nonlinear target unless we give it the right features, while a decision tree handles the shape on its own but pays a different price when noise increases.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#setup",
    "href": "pocket_book.ml_workflows.html#setup",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "",
    "text": "(ns pocket-book.ml-workflows\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Data processing:\n   [tablecloth.api :as tc]\n   [tablecloth.column.api :as tcc]\n   [tech.v3.dataset :as ds]\n   [tech.v3.dataset.modelling :as ds-mod]\n   ;; Machine learning:\n   [scicloj.metamorph.ml :as ml]\n   [scicloj.metamorph.ml.loss :as loss]\n   [scicloj.ml.tribuo]))\n\n\n(def cache-dir \"/tmp/pocket-regression\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.327 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-regression\n\n\n\n\n\n\"/tmp/pocket-regression\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.328 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#pipeline-functions",
    "href": "pocket_book.ml_workflows.html#pipeline-functions",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Pipeline functions",
    "text": "Pipeline functions\nThese are the steps of our ML pipeline ‚Äî plain Clojure functions that know nothing about caching. Pocket will wrap them later.\nData generation: make-regression-data creates a synthetic dataset from a ground-truth function. We control the sample size, noise level, and random seed ‚Äî all of which become part of the cache key, so changing any parameter triggers recomputation.\n\n(defn make-regression-data\n  \"Generate a synthetic regression dataset.\n  `f` is a function from x to y (the ground truth).\n  Optional `outlier-fraction` (0‚Äì1) and `outlier-scale` inject\n  corrupted x values to simulate sensor glitches.\"\n  [{:keys [f n noise-sd seed outlier-fraction outlier-scale]\n    :or {outlier-fraction 0 outlier-scale 10}}]\n  (let [rng (java.util.Random. (long seed))\n        xs (vec (repeatedly n #(* 10.0 (.nextDouble rng))))\n        xs-final (if (pos? outlier-fraction)\n                   (let [out-rng (java.util.Random. (+ (long seed) 7919))]\n                     (mapv (fn [x]\n                             (if (&lt; (.nextDouble out-rng) outlier-fraction)\n                               (+ x (* (double outlier-scale) (.nextGaussian out-rng)))\n                               x))\n                           xs))\n                   xs)\n        ys (mapv (fn [x] (+ (double (f x))\n                            (* (double noise-sd) (.nextGaussian rng))))\n                 xs)]\n    (-&gt; (tc/dataset {:x xs-final :y ys})\n        (ds-mod/set-inference-target :y))))\n\nSplitting: split-dataset divides data into training and test sets. This is a cached step so the full provenance chain ‚Äî from parameters through data generation to the split ‚Äî is captured in the DAG.\n\n(defn split-dataset\n  \"Split a dataset into train/test using holdout.\"\n  [ds {:keys [seed]}]\n  (first (tc/split-&gt;seq ds :holdout {:seed seed})))\n\nFeature engineering: prepare-features transforms raw data by adding derived columns. The choice of feature set is a key hyperparameter ‚Äî a linear model with only :raw features can‚Äôt learn nonlinear patterns, but :trig or :poly+trig features give it the building blocks it needs.\n\n(defn prepare-features\n  \"Add derived columns to a dataset according to `feature-set`.\n  Supported feature sets:\n\n  - `:raw`       ‚Äî no extra columns\n  - `:quadratic` ‚Äî add x¬≤\n  - `:trig`      ‚Äî add sin(x) and cos(x)\n  - `:poly+trig` ‚Äî add x¬≤, sin(x), and cos(x)\"\n  [ds feature-set]\n  (let [x (:x ds)]\n    (-&gt; (case feature-set\n          :raw ds\n          :quadratic (tc/add-columns ds {:x2 (tcc/sq x)})\n          :trig (tc/add-columns ds {:sin-x (tcc/sin x)\n                                    :cos-x (tcc/cos x)})\n          :poly+trig (tc/add-columns ds {:x2 (tcc/sq x)\n                                         :sin-x (tcc/sin x)\n                                         :cos-x (tcc/cos x)}))\n        (ds-mod/set-inference-target :y))))\n\nTraining and evaluation: train-model fits a model to prepared data, and predict-and-rmse measures how well it generalizes to unseen test data. These are thin wrappers around metamorph.ml ‚Äî the caching value comes from avoiding redundant retraining when only downstream parameters change.\n\n(defn train-model\n  \"Train a model on a dataset.\"\n  [train-ds model-spec]\n  (ml/train train-ds model-spec))\n\n\n(defn predict-and-rmse\n  \"Predict on test data and return RMSE.\"\n  [test-ds model]\n  (let [pred (ml/predict test-ds model)]\n    (loss/rmse (:y test-ds) (:y pred))))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#ground-truth",
    "href": "pocket_book.ml_workflows.html#ground-truth",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Ground truth",
    "text": "Ground truth\nWe need a function to predict. In real problems you don‚Äôt know the true relationship ‚Äî that‚Äôs what you‚Äôre trying to learn. Here we define it explicitly so we can measure how well our models do.\nOur target is \\(y = \\sin(x) \\cdot x\\) ‚Äî a wavy curve that grows with \\(x\\). A straight line can‚Äôt fit this shape, so a simple linear model will struggle unless we help it with better features.\n\n(defn nonlinear-fn\n  \"y = sin(x) ¬∑ x\"\n  [x]\n  (* (Math/sin x) x))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#model-specifications",
    "href": "pocket_book.ml_workflows.html#model-specifications",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Model specifications",
    "text": "Model specifications\nWe‚Äôll compare two fundamentally different algorithms:\nLinear model (gradient descent): Finds the best straight-line (or hyperplane) relationship between inputs and output. Simple and fast, but can only learn linear patterns. Needs good features.\nDecision tree (CART): Learns by splitting data into regions based on thresholds (‚Äúif x &gt; 5, go left‚Äù). Can capture complex patterns automatically, but may overfit noisy data.\nThese algorithms respond differently to feature engineering ‚Äî that contrast is the heart of Part 1.\n\n(def linear-sgd-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"squared\"\n                        :type \"org.tribuo.regression.sgd.objectives.SquaredLoss\"}\n                       {:name \"trainer\"\n                        :type \"org.tribuo.regression.sgd.linear.LinearSGDTrainer\"\n                        :properties {:objective \"squared\"\n                                     :epochs \"50\"\n                                     :loggingInterval \"10000\"}}]\n   :tribuo-trainer-name \"trainer\"})\n\n\n(def cart-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"cart\"\n                        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                        :properties {:maxDepth \"8\"}}]\n   :tribuo-trainer-name \"cart\"})",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-1-feature-engineering-matters-for-some-models",
    "href": "pocket_book.ml_workflows.html#part-1-feature-engineering-matters-for-some-models",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 1 ‚Äî Feature engineering matters (for some models)",
    "text": "Part 1 ‚Äî Feature engineering matters (for some models)\nFeature engineering means transforming raw inputs into forms that help models learn. For example, if the true relationship involves \\(x^2\\), adding a squared column gives the model that pattern directly instead of forcing it to discover it.\nWe‚Äôll test four feature sets:\n\n:raw ‚Äî just the original \\(x\\) value\n:quadratic ‚Äî add \\(x^2\\)\n:trig ‚Äî add \\(\\sin(x)\\) and \\(\\cos(x)\\)\n:poly+trig ‚Äî add all three\n\nCrossed with two model types, that‚Äôs eight combinations. Every step is cached, so re-running is instant.\n\nGenerate data\n\n(def data-c\n  (pocket/cached #'make-regression-data\n                 {:f #'nonlinear-fn :n 500 :noise-sd 0.5 :seed 42}))\n\n\n(tc/head (deref data-c))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.336 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n\n\n\n\n\n_unnamed [5 2]:\n\n\n\n:x\n:y\n\n\n\n\n7.27563680\n6.74555252\n\n\n6.83223472\n4.07224915\n\n\n3.08719455\n0.22904859\n\n\n2.77078490\n0.47163659\n\n\n6.65548952\n2.81816258\n\n\n\n\n\n\nSplit into train and test\n\n(def split-c\n  (pocket/cached #'split-dataset data-c {:seed 42}))\n\nExtract train and test sets ‚Äî using keywords as cached functions. The DAG now traces from numerical parameters through data generation to the split to each subset.\n\n(def train-c (pocket/cached :train split-c))\n\n\n(def test-c (pocket/cached :test split-c))\n\n\n\nFeature sets\n\n(def feature-sets [:raw :quadratic :trig :poly+trig])\n\n\n\nPrepare features (cached)\nEach feature set applied to each split half is a separate cached computation ‚Äî eight in total.\n\n(def prepared\n  (into {}\n        (for [fs feature-sets\n              [role ds-c] [[:train train-c] [:test test-c]]]\n          [[fs role]\n           (pocket/cached #'prepare-features ds-c fs)])))\n\n\n\nTrain models (cached)\nTwo models per feature set ‚Äî eight cached training runs.\n\n(def models\n  (into {}\n        (for [fs feature-sets\n              [model-name spec] [[:sgd linear-sgd-spec]\n                                 [:cart cart-spec]]]\n          [[fs model-name]\n           (pocket/cached #'train-model\n                          (prepared [fs :train])\n                          spec)])))\n\n\n\nResults\n\n(def feature-results\n  (vec (for [fs feature-sets\n             [model-name _] [[:sgd linear-sgd-spec]\n                             [:cart cart-spec]]]\n         {:feature-set fs\n          :model (name model-name)\n          :rmse (predict-and-rmse @(prepared [fs :test])\n                                  @(models [fs model-name]))})))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.352 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.352 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n18:23:49.352 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n18:23:49.357 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.357 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.357 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 7.061050130878382\n18:23:49.370 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.376 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.377 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.377 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 7.746488252108407\n18:23:49.387 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.396 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.397 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.397 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 0.9717267353378612\n18:23:49.407 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.417 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.418 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.418 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.5031022528715852\n18:23:49.429 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n\n\n\n\n\nfeature-results\n\n\n[{:feature-set :raw, :model \"sgd\", :rmse 3.6917759873191685}\n {:feature-set :raw, :model \"cart\", :rmse 0.6334615055076024}\n {:feature-set :quadratic, :model \"sgd\", :rmse 3.576999082640806}\n {:feature-set :quadratic, :model \"cart\", :rmse 0.6334615055076024}\n {:feature-set :trig, :model \"sgd\", :rmse 1.4577701415666355}\n {:feature-set :trig, :model \"cart\", :rmse 0.6805569759436894}\n {:feature-set :poly+trig, :model \"sgd\", :rmse 1.3410184469297421}\n {:feature-set :poly+trig, :model \"cart\", :rmse 0.6805569759436894}]\n\nWhat the results show:\nThe linear model (SGD) has high error with raw features ‚Äî it‚Äôs trying to draw a straight line through a wavy curve. But give it \\(\\sin(x)\\) and \\(\\cos(x)\\) as features, and it can combine them to approximate the true shape. Feature engineering saved the day.\nThe decision tree (CART) doesn‚Äôt care. It discovers the wavy pattern by splitting the data into regions. Extra features don‚Äôt help because the tree already found the structure.\nTakeaway: Some models need feature engineering; others don‚Äôt. Caching lets you explore both without waiting.\n\n\nPredictions plot\nBest linear model (poly+trig) vs best tree (raw) vs actual values.\n\n(let [test-ds @(prepared [:raw :test])\n      sgd-pred (:y (ml/predict @(prepared [:poly+trig :test])\n                               @(models [:poly+trig :sgd])))\n      cart-pred (:y (ml/predict test-ds\n                                @(models [:raw :cart])))\n      xs (vec (:x test-ds))\n      actuals (vec (:y test-ds))\n      sgd-vals (vec sgd-pred)\n      cart-vals (vec cart-pred)]\n  (kind/plotly\n   {:data [{:x xs :y actuals :mode \"markers\" :name \"actual\"\n            :marker {:opacity 0.3 :color \"gray\"}}\n           {:x xs :y sgd-vals :mode \"markers\" :name \"Linear SGD (poly+trig)\"\n            :marker {:opacity 0.5 :color \"steelblue\"}}\n           {:x xs :y cart-vals :mode \"markers\" :name \"CART (raw)\"\n            :marker {:opacity 0.5 :color \"tomato\"}}]\n    :layout {:xaxis {:title \"x\"} :yaxis {:title \"y\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-2-how-models-handle-noisy-data",
    "href": "pocket_book.ml_workflows.html#part-2-how-models-handle-noisy-data",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 2 ‚Äî How models handle noisy data",
    "text": "Part 2 ‚Äî How models handle noisy data\nReal data is messy. Measurements have errors, inputs are approximate. Noise is the random variation that obscures the true pattern.\nHow do our models behave as noise increases? We‚Äôll test five levels, from nearly clean (0.1) to very noisy (5.0).\nNotice: the noise=0.5 dataset reuses the cache from Part 1 ‚Äî Pocket recognizes the same function and arguments.\n\n(def noise-levels [0.1 0.5 1.0 2.0 5.0])\n\n\n(def noise-results\n  (vec\n   (for [noise-sd noise-levels]\n     (let [data-c (pocket/cached #'make-regression-data\n                                 {:f #'nonlinear-fn :n 500 :noise-sd noise-sd :seed 42})\n           split-c (pocket/cached #'split-dataset data-c {:seed 42})\n           train-c (pocket/cached :train split-c)\n           test-c (pocket/cached :test split-c)\n           cart-train (pocket/cached #'prepare-features train-c :raw)\n           cart-test (pocket/cached #'prepare-features test-c :raw)\n           sgd-train (pocket/cached #'prepare-features train-c :poly+trig)\n           sgd-test (pocket/cached #'prepare-features test-c :poly+trig)\n           cart-model (pocket/cached #'train-model cart-train cart-spec)\n           sgd-model (pocket/cached #'train-model sgd-train linear-sgd-spec)]\n       {:noise-sd noise-sd\n        :cart-rmse (predict-and-rmse @cart-test @cart-model)\n        :sgd-rmse (predict-and-rmse @sgd-test @sgd-model)}))))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.452 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.452 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n18:23:49.452 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n18:23:49.452 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n18:23:49.456 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.456 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.456 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n18:23:49.464 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.465 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.465 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.106624,min=-5.332393,mean=0.805881,variance=15.304966})\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.4235088958624642\n18:23:49.475 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.475 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n18:23:49.476 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n18:23:49.476 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n18:23:49.479 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.479 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.479 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n18:23:49.487 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.488 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.488 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=9.816940,min=-6.625413,mean=0.883112,variance=15.979208})\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.8153008504655874\n18:23:49.502 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.502 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n18:23:49.502 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n18:23:49.502 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n18:23:49.507 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.507 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.507 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n18:23:49.517 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.519 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.519 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=11.717291,min=-8.958664,mean=0.968924,variance=18.285525})\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 3.123027977933463\n18:23:49.533 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.533 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n18:23:49.533 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n18:23:49.533 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n18:23:49.538 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.538 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.538 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n18:23:49.546 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n18:23:49.548 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.548 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=17.418345,min=-15.958416,mean=1.226360,variance=35.039175})\nFeb 08, 2026 6:23:49 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 12.1030268449752\n\n\n\n\n\nnoise-results\n\n\n[{:noise-sd 0.1,\n  :cart-rmse 0.18813079748027944,\n  :sgd-rmse 1.2744431229599325}\n {:noise-sd 0.5,\n  :cart-rmse 0.6334615055076024,\n  :sgd-rmse 1.3410184469297421}\n {:noise-sd 1.0,\n  :cart-rmse 1.2499664669902657,\n  :sgd-rmse 1.582298583473656}\n {:noise-sd 2.0,\n  :cart-rmse 2.453719422103725,\n  :sgd-rmse 2.352662287937308}\n {:noise-sd 5.0,\n  :cart-rmse 5.960858808406107,\n  :sgd-rmse 5.262029923696976}]\n\nWhat the results show:\nAt low noise, the tree wins ‚Äî it captures fine details the linear model smooths over. But as noise increases, the tree starts memorizing random wiggles (overfitting), and its error explodes.\nThe linear model degrades more gracefully. Its rigid structure (a weighted sum of features) acts as a built-in regularizer ‚Äî it can‚Äôt chase noise even if it wanted to.\nTakeaway: Flexible models (trees) excel with clean data but suffer with noise. Simple models (linear) are more robust.\n\nRMSE vs.¬†noise\n\n(let [noise-sds (vec (map :noise-sd noise-results))\n      cart-rmses (vec (map :cart-rmse noise-results))\n      sgd-rmses (vec (map :sgd-rmse noise-results))]\n  (kind/plotly\n   {:data [{:x noise-sds :y cart-rmses :mode \"lines+markers\" :name \"CART\"}\n           {:x noise-sds :y sgd-rmses :mode \"lines+markers\" :name \"Linear SGD\"}]\n    :layout {:xaxis {:title \"noise-sd\"} :yaxis {:title \"rmse\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-3-what-got-cached",
    "href": "pocket_book.ml_workflows.html#part-3-what-got-cached",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 3 ‚Äî What got cached?",
    "text": "Part 3 ‚Äî What got cached?\nWe‚Äôve run many combinations of data, features, and models. Each pocket/cached call created an independent cache entry. Let‚Äôs see what we accumulated:\n\n(:total-entries (pocket/cache-stats))\n\n\n60\n\n\n(:entries-per-fn (pocket/cache-stats))\n\n\n{\"pocket-book.ml-workflows/prepare-features\" 24,\n \"pocket-book.ml-workflows/make-regression-data\" 5,\n \"pocket-book.ml-workflows/train-model\" 16,\n \":test\" 5,\n \":train\" 5,\n \"pocket-book.ml-workflows/split-dataset\" 5}\n\nWith this small synthetic data, each step runs in milliseconds. But the structure is what matters. In real workflows ‚Äî large datasets, deep neural networks, hyperparameter searches ‚Äî the same cache graph saves hours or days.\nHere‚Äôs what happens when you change something:\n\n\n\n\n\n\n\nChange\nWhat recomputes\n\n\n\n\nEdit a feature set\nThat feature prep + its models\n\n\nChange a model hyperparameter\nOnly that model\n\n\nChange the noise level\nThat data + its features + its models\n\n\nRe-run the whole notebook\nNothing ‚Äî all cached",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#cleanup",
    "href": "pocket_book.ml_workflows.html#cleanup",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.583 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-4-sharing-computations-across-branches",
    "href": "pocket_book.ml_workflows.html#part-4-sharing-computations-across-branches",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 4 ‚Äî Sharing computations across branches",
    "text": "Part 4 ‚Äî Sharing computations across branches\nReal sensors glitch. A positioning system occasionally records a wildly wrong x value ‚Äî the physics (y) is unaffected, but the recorded input is corrupted. When we build polynomial features like x¬≤, these outlier x values get amplified: an errant x=50 gives x¬≤=2500 instead of the expected ~25 from a normal x‚âà5.\nThe fix is feature outlier clipping: compute what range of x is ‚Äúnormal‚Äù from training data, then clip both train and test inputs to those bounds ‚Äî before feature engineering.\nThe clipping threshold must come from training data alone. Using test data would leak future information.\nThis creates a diamond dependency ‚Äî one computation (the threshold) feeds into multiple downstream steps:\n make-regression-data (with x outliers)\n         |\n    split-dataset\n         |\n    +----+----+\n    v         v\n (:train)  (:test)\n    |         |\n    v         |\nfit-threshold |\n    |         |\n    +----+----+\n    v         v\nclip(train) clip(test)\n    |         |\n    v         v\nfeatures   features\n    |         |\n    v         |\ntrain-model   |\n    |         |\n    +----+----+\n    v\n  evaluate\nPocket handles this naturally. The threshold node is computed once and feeds both clipping steps. When you change the training data, the threshold recomputes, and both branches update.\n\nPipeline functions\nThese are plain functions. Each does one thing: fit a threshold, clip outliers, or evaluate. Pocket will wire them together.\n\n(defn fit-outlier-threshold\n  \"Compute IQR-based clipping bounds for :x from training data.\n  Returns {:lower &lt;bound&gt; :upper &lt;bound&gt;}.\"\n  [train-ds]\n  (println \"  Fitting outlier threshold from training data...\")\n  (let [xs (sort (vec (:x train-ds)))\n        n (count xs)\n        q1 (nth xs (int (* 0.25 n)))\n        q3 (nth xs (int (* 0.75 n)))\n        iqr (- q3 q1)]\n    {:lower (- q1 (* 1.5 iqr))\n     :upper (+ q3 (* 1.5 iqr))}))\n\n\n(defn clip-outliers\n  \"Clip :x values using pre-computed threshold bounds.\"\n  [ds threshold]\n  (println \"  Clipping outliers with bounds:\" (select-keys threshold [:lower :upper]))\n  (let [{:keys [lower upper]} threshold]\n    (tc/add-column ds :x (-&gt; (:x ds) (tcc/max lower) (tcc/min upper)))))\n\n\n(defn evaluate-model\n  \"Evaluate a model on test data.\"\n  [test-ds model]\n  (println \"  Evaluating model...\")\n  (let [pred (ml/predict test-ds model)]\n    {:rmse (loss/rmse (:y test-ds) (:y pred))}))\n\n\n\nBuild the DAG with mixed storage policies\nNot every step needs disk persistence. We use caching-fn with per-function storage policies:\n\n:mem for cheap shared computations (threshold, clipping, feature engineering) ‚Äî no disk I/O, but in-memory dedup ensures each runs only once persists across JVM sessions\n:none for trivial steps (evaluation) ‚Äî just tracks identity in the DAG without any shared caching\n\n\n(def c-fit-threshold\n  (pocket/caching-fn #'fit-outlier-threshold {:storage :mem}))\n\n\n(def c-clip\n  (pocket/caching-fn #'clip-outliers {:storage :mem}))\n\n\n(def c-prepare\n  (pocket/caching-fn #'prepare-features {:storage :mem}))\n\n\n(def c-train\n  (pocket/caching-fn #'train-model))\n\n\n(def c-evaluate\n  (pocket/caching-fn #'evaluate-model {:storage :none}))\n\nGenerate data with outliers for this demo ‚Äî 10% of the x values are corrupted by large random spikes, simulating sensor glitches. The y values (physics) are computed from the clean x, then noise is added normally ‚Äî so only the input is corrupted.\n\n(def dag-data-c\n  (pocket/cached #'make-regression-data\n                 {:f #'nonlinear-fn :n 200 :noise-sd 0.3 :seed 99\n                  :outlier-fraction 0.1 :outlier-scale 15}))\n\n\n(def dag-split-c\n  (pocket/cached #'split-dataset dag-data-c {:seed 99}))\n\n\n(def dag-train-c (pocket/cached :train dag-split-c))\n\n\n(def dag-test-c (pocket/cached :test dag-split-c))\n\nNow wire the pipeline. The threshold is fitted once from training data (in memory) and feeds both clipping steps ‚Äî a diamond dependency handled naturally.\n\n(def threshold-c\n  (c-fit-threshold dag-train-c))\n\n\n(def train-clipped-c\n  (c-clip dag-train-c threshold-c))\n\n\n(def test-clipped-c\n  (c-clip dag-test-c threshold-c))\n\n\n(def train-prepped-c\n  (c-prepare train-clipped-c :poly+trig))\n\n\n(def test-prepped-c\n  (c-prepare test-clipped-c :poly+trig))\n\n\n(def model-c\n  (c-train train-prepped-c cart-spec))\n\n\n(def metrics-c\n  (c-evaluate test-prepped-c model-c))\n\n\n\nVisualize the DAG\nPocket provides three functions for DAG introspection, each suited to different use cases.\norigin-story returns a nested tree structure. Each cached node has :fn, :args, and :id. The :id is unique; when the same Cached instance appears multiple times (diamond pattern), subsequent occurrences become {:ref &lt;id&gt;} pointers. This avoids infinite recursion and makes the diamond explicit:\n\n(pocket/origin-story metrics-c)\n\n\n{:fn #'pocket-book.ml-workflows/evaluate-model,\n :args\n [{:fn #'pocket-book.ml-workflows/prepare-features,\n   :args\n   [{:fn #'pocket-book.ml-workflows/clip-outliers,\n     :args\n     [{:fn :test,\n       :args\n       [{:fn #'pocket-book.ml-workflows/split-dataset,\n         :args\n         [{:fn #'pocket-book.ml-workflows/make-regression-data,\n           :args\n           [{:value\n             {:f #'pocket-book.ml-workflows/nonlinear-fn,\n              :n 200,\n              :noise-sd 0.3,\n              :seed 99,\n              :outlier-fraction 0.1,\n              :outlier-scale 15}}],\n           :id \"c6\"}\n          {:value {:seed 99}}],\n         :id \"c5\"}],\n       :id \"c4\"}\n      {:fn #'pocket-book.ml-workflows/fit-outlier-threshold,\n       :args [{:fn :train, :args [{:ref \"c5\"}], :id \"c8\"}],\n       :id \"c7\"}],\n     :id \"c3\"}\n    {:value :poly+trig}],\n   :id \"c2\"}\n  {:fn #'pocket-book.ml-workflows/train-model,\n   :args\n   [{:fn #'pocket-book.ml-workflows/prepare-features,\n     :args\n     [{:fn #'pocket-book.ml-workflows/clip-outliers,\n       :args [{:ref \"c8\"} {:ref \"c7\"}],\n       :id \"c11\"}\n      {:value :poly+trig}],\n     :id \"c10\"}\n    {:value\n     {:model-type :scicloj.ml.tribuo/regression,\n      :tribuo-components\n      [{:name \"cart\",\n        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\",\n        :properties {:maxDepth \"8\"}}],\n      :tribuo-trainer-name \"cart\"}}],\n   :id \"c9\"}],\n :id \"c1\"}\n\nNotice how the threshold node appears as a :ref in one branch ‚Äî it‚Äôs the same computation feeding both train and test clipping.\norigin-story-graph normalizes the tree into a flat {:nodes ... :edges ...} structure suitable for graph algorithms:\n\n(pocket/origin-story-graph metrics-c)\n\n\n{:nodes\n {\"c9\" {:fn #'pocket-book.ml-workflows/fit-outlier-threshold},\n  \"c10\" {:fn :train},\n  \"c13\" {:fn #'pocket-book.ml-workflows/prepare-features},\n  \"c14\" {:fn #'pocket-book.ml-workflows/clip-outliers},\n  \"v15\" {:value :poly+trig},\n  \"v7\"\n  {:value\n   {:f #'pocket-book.ml-workflows/nonlinear-fn,\n    :n 200,\n    :noise-sd 0.3,\n    :seed 99,\n    :outlier-fraction 0.1,\n    :outlier-scale 15}},\n  \"v8\" {:value {:seed 99}},\n  \"c2\" {:fn #'pocket-book.ml-workflows/prepare-features},\n  \"v11\" {:value :poly+trig},\n  \"c12\" {:fn #'pocket-book.ml-workflows/train-model},\n  \"v16\"\n  {:value\n   {:model-type :scicloj.ml.tribuo/regression,\n    :tribuo-components\n    [{:name \"cart\",\n      :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\",\n      :properties {:maxDepth \"8\"}}],\n    :tribuo-trainer-name \"cart\"}},\n  \"c3\" {:fn #'pocket-book.ml-workflows/clip-outliers},\n  \"c4\" {:fn :test},\n  \"c5\" {:fn #'pocket-book.ml-workflows/split-dataset},\n  \"c6\" {:fn #'pocket-book.ml-workflows/make-regression-data},\n  \"c1\" {:fn #'pocket-book.ml-workflows/evaluate-model}},\n :edges\n [[\"c1\" \"c2\"]\n  [\"c2\" \"c3\"]\n  [\"c3\" \"c4\"]\n  [\"c4\" \"c5\"]\n  [\"c5\" \"c6\"]\n  [\"c6\" \"v7\"]\n  [\"c5\" \"v8\"]\n  [\"c3\" \"c9\"]\n  [\"c9\" \"c10\"]\n  [\"c10\" \"c5\"]\n  [\"c2\" \"v11\"]\n  [\"c1\" \"c12\"]\n  [\"c12\" \"c13\"]\n  [\"c13\" \"c14\"]\n  [\"c14\" \"c10\"]\n  [\"c14\" \"c9\"]\n  [\"c13\" \"v15\"]\n  [\"c12\" \"v16\"]]}\n\norigin-story-mermaid renders the DAG as a Mermaid flowchart, with arrows showing data flow direction (from inputs toward the final result). The diamond dependency is clearly visible ‚Äî the threshold feeds both clipping steps:\n\n(pocket/origin-story-mermaid metrics-c)\n\nflowchart TD\n  n0[\"evaluate-model\"]\n  n1[\"prepare-features\"]\n  n2[\"clip-outliers\"]\n  n3[\":test\"]\n  n4[\"split-dataset\"]\n  n5[\"make-regression-data\"]\n  n6[/\"{:f #'pocket-book.ml-workflows/nonlinear-fn,:n 200,:noise-sd 0.3,:seed 99,:outlier-fraction 0.1,:outlier-scale 15}\"/]\n  n6 --&gt; n5\n  n5 --&gt; n4\n  n7[/\"{:seed 99}\"/]\n  n7 --&gt; n4\n  n4 --&gt; n3\n  n3 --&gt; n2\n  n8[\"fit-outlier-threshold\"]\n  n9[\":train\"]\n  n4 --&gt; n9\n  n9 --&gt; n8\n  n8 --&gt; n2\n  n2 --&gt; n1\n  n10[/\":poly+trig\"/]\n  n10 --&gt; n1\n  n1 --&gt; n0\n  n11[\"train-model\"]\n  n12[\"prepare-features\"]\n  n13[\"clip-outliers\"]\n  n9 --&gt; n13\n  n8 --&gt; n13\n  n13 --&gt; n12\n  n14[/\":poly+trig\"/]\n  n14 --&gt; n12\n  n12 --&gt; n11\n  n15[/\"{:model-type :scicloj.ml.tribuo/regression,:tribuo-components [{:name 'cart',:type 'org.tribuo.regression.rtree.CARTRegressionTrainer',:properties {:maxDepth '8'}}],:tribuo-trainer-name 'cart'}\"/]\n  n15 --&gt; n11\n  n11 --&gt; n0\n\n\nExecute the pipeline\n\n(deref metrics-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.592 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n18:23:49.592 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/clip-outliers\n18:23:49.592 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n18:23:49.592 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n18:23:49.592 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n18:23:49.596 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/fit-outlier-threshold\n18:23:49.596 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n  Fitting outlier threshold from training data...\n  Clipping outliers with bounds: {:lower -5.499694170624462, :upper 15.994051959902624}\n18:23:49.598 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.598 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n18:23:49.598 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/clip-outliers\n  Clipping outliers with bounds: {:lower -5.499694170624462, :upper 15.994051959902624}\n  Evaluating model...\n\n\n\n\n\n{:rmse 1.601302555211606}\n\nHow much did clipping help? Let‚Äôs compare three scenarios using the same cached building blocks.\nThe no-clip and clean-baseline pipelines are local ‚Äî they exist only for this comparison. Each still builds a cached DAG that shares steps with the clipped pipeline above.\n\n(let [;; No-clip: skip clipping, go straight from raw splits to features\n      noclip-train-c  (c-prepare dag-train-c :poly+trig)\n      noclip-test-c   (c-prepare dag-test-c :poly+trig)\n      noclip-model-c  (c-train noclip-train-c cart-spec)\n      noclip-metrics  @(c-evaluate noclip-test-c noclip-model-c)\n      ;; Clean baseline: same structure, data without outliers\n      clean-data-c    (pocket/cached #'make-regression-data\n                                     {:f #'nonlinear-fn :n 200 :noise-sd 0.3 :seed 99})\n      clean-split-c   (pocket/cached #'split-dataset clean-data-c {:seed 99})\n      clean-train-c   (c-prepare (pocket/cached :train clean-split-c) :poly+trig)\n      clean-test-c    (c-prepare (pocket/cached :test clean-split-c) :poly+trig)\n      clean-model-c   (c-train clean-train-c cart-spec)\n      clean-metrics   @(c-evaluate clean-test-c clean-model-c)]\n  {:clean            clean-metrics\n   :outliers-no-clip noclip-metrics\n   :outliers-clipped @metrics-c})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.614 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n18:23:49.615 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.615 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n  Evaluating model...\n18:23:49.625 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n18:23:49.625 INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n18:23:49.625 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n18:23:49.625 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n18:23:49.630 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n18:23:49.630 INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n18:23:49.630 INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n  Evaluating model...\n\n\n\n\n\n{:clean {:rmse 0.4263098047865239},\n :outliers-no-clip {:rmse 2.552495499444297},\n :outliers-clipped {:rmse 1.601302555211606}}\n\nClipping x before building polynomial features makes a visible difference ‚Äî the amplification through x¬≤ is tamed.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-5-comparing-many-experiments-at-once",
    "href": "pocket_book.ml_workflows.html#part-5-comparing-many-experiments-at-once",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Part 5 ‚Äî Comparing many experiments at once",
    "text": "Part 5 ‚Äî Comparing many experiments at once\nHyperparameters are settings you choose before training: tree depth, learning rate, which features to use. Finding good values usually means trying many combinations ‚Äî a hyperparameter sweep.\nPocket‚Äôs compare-experiments helps here. You pass a collection of cached experiments, and it extracts the parameters that vary across them (ignoring ones that are constant).\n\n(defn run-pipeline\n  \"Run a complete pipeline with given hyperparameters.\"\n  [{:keys [noise-sd feature-set max-depth]}]\n  (let [ds (make-regression-data {:f nonlinear-fn :n 200 :noise-sd noise-sd :seed 42})\n        sp (split-dataset ds {:seed 42})\n        train-prep (prepare-features (:train sp) feature-set)\n        test-prep (prepare-features (:test sp) feature-set)\n        spec {:model-type :scicloj.ml.tribuo/regression\n              :tribuo-components [{:name \"cart\"\n                                   :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                                   :properties {:maxDepth (str max-depth)}}]\n              :tribuo-trainer-name \"cart\"}\n        model (ml/train train-prep spec)\n        pred (ml/predict test-prep model)]\n    {:rmse (loss/rmse (:y test-prep) (:y pred))}))\n\nRun experiments across a grid of hyperparameters:\n\n(def experiments\n  (for [noise-sd [0.3 0.5]\n        feature-set [:raw :poly+trig]\n        max-depth [4 8]]\n    (pocket/cached #'run-pipeline\n                   {:noise-sd noise-sd\n                    :feature-set feature-set\n                    :max-depth max-depth})))\n\nCompare all experiments ‚Äî only varying parameters are shown:\n\n(def comparison\n  (pocket/compare-experiments experiments))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.652 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n18:23:49.658 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n18:23:49.663 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n18:23:49.670 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n18:23:49.681 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n18:23:49.688 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n18:23:49.694 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n18:23:49.703 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n\n\n\n\n\n(tc/dataset comparison)\n\n\n_unnamed [8 4]:\n\n\n\n:noise-sd\n:feature-set\n:max-depth\n:result\n\n\n\n\n0.3\n:raw\n4\n{:rmse 0.7189521159338053}\n\n\n0.3\n:raw\n8\n{:rmse 0.41024324994778005}\n\n\n0.3\n:poly+trig\n4\n{:rmse 0.5297031491020386}\n\n\n0.3\n:poly+trig\n8\n{:rmse 0.4530388384300822}\n\n\n0.5\n:raw\n4\n{:rmse 0.8815492449083825}\n\n\n0.5\n:raw\n8\n{:rmse 0.6467985374993637}\n\n\n0.5\n:poly+trig\n4\n{:rmse 0.7728233864192875}\n\n\n0.5\n:poly+trig\n8\n{:rmse 0.6785270538736407}\n\n\n\n\nEach row shows the varying parameters plus the result. Parameters that were constant (like seed=42) are excluded automatically ‚Äî you see only what differs.\n\nResults visualization\n\n(let [rows (map (fn [exp]\n                  (merge (select-keys exp [:noise-sd :feature-set :max-depth])\n                         (:result exp)))\n                comparison)\n      ;; Group by both feature-set and noise-sd for legend entries\n      grouped (group-by (juxt :feature-set :noise-sd) rows)\n      feature-colors {:raw \"steelblue\" :poly \"tomato\" :poly+trig \"green\"}]\n  (kind/plotly\n   {:data (vec (for [[[feature-set noise-sd] pts] (sort-by first grouped)\n                     :let [max-depths (mapv :max-depth pts)\n                           rmses (mapv :rmse pts)]]\n                 {:x max-depths\n                  :y rmses\n                  :mode \"markers\"\n                  :name (str (name feature-set) \" (noise=\" noise-sd \")\")\n                  :legendgroup (name feature-set)\n                  :marker {:size (+ 8 (* 15 noise-sd))\n                           :color (feature-colors feature-set)}}))\n\n    :layout {:xaxis {:title \"max-depth\"} :yaxis {:title \"rmse\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#what-we-learned",
    "href": "pocket_book.ml_workflows.html#what-we-learned",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "What we learned",
    "text": "What we learned\nThis experiment revealed a clear story about the interplay between models, features, and noise:\n\nFeature engineering is decisive for linear models. With raw features, the linear model couldn‚Äôt capture the nonlinear target at all. Adding trigonometric features (sin, cos) ‚Äî which match the structure of the true function ‚Äî dramatically improved it. The model didn‚Äôt get smarter; we gave it the right vocabulary.\nDecision trees are self-sufficient but fragile. The CART model achieved low error regardless of feature set, because it can learn nonlinear splits on its own. But as noise increased, it began fitting the noise rather than the signal ‚Äî a classic overfitting pattern.\nThe crossover point matters. At low noise, the tree wins. At high noise, the well-featured linear model degrades more gracefully. Knowing where this crossover happens is exactly the kind of insight you get from systematic experimentation.\nCaching structures the workflow. In this small example, each step runs in milliseconds ‚Äî caching isn‚Äôt needed for speed. But the pattern scales: with real datasets and expensive training, the same pipeline structure ensures that only changed steps recompute. Meanwhile, compare-experiments extracted the varying parameters automatically, turning cached results into a comparison table ‚Äî useful at any scale.\nPreprocessing order matters. Outlier x values get amplified by polynomial features (x¬≤), so clipping must come before feature engineering. The diamond dependency ‚Äî one threshold feeding both train and test clipping ‚Äî is handled naturally by Pocket‚Äôs DAG.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#cleanup-1",
    "href": "pocket_book.ml_workflows.html#cleanup-1",
    "title": "10¬† Example: Machine Learning Workflows",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.729 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed true}\n\n\nsource: notebooks/pocket_book/ml_workflows.clj",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html",
    "href": "pocket_book.pocket_model.html",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "",
    "text": "Background\nLast modified: 2026-02-08\nThis chapter shows how to cache model training in a metamorph.ml pipeline using Pocket. We define a small pocket-model function ‚Äî a drop-in replacement for ml/model ‚Äî and use it with cross-validation, grid search, and multiple model types.\nmetamorph.ml is the Scicloj library for machine learning pipelines. It builds on metamorph, a data-transformation framework where each step is a function that takes a context map and returns an updated one. metamorph.ml distinguishes two modes ‚Äî :fit (learn from training data) and :transform (apply to new data) ‚Äî so a pipeline can be trained once and reused for prediction.\nOn top of this, metamorph.ml adds model training/prediction, cross-validation (evaluate-pipelines), loss functions, and hyperparameter search. A typical workflow looks like:",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#background",
    "href": "pocket_book.pocket_model.html#background",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "",
    "text": "Define a pipeline of preprocessing + model steps\nSplit data into folds\nCall evaluate-pipelines to train and score across folds\nCompare results, pick the best model",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#why-cache-with-pocket",
    "href": "pocket_book.pocket_model.html#why-cache-with-pocket",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Why cache with Pocket?",
    "text": "Why cache with Pocket?\nmetamorph.ml includes a built-in caching mechanism. This notebook explores what happens when we use Pocket‚Äôs caching instead, bringing a few things that are natural to Pocket‚Äôs design:\n\nDisk persistence ‚Äî cached models survive JVM restarts, so we can pick up where we left off across sessions\nContent-based keys ‚Äî cache keys derived from function identity and full argument values via SHA-1\nConcurrent dedup ‚Äî when multiple threads request the same computation, only one trains and the rest wait for the result\n\nThe integration is lightweight: a pocket-model function that is a drop-in replacement for ml/model. We swap one pipeline step and everything else ‚Äî evaluate-pipelines, preprocessing, grid search ‚Äî stays the same.\nWhat this gives us:\n\nSame pipeline code, same evaluate-pipelines\nModel training cached to disk (survives JVM restarts)\nGraceful fallback for non-serializable models\n\nWhat this notebook does not cover: because pocket-model plugs into metamorph.ml‚Äôs existing pipeline machinery, only the model-training step is cached through Pocket. Preprocessing, splitting, and evaluation happen outside Pocket‚Äôs awareness ‚Äî there is no computational DAG tracking the full pipeline, no per-step storage control (choosing whether each step caches to disk, memory, or not at all), and no provenance trail that connects a final metric back to the data and parameters that produced it. A companion notebook is in the works, exploring a deeper integration where every pipeline step is a Pocket caching-fn, giving us all of those things.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#setup",
    "href": "pocket_book.pocket_model.html#setup",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Setup",
    "text": "Setup\n\n(ns pocket-book.pocket-model\n  (:require\n   [pocket-book.logging]\n   [scicloj.pocket :as pocket]\n   [scicloj.kindly.v4.kind :as kind]\n   [tablecloth.api :as tc]\n   [tablecloth.column.api :as tcc]\n   [tech.v3.dataset.modelling :as ds-mod]\n   [tech.v3.dataset.column-filters :as cf]\n   [scicloj.metamorph.ml :as ml]\n   [scicloj.metamorph.ml.loss :as loss]\n   [scicloj.metamorph.ml.regression]\n   [scicloj.metamorph.core :as mm]\n   [scicloj.ml.tribuo]))\n\n\n(def cache-dir \"/tmp/pocket-model\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.881 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-model\n\n\n\n\n\n\"/tmp/pocket-model\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.881 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#the-pocket-model-function",
    "href": "pocket_book.pocket_model.html#the-pocket-model-function",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "The pocket-model function",
    "text": "The pocket-model function\nThis is the core of the integration. It follows the same contract as ml/model ‚Äî a metamorph step that trains in :fit mode and predicts in :transform mode. The only difference: ml/train is wrapped with pocket/cached.\nIf Nippy can‚Äôt serialize a model (e.g., Apache Commons Math OLS), it falls back to uncached training automatically.\n\n(defn pocket-model\n  \"Drop-in replacement for ml/model that caches training via Pocket.\n  Falls back to uncached training if serialization fails.\"\n  [options]\n  (fn [{:metamorph/keys [id data mode] :as ctx}]\n    (case mode\n      :fit\n      (let [model (try\n                    (deref (pocket/cached #'ml/train data options))\n                    (catch Exception _e\n                      (ml/train data options)))]\n        (assoc ctx id (assoc model :scicloj.metamorph.ml/unsupervised?\n                             (get (ml/options-&gt;model-def options)\n                                  :unsupervised? false))))\n      :transform\n      (let [model (get ctx id)]\n        (if (get model :scicloj.metamorph.ml/unsupervised?)\n          ctx\n          (-&gt; ctx\n              (update id assoc\n                      :scicloj.metamorph.ml/feature-ds (cf/feature data)\n                      :scicloj.metamorph.ml/target-ds (cf/target data))\n              (assoc :metamorph/data (ml/predict data model))))))))",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#test-data",
    "href": "pocket_book.pocket_model.html#test-data",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Test data",
    "text": "Test data\nSimple synthetic regression: y = 3x + noise. 200 rows, enough for quick feedback.\n\n(def ds (-&gt; (let [rng (java.util.Random. 42)]\n              (tc/dataset\n               {:x (vec (repeatedly 200 #(* 10.0 (.nextDouble rng))))\n                :y (vec (repeatedly 200 #(+ (* 3.0 (* 10.0 (.nextDouble rng)))\n                                            (* 2.0 (.nextGaussian rng)))))}))\n            (ds-mod/set-inference-target :y)))\n\n\n(def splits (tc/split-&gt;seq ds :kfold {:k 3 :seed 42}))\n\n\n(count splits)\n\n\n3",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#basic-usage",
    "href": "pocket_book.pocket_model.html#basic-usage",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Basic usage",
    "text": "Basic usage\nUse pocket-model in place of ml/model. The {:metamorph/id :model} map step sets the step ID that evaluate-pipelines expects.\n\n(def cart-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"cart\"\n                        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                        :properties {:maxDepth \"8\"}}]\n   :tribuo-trainer-name \"cart\"})\n\n\n(def pipe-cart\n  (mm/pipeline\n   {:metamorph/id :model}\n   (pocket-model cart-spec)))\n\nFirst run ‚Äî trains 3 models (one per fold):\n\n(def results-1\n  (ml/evaluate-pipelines\n   [pipe-cart]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.891 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:49.898 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:49.905 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n\n\n\n\n\n(mapv #(-&gt; % :test-transform :metric) (flatten results-1))\n\n\n[10.938693265902357 11.23113067170221 12.12978921023711]\n\nCache now has 3 entries (one per fold):\n\n(pocket/cache-stats)\n\n\n{:total-entries 3,\n :total-size-bytes 53371,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 3}}\n\nSecond run ‚Äî all cache hits, same metrics:\n\n(def results-2\n  (ml/evaluate-pipelines\n   [pipe-cart]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n(= (mapv #(-&gt; % :test-transform :metric) (flatten results-1))\n   (mapv #(-&gt; % :test-transform :metric) (flatten results-2)))\n\n\ntrue",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#incremental-grid-search",
    "href": "pocket_book.pocket_model.html#incremental-grid-search",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Incremental grid search",
    "text": "Incremental grid search\nStart with 3 depth values, then add 3 more. Only new combinations train ‚Äî existing ones hit cache.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.940 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\n\n(defn cart-pipe [max-depth]\n  (mm/pipeline\n   {:metamorph/id :model}\n   (pocket-model\n    {:model-type :scicloj.ml.tribuo/regression\n     :tribuo-components [{:name \"cart\"\n                          :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                          :properties {:maxDepth (str max-depth)}}]\n     :tribuo-trainer-name \"cart\"})))\n\nBatch 1: depths 4, 8, 12\n\n(def batch-1\n  (ml/evaluate-pipelines\n   (mapv cart-pipe [4 8 12])\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:49.943 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:49.951 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:49.958 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:49.964 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:49.972 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:49.983 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:49.993 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.000 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.007 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n\n\n\n\n3 depths √ó 3 folds = 9 trainings:\n\n(pocket/cache-stats)\n\n\n{:total-entries 9,\n :total-size-bytes 158774,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 9}}\n\nBatch 2: depths 4, 6, 8, 10, 12, 16 Depths 4, 8, 12 already cached ‚Üí only 6, 10, 16 are new\n\n(def batch-2\n  (ml/evaluate-pipelines\n   (mapv cart-pipe [4 6 8 10 12 16])\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.038 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.047 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.055 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.067 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.075 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.083 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.096 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.102 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.109 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n\n\n\n\n3 new depths √ó 3 folds = 9 new + 9 cached = 18 total:\n\n(pocket/cache-stats)\n\n\n{:total-entries 18,\n :total-size-bytes 322365,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 18}}\n\nCombine results ‚Äî best depth by mean RMSE:\n\n(let [depths [4 6 8 10 12 16]\n      means (mapv (fn [pipeline-results]\n                    (tcc/mean (map #(-&gt; % :test-transform :metric) pipeline-results)))\n                  batch-2)]\n  (tc/dataset {:depth depths :mean-rmse means}))\n\n\n_unnamed [6 2]:\n\n\n\n:depth\n:mean-rmse\n\n\n\n\n4\n12.89681757\n\n\n6\n12.36344906\n\n\n8\n12.28048327\n\n\n10\n11.43320438\n\n\n12\n10.68677435\n\n\n16\n9.86061013",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#multiple-model-types",
    "href": "pocket_book.pocket_model.html#multiple-model-types",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Multiple model types",
    "text": "Multiple model types\nCompare CART, linear SGD, and fastmath OLS in the same evaluation. Each model type is cached independently.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.135 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\n\n(def sgd-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"squared\"\n                        :type \"org.tribuo.regression.sgd.objectives.SquaredLoss\"}\n                       {:name \"trainer\"\n                        :type \"org.tribuo.regression.sgd.linear.LinearSGDTrainer\"\n                        :properties {:objective \"squared\"\n                                     :epochs \"50\"\n                                     :loggingInterval \"10000\"}}]\n   :tribuo-trainer-name \"trainer\"})\n\n\n(def multi-results\n  (ml/evaluate-pipelines\n   [(mm/pipeline {:metamorph/id :model} (pocket-model cart-spec))\n    (mm/pipeline {:metamorph/id :model} (pocket-model sgd-spec))\n    (mm/pipeline {:metamorph/id :model} (pocket-model {:model-type :fastmath/ols}))]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.136 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.145 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.153 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.164 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 08, 2026 6:23:50 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 133 examples\nFeb 08, 2026 6:23:50 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=133,max=32.285163,min=-3.003255,mean=15.591786,variance=84.043799})\n18:23:50.172 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 08, 2026 6:23:50 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 133 examples\nFeb 08, 2026 6:23:50 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=133,max=31.652557,min=-1.736155,mean=15.631001,variance=80.557863})\n18:23:50.178 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\nFeb 08, 2026 6:23:50 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 134 examples\nFeb 08, 2026 6:23:50 PM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=134,max=32.285163,min=-3.003255,mean=16.262557,variance=77.697467})\n18:23:50.185 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.214 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.223 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n\n\n\n\n3 model types √ó 3 folds = 9 entries:\n\n(pocket/cache-stats)\n\n\n{:total-entries 9,\n :total-size-bytes 188813,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 9}}\n\nMean RMSE per model type:\n\n(let [model-names [\"CART\" \"SGD\" \"fastmath-OLS\"]\n      means (mapv (fn [pipeline-results]\n                    (tcc/mean (map #(-&gt; % :test-transform :metric) pipeline-results)))\n                  multi-results)]\n  (tc/dataset {:model model-names :mean-rmse means}))\n\n\n_unnamed [3 2]:\n\n\n\n:model\n:mean-rmse\n\n\n\n\nCART\n11.43320438\n\n\nSGD\n9.00886158\n\n\nfastmath-OLS\n9.01791979",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#graceful-fallback",
    "href": "pocket_book.pocket_model.html#graceful-fallback",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Graceful fallback",
    "text": "Graceful fallback\nThe built-in metamorph.ml/ols uses Apache Commons Math which Nippy can‚Äôt serialize. pocket-model catches the error and falls back to uncached training ‚Äî the pipeline still works, just without disk caching for that model.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.250 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\n\n(def fallback-results\n  (ml/evaluate-pipelines\n   [(mm/pipeline {:metamorph/id :model} (pocket-model cart-spec))\n    (mm/pipeline {:metamorph/id :model} (pocket-model {:model-type :metamorph.ml/ols}))]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.251 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.263 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.277 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.291 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.309 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.316 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n\n\n\n\nCART models are cached ‚Äî 3 entries, one per fold. OLS falls back to uncached training silently. The failed serialization attempts leave empty cache directories, which show up as entries with a nil function name:\n\n(pocket/cache-stats)\n\n\n{:total-entries 6,\n :total-size-bytes 53371,\n :entries-per-fn {\"scicloj.metamorph.ml/train\" 3, nil 3}}\n\nBoth model types produce valid metrics:\n\n(let [model-names [\"CART\" \"OLS-fallback\"]\n      means (mapv (fn [pipeline-results]\n                    (tcc/mean (map #(-&gt; % :test-transform :metric) pipeline-results)))\n                  fallback-results)]\n  (tc/dataset {:model model-names :mean-rmse means}))\n\n\n_unnamed [2 2]:\n\n\n\n:model\n:mean-rmse\n\n\n\n\nCART\n11.43320438\n\n\nOLS-fallback\n9.00886158",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#disk-persistence",
    "href": "pocket_book.pocket_model.html#disk-persistence",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Disk persistence",
    "text": "Disk persistence\nModels survive JVM restarts. After clearing the in-memory cache, models are loaded from disk on next access.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.334 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\nTrain fresh:\n\n(def persist-results-1\n  (ml/evaluate-pipelines\n   [(mm/pipeline {:metamorph/id :model} (pocket-model cart-spec))]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.335 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.347 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n18:23:50.358 INFO scicloj.pocket.impl.cache - Cache miss, computing: scicloj.metamorph.ml/train\n\n\n\n\nClear in-memory cache (simulates JVM restart):\n\n(pocket/clear-mem-cache!)\n\n\n{}\n\nRe-evaluate ‚Äî loads from disk:\n\n(def persist-results-2\n  (ml/evaluate-pipelines\n   [(mm/pipeline {:metamorph/id :model} (pocket-model cart-spec))]\n   splits\n   loss/rmse\n   :loss\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\nSame metrics:\n\n(= (mapv #(-&gt; % :test-transform :metric) (flatten persist-results-1))\n   (mapv #(-&gt; % :test-transform :metric) (flatten persist-results-2)))\n\n\ntrue",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#discussion",
    "href": "pocket_book.pocket_model.html#discussion",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Discussion",
    "text": "Discussion\npocket-model is a thin wrapper ‚Äî about 20 lines of code ‚Äî that gives us disk-persistent model caching with zero changes to our pipeline structure. It works with evaluate-pipelines, preprocessing steps, learning curves, and grid search.\nSerialization compatibility (tested):\n\n\n\nBackend\nCacheable?\n\n\n\n\nTribuo regression (CART, SGD)\nYes\n\n\nTribuo classification\nYes\n\n\nfastmath/ols\nYes\n\n\nmetamorph.ml/ols (Commons Math)\nNo (falls back)\n\n\nmetamorph.ml/dummy-regressor\nYes\n\n\n\nWhen to use pocket-model:\n\nGrid search / hyperparameter tuning (train once, reuse)\nIterative notebook development (change downstream code, keep models)\nLearning curves (add new sizes, only new ones train)\nAny workflow where we re-evaluate with the same data + options",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.pocket_model.html#cleanup",
    "href": "pocket_book.pocket_model.html#cleanup",
    "title": "11¬† üöß Draft: pocket-model ‚Äî drop-in caching for metamorph.ml",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.387 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-model\n\n\n\n\n\n{:dir \"/tmp/pocket-model\", :existed true}\n\n\nsource: notebooks/pocket_book/pocket_model.clj",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>üöß Draft: `pocket-model` ‚Äî drop-in caching for metamorph.ml</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html",
    "href": "pocket_book.cache_keys.html",
    "title": "12¬† Under the hood: cache keys",
    "section": "",
    "text": "Setup\nWhen Pocket caches a function call, it builds a cache key from the function identity and all arguments. This chapter looks at how that works internally and what it costs ‚Äî especially for large arguments like datasets.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#setup",
    "href": "pocket_book.cache_keys.html#setup",
    "title": "12¬† Under the hood: cache keys",
    "section": "",
    "text": "(ns pocket-book.cache-keys\n  (:require\n   [scicloj.pocket :as pocket]\n   [scicloj.pocket.impl.cache :as cache]\n   [scicloj.pocket.protocols :as proto]\n   [scicloj.kindly.v4.kind :as kind]\n   [tablecloth.api :as tc]\n   [tech.v3.dataset.modelling :as ds-mod]))",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#the-four-steps",
    "href": "pocket_book.cache_keys.html#the-four-steps",
    "title": "12¬† Under the hood: cache keys",
    "section": "The four steps",
    "text": "The four steps\nEvery call to pocket/cached goes through four steps to produce a filesystem path for the cache entry:\n\n-&gt;id ‚Äî convert each argument to its identity representation via the PIdentifiable protocol. Vars become fully-qualified symbols; Cached references become lightweight references; datasets become their full column data + metadata.\ncanonical-id ‚Äî deep-sort maps and normalize the structure so that {:a 1 :b 2} and {:b 2 :a 1} produce the same key.\nstr ‚Äî serialize the canonical form to a string.\nsha ‚Äî SHA-1 hash for a fixed-length, filesystem-safe path.\n\nWhen a function‚Äôs arguments are small (scalars, keywords, or Cached references), all four steps are sub-millisecond. But when a raw dataset is passed directly, the full dataset content becomes part of the cache key.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#measuring-the-cost",
    "href": "pocket_book.cache_keys.html#measuring-the-cost",
    "title": "12¬† Under the hood: cache keys",
    "section": "Measuring the cost",
    "text": "Measuring the cost\nLet‚Äôs pass a 50,000-row dataset as a direct argument and time each step:\n\n(let [ds (-&gt; (tc/dataset {:x (vec (range 50000))\n                          :y (vec (range 50000))\n                          :z (repeatedly 50000 rand)})\n             (ds-mod/set-inference-target :y))\n      ;; Step 1: -&gt;id\n      t0 (System/nanoTime)\n      id (proto/-&gt;id ds)\n      t1 (System/nanoTime)\n      ;; Step 2: canonical-id\n      cid (cache/canonical-id id)\n      t2 (System/nanoTime)\n      ;; Step 3: str\n      s (str cid)\n      t3 (System/nanoTime)\n      ;; Step 4: sha\n      _ (cache/sha s)\n      t4 (System/nanoTime)]\n  {:rows 50000\n   :string-length (count s)\n   :-&gt;id-ms (/ (- t1 t0) 1e6)\n   :canonical-id-ms (/ (- t2 t1) 1e6)\n   :str-ms (/ (- t3 t2) 1e6)\n   :sha-ms (/ (- t4 t3) 1e6)})\n\n\n{:rows 50000,\n :string-length 1541617,\n :-&gt;id-ms 3.463044,\n :canonical-id-ms 8.98263,\n :str-ms 24.166543,\n :sha-ms 1.48034}\n\nThe str serialization step dominates ‚Äî it must walk the entire nested structure and produce a ~1.5 MB string. SHA-1 hashing that string is fast by comparison. Switching to a faster hash algorithm would not meaningfully help.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#why-cached-references-matter",
    "href": "pocket_book.cache_keys.html#why-cached-references-matter",
    "title": "12¬† Under the hood: cache keys",
    "section": "Why Cached references matter",
    "text": "Why Cached references matter\nWhen an argument is a Cached reference rather than a raw dataset, its identity is a lightweight reference to the computation that produced it ‚Äî not the data itself. Compare:\n\n(pocket/set-base-cache-dir! \"/tmp/pocket-cache-keys\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.509 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-cache-keys\n\n\n\n\n\n\"/tmp/pocket-cache-keys\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.509 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-cache-keys\n\n\n\n\n\n{:dir \"/tmp/pocket-cache-keys\", :existed false}\n\n\n(defn make-data [n]\n  (tc/dataset {:x (vec (range n))\n               :y (vec (range n))}))\n\nDirect dataset ‚Äî identity includes all 50,000 rows:\n\n(let [ds (make-data 50000)\n      t0 (System/nanoTime)\n      _ (str (cache/canonical-id (proto/-&gt;id ds)))\n      t1 (System/nanoTime)]\n  {:direct-ms (/ (- t1 t0) 1e6)})\n\n\n{:direct-ms 21.915702}\n\nCached reference ‚Äî identity is just (make-data 50000):\n\n(let [data-c (pocket/cached #'make-data 50000)\n      t0 (System/nanoTime)\n      _ (str (cache/canonical-id (proto/-&gt;id data-c)))\n      t1 (System/nanoTime)]\n  {:cached-reference-ms (/ (- t1 t0) 1e6)})\n\n\n{:cached-reference-ms 0.263794}\n\nThe Cached reference is orders of magnitude faster because its identity is a small form like (pocket-book.cache-keys/make-data 50000), regardless of how large the output dataset is.\nThis is one of the key reasons to chain pocket/cached calls in a pipeline: each step‚Äôs cache key references its inputs by identity rather than by content, keeping key generation fast and enabling full provenance through the DAG.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.cache_keys.html#cleanup",
    "href": "pocket_book.cache_keys.html#cleanup",
    "title": "12¬† Under the hood: cache keys",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.543 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-cache-keys\n\n\n\n\n\n{:dir \"/tmp/pocket-cache-keys\", :existed false}\n\n\nsource: notebooks/pocket_book/cache_keys.clj",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Under the hood: cache keys</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html",
    "href": "pocket_book.developing_pocket.html",
    "title": "13¬† Developing Pocket",
    "section": "",
    "text": "Rendering notebooks\nLast modified: 2026-02-08\nThis chapter is for contributors and curious readers. It describes how Pocket‚Äôs documentation is built, how tests are structured, and the conventions the notebooks follow.\nPocket‚Äôs documentation is a Clay book ‚Äî a collection of Clojure source files that Clay evaluates and renders as HTML (via Quarto) or as GitHub Flavored Markdown.\nThe chapter list lives in notebooks/chapters.edn:\nEach entry maps to a file under notebooks/pocket_book/. For example, \"getting_started\" corresponds to notebooks/pocket_book/getting_started.clj.\nThe rendering helpers live in notebooks/dev.clj. From a REPL with the :dev alias:\nThe Quarto configuration is in clay.edn at the project root.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#rendering-notebooks",
    "href": "pocket_book.developing_pocket.html#rendering-notebooks",
    "title": "13¬† Developing Pocket",
    "section": "",
    "text": "(-&gt;&gt; \"notebooks/chapters.edn\"\n     slurp\n     clojure.edn/read-string)\n\n\n[\"getting_started\"\n \"configuration\"\n \"logging\"\n \"recursive_caching_in_pipelines\"\n \"usage_practices\"\n \"real_world_walkthrough\"\n \"concurrency\"\n \"extending_pocket\"\n \"ml_workflows\"\n \"pocket_model\"\n \"cache_keys\"\n \"developing_pocket\"\n \"api_reference\"]\n\n\n\n(require '[dev :as dev] :reload)\n\n;; Render the full HTML book (opens a browser):\n(dev/make-book!)\n\n;; Render one or more chapters as GitHub Flavored Markdown\n;; (useful for reviewing in a terminal or diff tool):\n(dev/make-gfm! \"pocket_book/getting_started.clj\")",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#running-tests",
    "href": "pocket_book.developing_pocket.html#running-tests",
    "title": "13¬† Developing Pocket",
    "section": "Running tests",
    "text": "Running tests\nThe test suite combines hand-written tests with tests generated from notebooks:\n./run_tests.sh\nThis runs clojure -M:dev:test -m cognitect.test-runner, which scans the test/ directory recursively. It picks up:\n\ntest/scicloj/pocket_test.clj ‚Äî hand-written unit tests\ntest/pocket_book/*_generated_test.clj ‚Äî tests generated from notebook kind/test-last annotations (see below)",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#literate-testing-with-kindtest-last",
    "href": "pocket_book.developing_pocket.html#literate-testing-with-kindtest-last",
    "title": "13¬† Developing Pocket",
    "section": "Literate testing with kind/test-last",
    "text": "Literate testing with kind/test-last\nClay notebooks can embed inline assertions using kind/test-last. A form like:\n(+ 1 2)\n\n(kind/test-last [= 3])\nasserts that the result of the previous form equals 3. The kind/test-last form is invisible in the rendered documentation ‚Äî readers see only the code and its output.\nWhen Clay renders the notebook, it generates a standard clojure.test file as a side effect. For example, a notebook notebooks/pocket_book/foo.clj produces test/pocket_book/foo_generated_test.clj.\nHere is a live example:\n\n(def demo-value (+ 10 20))\n\n\ndemo-value\n\n\n30\n\nThe assertion above is invisible in the rendered output ‚Äî but it generated a deftest that runs with every test suite execution.\nThe predicate can be any function. Common patterns:\n\n(type demo-value)\n\n\njava.lang.Long\n\n\n(str \"result is \" demo-value)\n\n\n\"result is 30\"",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#api-reference-with-kinddoc",
    "href": "pocket_book.developing_pocket.html#api-reference-with-kinddoc",
    "title": "13¬† Developing Pocket",
    "section": "API Reference with kind/doc",
    "text": "API Reference with kind/doc\nThe API Reference chapter uses kind/doc to render a var‚Äôs docstring as formatted documentation:\n\n(kind/doc #'clojure.core/map)\n\n\nmap\n[f]\n[f coll]\n[f c1 c2]\n[f c1 c2 c3]\n[f c1 c2 c3 & colls]\nReturns a lazy sequence consisting of the result of applying f to the set of first items of each coll, followed by applying f to the set of second items in each coll, until any one of the colls is exhausted. Any remaining items in other colls are ignored. Function f should accept number-of-colls arguments. Returns a transducer when no collection is provided.\nEach kind/doc call produces a documentation block from the var‚Äôs metadata (docstring, arglists, etc.). Live code examples follow naturally after each block.\nThe API Reference namespace uses a metadata hint to hide the kind/doc source code in the rendered output:\n^{:kindly/hide-code true\n  :kindly/options {:kinds-that-hide-code #{:kind/doc}}}\n(ns pocket-book.api-reference ...)\nThis means readers see the formatted docstring but not the (kind/doc ...) call that produced it.\n\nsource: notebooks/pocket_book/developing_pocket.clj",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html",
    "href": "pocket_book.api_reference.html",
    "title": "14¬† API Reference",
    "section": "",
    "text": "Setup\nLast modified: 2026-02-08\nA few preparations for the code examples below:",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#setup",
    "href": "pocket_book.api_reference.html#setup",
    "title": "14¬† API Reference",
    "section": "",
    "text": "(require '[scicloj.pocket :as pocket])\n\n\n(def cache-dir \"/tmp/pocket-demo-reference\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.581 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-reference\n\n\n\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.581 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed false}\n\n\n(defn expensive-calculation\n  \"Simulates an expensive computation\"\n  [x y]\n  (println (str \"Computing \" x \" + \" y \" (this is expensive!)\"))\n  (Thread/sleep 400)\n  (+ x y))",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#reference",
    "href": "pocket_book.api_reference.html#reference",
    "title": "14¬† API Reference",
    "section": "Reference",
    "text": "Reference\n\n*base-cache-dir*\nBase directory for cache storage.\nResolved with precedence: binding &gt; set-base-cache-dir! &gt; POCKET_BASE_CACHE_DIR env var &gt; pocket.edn :base-cache-dir &gt; pocket-defaults.edn (library default: .cache/pocket).\nThe current value:\n\npocket/*base-cache-dir*\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n\nset-base-cache-dir!\n[dir]\nSet the base cache directory by altering *base-cache-dir*. Returns the directory path.\n\n(pocket/set-base-cache-dir! \"/tmp/pocket-demo-2\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.584 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-2\n\n\n\n\n\n\"/tmp/pocket-demo-2\"\n\n\npocket/*base-cache-dir*\n\n\n\"/tmp/pocket-demo-2\"\n\nRestore it for the rest of the notebook:\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.584 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-reference\n\n\n\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n\nconfig\n[]\nReturn the effective resolved configuration as a map. Useful for inspecting which cache directory, mem-cache policy, storage policy, and filename length limit are in effect after applying the precedence chain.\nInspect the current effective configuration:\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-reference\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\n\n\ncached\n[func & args]\nCreate a cached computation (returns IDeref).\nThe computation is executed on first deref and cached to disk. Subsequent derefs load from cache if available.\nfunc must be a var (e.g., #'my-fn) or keyword (e.g., :train) for stable cache keys. Keywords are useful for extracting from cached maps: (cached :train split-c).\nStorage policy is controlled by *storage* (see set-storage!). Use caching-fn with an opts map for per-function overrides.\ncached returns a Cached object ‚Äî the computation is not yet executed:\n\n(def my-result (pocket/cached #'expensive-calculation 100 200))\n\n\n(type my-result)\n\n\nscicloj.pocket.impl.cache.Cached\n\nThe computation runs when we deref:\n\n(deref my-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.587 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 100 + 200 (this is expensive!)\n\n\n\n\n\n300\n\nDerefing again loads from cache (no recomputation):\n\n(deref my-result)\n\n\n300\n\n\n\ncaching-fn\n[f]\n[f opts]\nWrap a function to automatically cache its results.\nReturns a new function where each call returns a Cached object (IDeref). Deref the result to trigger computation or load from cache. f must be a var (e.g., #'my-fn) or keyword for stable cache keys.\nOptionally accepts an options map to override configuration per-function:\n\n:storage ‚Äî :mem+disk, :mem, or :none (overrides *storage*)\n:cache-dir ‚Äî base cache directory (overrides *base-cache-dir*)\n:mem-cache ‚Äî in-memory cache options (overrides *mem-cache-options*)\n:filename-length-limit ‚Äî max filename length before SHA-1 fallback (overrides *filename-length-limit*)\n\ncaching-fn wraps a function so that every call returns a Cached object:\n\n(def my-caching-fn (pocket/caching-fn #'expensive-calculation))\n\n\n(deref (my-caching-fn 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:50.995 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\nSame args hit the cache:\n\n(deref (my-caching-fn 3 4))\n\n\n7\n\ncaching-fn accepts an optional map to override per-function configuration:\n(pocket/caching-fn #'f {:storage :mem})     ;; in-memory only\n(pocket/caching-fn #'f {:storage :none})    ;; identity tracking only\n(pocket/caching-fn #'f {:cache-dir \"/tmp/alt\"})  ;; alternate cache dir\nSee the Configuration chapter for details on storage modes and the full option map.\n\n\nmaybe-deref\n[x]\nDeref if x implements IDeref, otherwise return x as-is.\nUseful in pipeline functions that may receive either Cached or plain values.\nA plain value passes through unchanged:\n\n(pocket/maybe-deref 42)\n\n\n42\n\nA Cached value gets derefed:\n\n(pocket/maybe-deref (pocket/cached #'expensive-calculation 100 200))\n\n\n300\n\n\n\n-&gt;id\n[x]\nReturn a cache key representation of a value. Dispatches via the PIdentifiable protocol.\nA var‚Äôs identity is its fully-qualified name:\n\n(pocket/-&gt;id #'expensive-calculation)\n\n\npocket-book.api-reference/expensive-calculation\n\nA map‚Äôs identity is itself (maps are deep-sorted later for stable cache paths):\n\n(pocket/-&gt;id {:b 2 :a 1})\n\n\n{:b 2, :a 1}\n\nA Cached object‚Äôs identity captures the full computation ‚Äî function name and argument identities ‚Äî without running it:\n\n(pocket/-&gt;id (pocket/cached #'expensive-calculation 100 200))\n\n\n(pocket-book.api-reference/expensive-calculation 100 200)\n\nnil is handled as well:\n\n(pocket/-&gt;id nil)\n\n\nnil\n\n\n\nset-mem-cache-options!\n[opts]\nConfigure the in-memory cache. Resets it, discarding any currently cached values.\nSupported keys:\n\n:policy ‚Äî :lru, :fifo, :lu, :ttl, :lirs, :soft, or :basic\n:threshold ‚Äî max entries for :lru, :fifo, :lu\n:ttl ‚Äî time-to-live in ms for :ttl policy\n:s-history-limit / :q-history-limit ‚Äî for :lirs policy\n\nDefaults come from pocket-defaults.edn.\nSwitch to a FIFO policy with 100 entries:\n\n(pocket/set-mem-cache-options! {:policy :fifo :threshold 100})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.413 INFO scicloj.pocket - Mem-cache options set: {:policy :fifo, :threshold 100}\n18:23:51.413 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :fifo, :threshold 100}\n\n\n\n\n\n{:policy :fifo, :threshold 100}\n\nReset to default:\n\n(pocket/set-mem-cache-options! {:policy :lru :threshold 256})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.414 INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 256}\n18:23:51.414 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\n\nreset-mem-cache-options!\n[]\nReset the in-memory cache configuration to library defaults. Clears any options set by set-mem-cache-options! and reconfigures the mem-cache with the default policy from pocket-defaults.edn. Returns the default options.\nReset mem-cache configuration to library defaults:\n\n(pocket/reset-mem-cache-options!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.416 INFO scicloj.pocket - Mem-cache options reset to defaults: {:policy :lru, :threshold 256}\n18:23:51.416 INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\n\n*storage*\nStorage policy for cached computations: :mem+disk, :mem, or :none.\n\n:mem+disk (default) ‚Äî in-memory cache backed by disk persistence\n:mem ‚Äî in-memory cache only, no disk I/O\n:none ‚Äî no shared cache; instance-local memoization only\n\nResolved with precedence: binding &gt; set-storage! &gt; POCKET_STORAGE env var &gt; pocket.edn :storage &gt; pocket-defaults.edn (library default: :mem+disk).\n\n\nset-storage!\n[storage]\nSet the storage policy by altering *storage*. Valid values: :mem+disk, :mem, :none. Returns the storage policy.\nSwitch to memory-only storage:\n\n(pocket/set-storage! :mem)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.417 INFO scicloj.pocket - Storage policy set to: :mem\n\n\n\n\n\n:mem\n\nReset to default:\n\n(pocket/set-storage! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.418 INFO scicloj.pocket - Storage policy set to: nil\n\n\n\n\n\nnil\n\n\n\ncleanup!\n[]\nDelete the cache directory, removing all cached values. Also clears the in-memory cache. Returns a map with :dir and :existed indicating what happened.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.421 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\nclear-mem-cache!\n[]\nClear all entries from the in-memory cache without deleting the disk cache. The next deref of a cached value will reload from disk if available. Useful for testing scenarios that need to simulate memory eviction.\nClear in-memory cache without touching disk:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.423 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n(pocket/clear-mem-cache!)\n\n\n{}\n\n\n\ninvalidate!\n[func & args]\nInvalidate a specific cached computation, removing it from both disk and memory. Takes the same arguments as cached: a function var (or keyword) and its arguments. Returns a map with :path and :existed.\nRemove a specific cached entry:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n30\n\n\n(pocket/invalidate! #'expensive-calculation 10 20)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.828 INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20) existed= true\n\n\n\n\n\n{:path\n \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n :existed true}\n\nDerefing again will recompute:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:51.829 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n\ninvalidate-fn!\n[func]\nInvalidate all cached entries for a given function var (or keyword), regardless of arguments. Removes matching entries from both disk and memory. Returns a map with :fn-name, :count, and :paths.\nCache a few entries, then invalidate them all:\n\n(deref (pocket/cached #'expensive-calculation 1 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:52.233 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 1 + 2 (this is expensive!)\n\n\n\n\n\n3\n\n\n(deref (pocket/cached #'expensive-calculation 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:52.638 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\n\n(pocket/invalidate-fn! #'expensive-calculation)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:53.042 INFO scicloj.pocket.impl.cache - Invalidated 3 entries for pocket-book.api-reference/expensive-calculation\n\n\n\n\n\n{:fn-name \"pocket-book.api-reference/expensive-calculation\",\n :count 3,\n :paths\n [\"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\"\n  \"/tmp/pocket-demo-reference/d2/(pocket-book.api-reference_expensive-calculation 1 2)\"\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\"]}\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:53.044 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\ncache-entries\n[]\n[fn-name]\nScan the cache directory and return a sequence of metadata maps. Each entry contains :path, :id, :fn-name, :args-str, and :created-at (when metadata is available ‚Äî entries cached before metadata support will only have :path). Optionally filter by function name.\nList all cached entries:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:53.046 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n(deref (pocket/cached #'expensive-calculation 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:53.450 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 10 20)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[10 20]\",\n  :created-at \"2026-02-08T16:23:53.447126317Z\"}\n {:path\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 3 4)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[3 4]\",\n  :created-at \"2026-02-08T16:23:53.851183044Z\"}]\n\nFilter by function name:\n\n(pocket/cache-entries \"pocket-book.api-reference/expensive-calculation\")\n\n\n[{:path\n  \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 10 20)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[10 20]\",\n  :created-at \"2026-02-08T16:23:53.447126317Z\"}\n {:path\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 3 4)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[3 4]\",\n  :created-at \"2026-02-08T16:23:53.851183044Z\"}]\n\n\n\ncache-stats\n[]\nReturn aggregate statistics about the cache. Returns a map with :total-entries, :total-size-bytes, and :entries-per-fn.\n\n(pocket/cache-stats)\n\n\n{:total-entries 2,\n :total-size-bytes 388,\n :entries-per-fn {\"pocket-book.api-reference/expensive-calculation\" 2}}\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:53.860 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\norigin-story\n[x]\nGiven a value, return its computation DAG as a nested map.\nFor a Cached value, each node is {:fn &lt;var&gt; :args [&lt;nodes&gt;] :id &lt;string&gt;}, with :value included if the computation has been realized. Plain (non-Cached) arguments become {:value &lt;val&gt;} leaf nodes.\nWhen the same Cached instance appears multiple times in the tree, subsequent occurrences are represented as {:ref &lt;id&gt;} pointing to the first occurrence‚Äôs :id. This enables proper DAG representation for diamond dependencies.\nDoes not trigger computation ‚Äî only peeks at already-realized values. Works with all storage policies (:mem+disk, :mem, :none).\norigin-story returns a nested map describing a computation‚Äôs DAG. Each cached step is {:fn &lt;var&gt; :args [...]}, with :value if realized. Plain arguments become {:value ...} leaves.\n\n(defn step-a [x] (+ x 10))\n\n\n(defn step-b [x y] (* x y))\n\n\n(def a-c (pocket/cached #'step-a 5))\n\n\n(def b-c (pocket/cached #'step-b a-c 3))\n\nBefore deref ‚Äî no :value keys:\n\n(pocket/origin-story b-c)\n\n\n{:fn #'pocket-book.api-reference/step-b,\n :args\n [{:fn #'pocket-book.api-reference/step-a,\n   :args [{:value 5}],\n   :id \"c2\"}\n  {:value 3}],\n :id \"c1\"}\n\nDeref to trigger computation:\n\n(deref b-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:53.864 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/step-b\n18:23:53.864 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/step-a\n\n\n\n\n\n45\n\nAfter deref ‚Äî :value keys appear:\n\n(pocket/origin-story b-c)\n\n\n{:fn #'pocket-book.api-reference/step-b,\n :args\n [{:fn #'pocket-book.api-reference/step-a,\n   :args [{:value 5}],\n   :id \"c2\",\n   :value 15}\n  {:value 3}],\n :id \"c1\",\n :value 45}\n\n\n\norigin-story-mermaid\n[x]\nGiven a value, return a Mermaid flowchart string of its computation DAG.\nAccepts a Cached value (walks it via origin-story) or a tree map previously returned by origin-story.\nReturns a plain string. Wrap with (kind/mermaid ...) for Kindly rendering.\nReturns a Mermaid flowchart with kindly metadata for notebook rendering:\n\n(pocket/origin-story-mermaid b-c)\n\nflowchart TD\n  n0[\"step-b\"]\n  n1[\"step-a\"]\n  n2[/\"5\"/]\n  n2 --&gt; n1\n  n1 --&gt; n0\n  n3[/\"3\"/]\n  n3 --&gt; n0\n\n\norigin-story-graph\n[x]\nGiven a value, return its computation DAG as a normalized graph.\nReturns {:nodes {&lt;id&gt; &lt;node-map&gt;} :edges [[&lt;from&gt; &lt;to&gt;] ...]}.\nNode maps contain :fn (for cached steps) or :value (for leaves), plus :value if the cached computation has been realized.\nThis is the fully normalized (Format B) representation of the DAG. Use origin-story for the tree-with-refs representation (Format A).\norigin-story-graph returns a normalized {:nodes ... :edges ...} format, suitable for graph algorithms:\n\n(pocket/origin-story-graph b-c)\n\n\n{:nodes\n {\"c1\" {:fn #'pocket-book.api-reference/step-b, :value 45},\n  \"c2\" {:fn #'pocket-book.api-reference/step-a, :value 15},\n  \"v3\" {:value 5},\n  \"v4\" {:value 3}},\n :edges [[\"c1\" \"c2\"] [\"c2\" \"v3\"] [\"c1\" \"v4\"]]}\n\n\n\ncompare-experiments\n[cached-values]\nCompare multiple cached experiment results.\nTakes a seq of Cached values (typically final metrics from different hyperparameter configurations). Walks each experiment‚Äôs origin-story to extract parameter maps, identifies which parameters vary across experiments, and returns a seq of maps containing the varying params plus the experiment result.\nOnly parameters that differ across experiments are included. The :result key contains the derefed value of each Cached.\ncompare-experiments extracts varying parameters from multiple experiments. This is useful for hyperparameter sweeps where you want to see which parameters differ across experiments.\n\n(defn run-exp [config]\n  {:rmse (* 0.1 (:lr config))})\n\n\n(def exp1 (pocket/cached #'run-exp {:lr 0.01 :epochs 100}))\n\n\n(def exp2 (pocket/cached #'run-exp {:lr 0.001 :epochs 100}))\n\n\n(pocket/compare-experiments [exp1 exp2])\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:53.872 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/run-exp\n18:23:53.873 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/run-exp\n\n\n\n\n\n[{:lr 0.01, :result {:rmse 0.001}} {:lr 0.001, :result {:rmse 1.0E-4}}]\n\nNote: :epochs is not shown because it‚Äôs the same (100) in both experiments. Only varying parameters appear in the comparison.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n18:23:53.878 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#extending-pidentifiable",
    "href": "pocket_book.api_reference.html#extending-pidentifiable",
    "title": "14¬† API Reference",
    "section": "Extending PIdentifiable",
    "text": "Extending PIdentifiable\nYou can customize how your types contribute to cache keys by extending the PIdentifiable protocol. See the Extending Pocket chapter for a full walkthrough with examples.\n\nsource: notebooks/pocket_book/api_reference.clj",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>API Reference</span>"
    ]
  }
]