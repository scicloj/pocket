[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pocket Book",
    "section": "",
    "text": "1 Pocket Book",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Pocket Book</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html",
    "href": "pocket_book.getting_started.html",
    "title": "2  Getting Started",
    "section": "",
    "text": "Setup\nPocket is a Clojure library for filesystem-based caching of expensive computations. It persists results to disk so they survive JVM restarts. Cache keys are derived from the function identity and its arguments, so the same computation always maps to the same cache entry.\nFirst, we set up a cache directory and define an expensive computation:\nStart fresh so the examples below run from a clean slate:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#setup",
    "href": "pocket_book.getting_started.html#setup",
    "title": "2  Getting Started",
    "section": "",
    "text": "(ns pocket-book.getting-started\n  (:require\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]))\n\n\n\n(def cache-dir \"/tmp/pocket-demo\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo\n\n\n\n\n\n\"/tmp/pocket-demo\"\n\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo\n\n\n\n\n\n{:dir \"/tmp/pocket-demo\", :existed false}\n\n\n(defn expensive-calculation\n  \"Simulates an expensive computation\"\n  [x y]\n  (println (str \"Computing \" x \" + \" y \" (this is expensive!)\"))\n  (Thread/sleep 400)\n  (+ x y))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#background-deref-in-clojure",
    "href": "pocket_book.getting_started.html#background-deref-in-clojure",
    "title": "2  Getting Started",
    "section": "Background: deref in Clojure",
    "text": "Background: deref in Clojure\nIn Clojure, deref extracts a value from a reference type. It can be written as (deref x) or with the shorthand reader macro @x — both are equivalent. Pocket’s cached returns a Cached object that implements IDeref, so you use @ (or deref) to trigger the computation and retrieve the result.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#creating-a-cached-computation",
    "href": "pocket_book.getting_started.html#creating-a-cached-computation",
    "title": "2  Getting Started",
    "section": "Creating a cached computation",
    "text": "Creating a cached computation\ncached creates a lazy cached computation. It returns a Cached object — the computation won’t run until we deref it:\n\n(def cached-result\n  (pocket/cached #'expensive-calculation 10 20))\n\n\n(type cached-result)\n\n\nscicloj.pocket.impl.cache.Cached\n\nFirst deref (computes and caches):\n\n(time @cached-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\"Elapsed time: 401.784959 msecs\"\n\n\n\n\n\n30\n\nSecond deref (loaded from cache, instant):\n\n(time @cached-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.146564 msecs\"\n\n\n\n\n\n30",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#wrapping-functions-with-caching-fn",
    "href": "pocket_book.getting_started.html#wrapping-functions-with-caching-fn",
    "title": "2  Getting Started",
    "section": "Wrapping functions with caching-fn",
    "text": "Wrapping functions with caching-fn\nFor convenience, caching-fn wraps a function so that every call returns a Cached object:\n\n(def cached-expensive\n  (pocket/caching-fn #'expensive-calculation))\n\nFirst call:\n\n(time @(cached-expensive 5 15))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 5 + 15 (this is expensive!)\n\"Elapsed time: 401.467014 msecs\"\n\n\n\n\n\n20\n\nSame args — cache hit:\n\n(time @(cached-expensive 5 15))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.331776 msecs\"\n\n\n\n\n\n20\n\nDifferent args — new computation:\n\n(time @(cached-expensive 7 8))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation\nComputing 7 + 8 (this is expensive!)\n\"Elapsed time: 401.409314 msecs\"\n\n\n\n\n\n15",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#nil-handling",
    "href": "pocket_book.getting_started.html#nil-handling",
    "title": "2  Getting Started",
    "section": "Nil handling",
    "text": "Nil handling\nPocket properly handles nil values. Since the cache uses files on disk, it needs to distinguish “never computed” from “computed and got nil”. It does this with a special marker file:\n\n(defn returns-nil [] nil)\n\n\n(def nil-result (pocket/cached #'returns-nil))\n\nCached nil value:\n\n(deref nil-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/returns-nil\n\n\n\n\n\nnil\n\nLoading nil from cache:\n\n(deref nil-result)\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#important-use-vars-or-keywords-for-functions",
    "href": "pocket_book.getting_started.html#important-use-vars-or-keywords-for-functions",
    "title": "2  Getting Started",
    "section": "Important: use vars or keywords for functions",
    "text": "Important: use vars or keywords for functions\nAlways pass functions as vars (#'fn-name) or keywords, not as bare function objects. Vars have stable names that produce consistent cache keys across sessions. Keywords are useful for extracting from cached maps (e.g., (cached :train split-c)). Pocket throws an error if you pass a bare function:\n;; ✅ (pocket/cached #'my-function args)\n;; ✅ (pocket/cached :train cached-map)\n;; ❌ (pocket/cached my-function args)\nSee the Usage Practices chapter for a detailed explanation and more best practices.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#next-steps",
    "href": "pocket_book.getting_started.html#next-steps",
    "title": "2  Getting Started",
    "section": "Next steps",
    "text": "Next steps\n\nConfiguration — cache directory, in-memory eviction policies, pocket.edn\nRecursive Caching in Pipelines — chaining cached computations\nUsage Practices — invalidation strategies, testing, serialization, and more",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.getting_started.html#cleanup",
    "href": "pocket_book.getting_started.html#cleanup",
    "title": "2  Getting Started",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo\n\n\n\n\n\n{:dir \"/tmp/pocket-demo\", :existed true}\n\n\nsource: notebooks/pocket_book/getting_started.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Getting Started</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html",
    "href": "pocket_book.configuration.html",
    "title": "3  Configuration",
    "section": "",
    "text": "Setup\nPocket resolves configuration using a precedence chain (for both cache directory and in-memory cache options), from highest to lowest priority:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#setup",
    "href": "pocket_book.configuration.html#setup",
    "title": "3  Configuration",
    "section": "",
    "text": "binding (thread-local override)\nset-*! functions (set-base-cache-dir!, set-mem-cache-options!)\nEnvironment variable (POCKET_BASE_CACHE_DIR, POCKET_MEM_CACHE)\npocket.edn on classpath\nLibrary defaults (pocket-defaults.edn)\n\nflowchart TD\n    B(binding) --&gt;|if nil| S(set-*!)\n    S --&gt;|if nil| E(Environment variable)\n    E --&gt;|if nil| P(pocket.edn)\n    P --&gt;|if nil| D(Hardcoded default)\n    style B fill:#4a9,color:#fff\n    style D fill:#888,color:#fff",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#pocket.edn",
    "href": "pocket_book.configuration.html#pocket.edn",
    "title": "3  Configuration",
    "section": "pocket.edn",
    "text": "pocket.edn\nPlace a pocket.edn file on your classpath root for declarative, project-level configuration:\n{:base-cache-dir \"/tmp/my-project-cache\"\n :mem-cache {:policy :lru :threshold 256}}\nIt is re-read on each cache operation (with a 1-second TTL cache), so changes take effect quickly during REPL development. It provides defaults that can be overridden by environment variables, set-*! calls, or binding.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#library-defaults",
    "href": "pocket_book.configuration.html#library-defaults",
    "title": "3  Configuration",
    "section": "Library defaults",
    "text": "Library defaults\nPocket ships with pocket-defaults.edn containing the library defaults. These are used when no other configuration is provided:\n\n(-&gt; (clojure.java.io/resource \"pocket-defaults.edn\")\n    slurp\n    clojure.edn/read-string)\n\n\n{:base-cache-dir \".cache/pocket\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\nYou can override any of these via pocket.edn, environment variables, or the set-*! functions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cache-directory",
    "href": "pocket_book.configuration.html#cache-directory",
    "title": "3  Configuration",
    "section": "Cache directory",
    "text": "Cache directory\nThe cache directory can be set in several ways.\nEnvironment variable — POCKET_BASE_CACHE_DIR:\nexport POCKET_BASE_CACHE_DIR=/path/to/cache\nProgrammatically with set-base-cache-dir!:\n\n(pocket/set-base-cache-dir! \"/tmp/pocket-demo-config\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-config\n\n\n\n\n\n\"/tmp/pocket-demo-config\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-config\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-config\", :existed false}\n\nYou can inspect the effective resolved configuration at any time:\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-config\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\nThread-local binding (useful for tests):\n(binding [pocket/*base-cache-dir* \"/tmp/test-cache\"]\n  @(pocket/cached #'my-fn args))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#in-memory-cache-and-thread-safety",
    "href": "pocket_book.configuration.html#in-memory-cache-and-thread-safety",
    "title": "3  Configuration",
    "section": "In-memory cache and thread safety",
    "text": "In-memory cache and thread safety\nPocket maintains an in-memory cache in front of the disk layer, backed by core.cache.\nflowchart LR\n    D(deref) --&gt; MC{In-memory\ncache?}\n    MC --&gt;|hit| R[Return value]\n    MC --&gt;|miss| DC{Disk\ncache?}\n    DC --&gt;|hit| R\n    DC --&gt;|miss| C[Compute] --&gt; W[Write to disk] --&gt; R\nThis provides two benefits:\n\nPerformance — repeated derefs of the same computation skip disk I/O entirely (until the entry is evicted from memory).\nThread safety — when multiple threads deref the same Cached value concurrently, the computation runs exactly once. This is coordinated via a ConcurrentHashMap of delays, so no duplicate work is performed. See the Concurrency chapter for a detailed explanation.\n\nBy default, the in-memory layer uses an LRU (Least Recently Used) policy — see defaults above.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cache-policies",
    "href": "pocket_book.configuration.html#cache-policies",
    "title": "3  Configuration",
    "section": "Cache policies",
    "text": "Cache policies\nSupported policies and their parameters:\n\n\n\nPolicy\nKey\nParameters\n\n\n\n\nLRU (Least Recently Used)\n:lru\n:threshold (see defaults above)\n\n\nFIFO (First In First Out)\n:fifo\n:threshold (see defaults above)\n\n\nLFU (Least Frequently Used)\n:lu\n:threshold (see defaults above)\n\n\nTTL (Time To Live)\n:ttl\n:ttl in ms (see defaults above)\n\n\nLIRS\n:lirs\n:s-history-limit, :q-history-limit\n\n\nSoft references\n:soft\n(none — uses JVM garbage collection)\n\n\nBasic (unbounded)\n:basic\n(none)\n\n\n\nConfigure via set-mem-cache-options!:\n\n(pocket/set-mem-cache-options! {:policy :fifo :threshold 100})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :fifo, :threshold 100}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :fifo, :threshold 100}\n\n\n\n\n\n{:policy :fifo, :threshold 100}\n\nOr a TTL policy where entries expire after 60 seconds:\n\n(pocket/set-mem-cache-options! {:policy :ttl :ttl 60000})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :ttl, :ttl 60000}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :ttl, :ttl 60000}\n\n\n\n\n\n{:policy :ttl, :ttl 60000}\n\nReset to the default LRU policy:\n\n(pocket/set-mem-cache-options! {:policy :lru :threshold 256})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 256}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\nEnvironment variable — POCKET_MEM_CACHE (EDN string):\nexport POCKET_MEM_CACHE='{:policy :lru :threshold 512}'\nThread-local binding (useful for tests):\n(binding [pocket/*mem-cache-options* {:policy :fifo :threshold 50}]\n  @(pocket/cached #'my-fn args))\nCaution: binding *mem-cache-options* reconfigures the shared global mem-cache, which affects all threads. This is useful for test fixtures but should be avoided in concurrent production use with different policies.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#storage-policies",
    "href": "pocket_book.configuration.html#storage-policies",
    "title": "3  Configuration",
    "section": "Storage policies",
    "text": "Storage policies\nPocket supports three storage modes, controlled by *storage*:\n\n\n\nMode\nBehavior\n\n\n\n\n:mem+disk\nIn-memory cache backed by disk persistence (default)\n\n\n:mem\nIn-memory cache only — no disk I/O\n\n\n:none\nNo shared cache — instance-local memoization only\n\n\n\n:mem is useful for cheap computations that are called many times with the same arguments. It avoids disk serialization overhead while still deduplicating concurrent access.\n:none is useful for trivially cheap functions that you want to participate in DAG identity tracking (see Recursive Caching in Pipelines) without any shared caching. Each Cached instance memoizes its own result (like a delay), but separate instances recompute.\nProgrammatically with set-storage!:\n\n(pocket/set-storage! :mem)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Storage policy set to: :mem\n\n\n\n\n\n:mem\n\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-config\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem,\n :filename-length-limit 240}\n\nPer-function via caching-fn options:\n(def fast-fn* (pocket/caching-fn #'fast-fn {:storage :mem}))\n(def identity-fn* (pocket/caching-fn #'identity-fn {:storage :none}))\nThe option map can also override :cache-dir and :mem-cache:\n(pocket/caching-fn #'f {:storage :mem+disk\n                        :cache-dir \"/data/project-cache\"\n                        :mem-cache {:policy :ttl :ttl 60000}})\nThread-local binding:\n(binding [pocket/*storage* :mem]\n  @(pocket/cached #'my-fn args))\nEnvironment variable — POCKET_STORAGE:\nexport POCKET_STORAGE=mem\nNote: :mem-only entries do not appear in cache-entries or cache-stats, which scan the disk cache. :none entries are not tracked anywhere — they exist only as in-memory Cached objects.\nReset to default:\n\n(pocket/set-storage! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Storage policy set to: nil\n\n\n\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#filename-length-limit-windows",
    "href": "pocket_book.configuration.html#filename-length-limit-windows",
    "title": "3  Configuration",
    "section": "Filename length limit (Windows)",
    "text": "Filename length limit (Windows)\nMost operating systems have a 255-character filename limit, which Pocket handles with its default threshold of 240. However, Windows has a 260-character full path limit (unless long path support is enabled). If your base cache directory is deep, the combined path may exceed this.\nWhen a cache key exceeds the configured limit, Pocket falls back to a SHA-1 hash as the directory name. The default (240) is safe for Linux and macOS, but Windows users with deep base directories may need to lower it.\nConfigure in pocket.edn:\n{:filename-length-limit 80}  ; for Windows with deep paths\nOr at runtime:\n\n(pocket/set-filename-length-limit! 80)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Filename length limit set to: 80\n\n\n\n\n\n80\n\nOr via environment variable:\nexport POCKET_FILENAME_LENGTH_LIMIT=80\nThe current limit is included in config:\n\n(:filename-length-limit (pocket/config))\n\n\n80\n\nReset to default (240):\n\n(pocket/set-filename-length-limit! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Filename length limit set to: nil\n\n\n\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#per-function-configuration-with-caching-fn",
    "href": "pocket_book.configuration.html#per-function-configuration-with-caching-fn",
    "title": "3  Configuration",
    "section": "Per-function configuration with caching-fn",
    "text": "Per-function configuration with caching-fn\nThe caching-fn wrapper accepts an optional options map. When provided, the wrapper binds the corresponding dynamic vars before calling cached. This is equivalent to wrapping the call in binding yourself:\n;; These two are equivalent:\n(def c-fn (pocket/caching-fn #'my-fn {:storage :mem}))\n\n(defn c-fn [& args]\n  (binding [pocket/*storage* :mem]\n    (apply pocket/cached #'my-fn args)))\n\nAvailable options\n\n\n\nOption\nBinds\n\n\n\n\n:storage\n*storage*\n\n\n:cache-dir\n*base-cache-dir*\n\n\n:mem-cache\n*mem-cache-options*\n\n\n:filename-length-limit\n*filename-length-limit*\n\n\n\n\n\nExample: Mixed storage policies\nA data science pipeline might use different storage for different steps:\n\n(defn load-data [path] (slurp path))\n\n\n(defn compute-stats [data] {:lines (count (clojure.string/split-lines data))})\n\n\n(defn train-model [data stats] {:model \"trained\" :stats stats})\n\nExpensive data loading — default (disk + memory):\n\n(def c-load (pocket/caching-fn #'load-data))\n\nCheap stats — memory only, no disk I/O:\n\n(def c-stats (pocket/caching-fn #'compute-stats {:storage :mem}))\n\nExpensive training — shorter filenames for Windows compatibility:\n\n(def c-train (pocket/caching-fn #'train-model {:filename-length-limit 80}))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.configuration.html#cleanup",
    "href": "pocket_book.configuration.html#cleanup",
    "title": "3  Configuration",
    "section": "Cleanup",
    "text": "Cleanup\nTo delete all cached values (both disk and in-memory), use cleanup!:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-config\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-config\", :existed false}\n\n\nsource: notebooks/pocket_book/configuration.clj",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Configuration</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html",
    "href": "pocket_book.logging.html",
    "title": "4  Logging",
    "section": "",
    "text": "Log levels\nPocket uses clojure.tools.logging for cache lifecycle messages. It does not bundle a logging backend — you provide your own (e.g., SLF4J with slf4j-simple or Logback, or Log4j2 directly). tools.logging auto-discovers a backend from the classpath; without one, logging is silently disabled.\nThis documentation was rendered using slf4j-simple as a dev dependency of the Pocket project, so the log output shown here is real.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html#log-levels",
    "href": "pocket_book.logging.html#log-levels",
    "title": "4  Logging",
    "section": "",
    "text": "Level\nMessages\n\n\n\n\n:debug\nCache hits (memory and disk), cache writes\n\n\n:info\nCache misses (computation), invalidation, mem-cache reconfiguration, cleanup",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.logging.html#setup-for-notebooks",
    "href": "pocket_book.logging.html#setup-for-notebooks",
    "title": "4  Logging",
    "section": "Setup for notebooks",
    "text": "Setup for notebooks\nThe following configures slf4j-simple for notebook use. These properties must be set before any logging occurs.\nShow debug-level messages (cache hits and writes):\n\n(System/setProperty \"org.slf4j.simpleLogger.defaultLogLevel\" \"debug\")\n\n\n\"debug\"\n\nHide thread names to reduce clutter:\n\n(System/setProperty \"org.slf4j.simpleLogger.showThreadName\" \"false\")\n\n\n\"false\"\n\nShow timestamps for each log message:\n\n(System/setProperty \"org.slf4j.simpleLogger.showDateTime\" \"true\")\n\n\n\"true\"\n\nUse hours:minutes:seconds.milliseconds format:\n\n(System/setProperty \"org.slf4j.simpleLogger.dateTimeFormat\" \"HH:mm:ss.SSS\")\n\n\n\"HH:mm:ss.SSS\"\n\nWrite to stdout so messages appear as OUT rather than ERR:\n\n(System/setProperty \"org.slf4j.simpleLogger.logFile\" \"System.out\")\n\n\n\"System.out\"\n\nIf slf4j-simple was already initialized (e.g., in a long-running REPL), the properties above won’t take effect because SimpleLogger reads them only once at class-load time. The following forces the output to stdout on the already-initialized configuration singleton:\n\n(try\n  (let [cp-field (.getDeclaredField org.slf4j.simple.SimpleLogger \"CONFIG_PARAMS\")]\n    (.setAccessible cp-field true)\n    (let [config (.get cp-field nil)\n          oc-field (.getDeclaredField (class config) \"outputChoice\")]\n      (.setAccessible oc-field true)\n      (let [sys-out (java.lang.Enum/valueOf\n                     org.slf4j.simple.OutputChoice$OutputChoiceType \"SYS_OUT\")\n            ctor (.getDeclaredConstructor\n                  org.slf4j.simple.OutputChoice\n                  (into-array Class [org.slf4j.simple.OutputChoice$OutputChoiceType]))]\n        (.setAccessible ctor true)\n        (.set oc-field config (.newInstance ctor (object-array [sys-out]))))))\n  (catch Exception _))\n\n\nnil\n\nOther notebooks in this book require this namespace to activate logging. In your own projects, configure your preferred SLF4J backend instead.\n\nsource: notebooks/pocket_book/logging.clj",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Logging</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html",
    "href": "pocket_book.recursive_caching_in_pipelines.html",
    "title": "5  Recursive Caching in Pipelines",
    "section": "",
    "text": "Setup\nWhen you pass a Cached value as an argument to another cached function, Pocket handles this recursively. The cache key for the outer computation is derived from the identity of the inner computation (its function name and arguments), not from its result. This means the entire pipeline’s cache key captures the full computation graph.\nPocket automatically derefs any Cached arguments before calling the function, so pipeline functions receive plain values and don’t need any special handling.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#setup",
    "href": "pocket_book.recursive_caching_in_pipelines.html#setup",
    "title": "5  Recursive Caching in Pipelines",
    "section": "",
    "text": "(ns pocket-book.recursive-caching-in-pipelines\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; String utilities:\n   [clojure.string :as str]))\n\n\n(def cache-dir \"/tmp/pocket-demo-pipelines\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-pipelines\n\n\n\n\n\n\"/tmp/pocket-demo-pipelines\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-pipelines\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-pipelines\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#a-three-step-pipeline",
    "href": "pocket_book.recursive_caching_in_pipelines.html#a-three-step-pipeline",
    "title": "5  Recursive Caching in Pipelines",
    "section": "A three-step pipeline",
    "text": "A three-step pipeline\nWe’ll build a simple data science pipeline with three stages: load data, preprocess it, and train a model. Each stage is wrapped with caching-fn so every call returns a Cached object. Passing one Cached result into the next stage is what makes the caching recursive.\nflowchart LR\n    LD[load-dataset] --&gt; PP[preprocess]\n    PP --&gt; TM[train-model]",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#pipeline-functions",
    "href": "pocket_book.recursive_caching_in_pipelines.html#pipeline-functions",
    "title": "5  Recursive Caching in Pipelines",
    "section": "Pipeline functions",
    "text": "Pipeline functions\n\n(defn load-dataset [path]\n  (println \"Loading dataset from\" path \"...\")\n  (Thread/sleep 300)\n  {:data [1 2 3 4 5] :source path})\n\n\n(defn preprocess [data opts]\n  (println \"Preprocessing with options:\" opts)\n  (Thread/sleep 300)\n  (update data :data #(map (fn [x] (* x (:scale opts))) %)))\n\n\n(defn train-model [data params]\n  (println \"Training model with params:\" params)\n  (Thread/sleep 300)\n  {:model :trained :accuracy 0.95 :data data})\n\nWrap each function with caching-fn so every call returns a Cached object:\n\n(def load-dataset* (pocket/caching-fn #'load-dataset))\n\n\n(def preprocess* (pocket/caching-fn #'preprocess))\n\n\n(def train-model* (pocket/caching-fn #'train-model))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#running-the-pipeline",
    "href": "pocket_book.recursive_caching_in_pipelines.html#running-the-pipeline",
    "title": "5  Recursive Caching in Pipelines",
    "section": "Running the pipeline",
    "text": "Running the pipeline\nChain cached computations in a pipeline:\nFirst pipeline run:\n\n(time\n (-&gt; \"data/raw.csv\"\n     (load-dataset*)\n     (preprocess* {:scale 2})\n     (train-model* {:epochs 100})\n     deref\n     (select-keys [:model :accuracy])))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset\nLoading dataset from data/raw.csv ...\nPreprocessing with options: {:scale 2}\nTraining model with params: {:epochs 100}\n\"Elapsed time: 907.00642 msecs\"\n\n\n\n\n\n{:model :trained, :accuracy 0.95}\n\nRun the same pipeline again — everything loads from cache:\nSecond pipeline run (all cached):\n\n(time\n (-&gt; \"data/raw.csv\"\n     (load-dataset*)\n     (preprocess* {:scale 2})\n     (train-model* {:epochs 100})\n     deref\n     (select-keys [:model :accuracy])))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.603593 msecs\"\n\n\n\n\n\n{:model :trained, :accuracy 0.95}\n\nNo log output above — the result was served entirely from the in-memory cache, so no disk I/O or computation occurred. Each step caches independently. If you change only the last step (e.g., different training params), the upstream steps load from cache while only the final step recomputes.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#provenance-in-cache-entries",
    "href": "pocket_book.recursive_caching_in_pipelines.html#provenance-in-cache-entries",
    "title": "5  Recursive Caching in Pipelines",
    "section": "Provenance in cache entries",
    "text": "Provenance in cache entries\nThe cache entries reveal the pipeline structure. Each entry’s identity encodes its full computation history — not just the function name, but the nested identities of all its cached inputs.\n\n(-&gt;&gt; (pocket/cache-entries)\n     (mapv :id))\n\n\n[\"(pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\")\"\n \"(pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\") {:scale 2})\"\n \"(pocket-book.recursive-caching-in-pipelines/train-model (pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \\\"data/raw.csv\\\") {:scale 2}) {:epochs 100})\"]\n\n\n(-&gt;&gt; (pocket/cache-entries)\n     (mapv :id)\n     (str/join \"\\n\")\n     kind/code)\n\n\n(pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\")\n(pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\") {:scale 2})\n(pocket-book.recursive-caching-in-pipelines/train-model (pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\") {:scale 2}) {:epochs 100})\n\nThe inner step appears as a literal sub-expression in the outer step’s identity. This is how Pocket tracks provenance: the cache key for train-model records that its input came from preprocess, which in turn came from load-dataset.\nThis happens automatically when you pass Cached objects (without derefing) from one cached step to the next. If you deref early with @ (or deref), the downstream step sees a plain value and the provenance link is lost — the cache key is based on the value’s hash instead. Both patterns work; the choice is whether you need traceability.\nFor a fuller example with branching dependencies, see the Real-World Walkthrough.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#inspecting-the-dag",
    "href": "pocket_book.recursive_caching_in_pipelines.html#inspecting-the-dag",
    "title": "5  Recursive Caching in Pipelines",
    "section": "Inspecting the DAG",
    "text": "Inspecting the DAG\nPocket provides three functions for DAG introspection:\n\norigin-story — nested tree with :ref pointers for shared nodes\norigin-story-graph — flat {:nodes ... :edges ...} for graph algorithms\norigin-story-mermaid — Mermaid flowchart string for visualization\n\nBuild the pipeline keeping the intermediate Cached objects:\n\n(def data-c (load-dataset* \"data/experiment.csv\"))\n\n\n(def preprocessed-c (preprocess* data-c {:scale 2}))\n\n\n(def model-c (train-model* preprocessed-c {:epochs 100}))\n\n\norigin-story — tree structure\nReturns a nested map where each cached step is {:fn &lt;var&gt; :args [...] :id &lt;string&gt;}. Plain arguments become {:value ...} leaves. If a step has been computed, :value is included.\nBefore any computation:\n\n(pocket/origin-story model-c)\n\n\n{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n :args\n [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :args\n   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n     :args [{:value \"data/experiment.csv\"}],\n     :id \"c3\"}\n    {:value {:scale 2}}],\n   :id \"c2\"}\n  {:value {:epochs 100}}],\n :id \"c1\"}\n\nNo :value keys yet. Now trigger computation:\n\n(deref model-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset\nLoading dataset from data/experiment.csv ...\nPreprocessing with options: {:scale 2}\nTraining model with params: {:epochs 100}\n\n\n\n\n\n{:model :trained,\n :accuracy 0.95,\n :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}\n\nAfter deref, every node includes its :value:\n\n(pocket/origin-story model-c)\n\n\n{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n :args\n [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :args\n   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n     :args [{:value \"data/experiment.csv\"}],\n     :id \"c3\",\n     :value {:data [1 2 3 4 5], :source \"data/experiment.csv\"}}\n    {:value {:scale 2}}],\n   :id \"c2\",\n   :value {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}\n  {:value {:epochs 100}}],\n :id \"c1\",\n :value\n {:model :trained,\n  :accuracy 0.95,\n  :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}}\n\nWhen the same Cached instance appears multiple times (diamond pattern), subsequent occurrences are {:ref &lt;id&gt;} pointing to the first.\n\n\norigin-story-graph — flat graph\nReturns {:nodes {&lt;id&gt; &lt;node-map&gt;} :edges [[&lt;from&gt; &lt;to&gt;] ...]}. Useful for graph algorithms or custom rendering.\n\n(pocket/origin-story-graph model-c)\n\n\n{:nodes\n {\"c1\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/train-model,\n   :value\n   {:model :trained,\n    :accuracy 0.95,\n    :data {:data (2 4 6 8 10), :source \"data/experiment.csv\"}}},\n  \"c2\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,\n   :value {:data (2 4 6 8 10), :source \"data/experiment.csv\"}},\n  \"c3\"\n  {:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,\n   :value {:data [1 2 3 4 5], :source \"data/experiment.csv\"}},\n  \"v4\" {:value \"data/experiment.csv\"},\n  \"v5\" {:value {:scale 2}},\n  \"v6\" {:value {:epochs 100}}},\n :edges [[\"c1\" \"c2\"] [\"c2\" \"c3\"] [\"c3\" \"v4\"] [\"c2\" \"v5\"] [\"c1\" \"v6\"]]}\n\n\n\norigin-story-mermaid — visualization\nReturns a Mermaid flowchart string. Arrows show data flow direction (from inputs toward the final result). It returns a kindly value that renders directly.\n\n(pocket/origin-story-mermaid model-c)\n\nflowchart TD\n  n0[\"train-model\"]\n  n1[\"preprocess\"]\n  n2[\"load-dataset\"]\n  n3[/\"'data/experiment.csv'\"/]\n  n3 --&gt; n2\n  n2 --&gt; n1\n  n4[/\"{:scale 2}\"/]\n  n4 --&gt; n1\n  n1 --&gt; n0\n  n5[/\"{:epochs 100}\"/]\n  n5 --&gt; n0",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.recursive_caching_in_pipelines.html#cleanup",
    "href": "pocket_book.recursive_caching_in_pipelines.html#cleanup",
    "title": "5  Recursive Caching in Pipelines",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-pipelines\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-pipelines\", :existed true}\n\n\nsource: notebooks/pocket_book/recursive_caching_in_pipelines.clj",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Recursive Caching in Pipelines</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html",
    "href": "pocket_book.usage_practices.html",
    "title": "6  Usage Practices",
    "section": "",
    "text": "Setup\nThis chapter expands on the basics from Getting Started with practical patterns for day-to-day work: function identity in depth, cache invalidation strategies, testing, REPL introspection, serialization constraints, and debugging tips.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#setup",
    "href": "pocket_book.usage_practices.html#setup",
    "title": "6  Usage Practices",
    "section": "",
    "text": "(ns pocket-book.usage-practices\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]))\n\n\n(def test-dir \"/tmp/pocket-dev-practices\")\n\n\n(pocket/set-base-cache-dir! test-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-dev-practices\n\n\n\n\n\n\"/tmp/pocket-dev-practices\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#when-to-use-pocket",
    "href": "pocket_book.usage_practices.html#when-to-use-pocket",
    "title": "6  Usage Practices",
    "section": "When to Use Pocket",
    "text": "When to Use Pocket\n\nGood use cases\n\nData science pipelines with expensive intermediate steps (data loading, preprocessing, feature engineering, model training)\nReproducible research where cached intermediate results let you iterate on downstream steps without re-running upstream computations\nLong-running computations (minutes to hours) that need to survive JVM restarts, crashes, or machine reboots\nMulti-threaded workflows where multiple threads may request the same expensive computation — Pocket ensures it runs only once\n\n\n\nComparison to alternatives\n\n\n\nFeature\nPocket\nclojure.core/memoize\ncore.memoize\n\n\n\n\nPersistence\nDisk + memory\nMemory only\nMemory only\n\n\nCross-session\nYes\nNo\nNo\n\n\nLazy evaluation\nIDeref\nEager\nEager\n\n\nEviction policies\nLRU, FIFO, TTL, etc.\nNone\nLRU, TTL, etc.\n\n\nThread-safe (single computation)\nYes\nNo\nYes\n\n\nPipeline caching\nYes (recursive)\nNo\nNo",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#function-identity-use-vars-or-keywords",
    "href": "pocket_book.usage_practices.html#function-identity-use-vars-or-keywords",
    "title": "6  Usage Practices",
    "section": "Function Identity: Use Vars or Keywords",
    "text": "Function Identity: Use Vars or Keywords\nPocket requires functions to be passed as vars (#'fn-name) or keywords (e.g., :train), not as bare function objects.\n;; ❌ WRONG - bare function, unstable identity\n(pocket/cached my-expensive-fn arg1 arg2)\n\n;; ✅ CORRECT - var, stable identity\n(pocket/cached #'my-expensive-fn arg1 arg2)\n\n;; ✅ CORRECT - keyword, stable identity\n(pocket/cached :train cached-split)\nWhy? Function objects have different identity across JVM sessions, making cache keys unpredictable. Vars provide stable symbol names that survive restarts. Keywords are inherently stable and work naturally as map accessors on cached values.\nPocket validates this and throws a clear error if you forget:\n\n(defn example-fn [x] (* x x))\n\n\n(try\n  (pocket/cached example-fn 5)\n  (catch Exception e\n    (ex-message e)))\n\n\n\"pocket/cached requires a var or keyword (e.g., #'my-fn or :my-key), got: class pocket_book.usage_practices$example_fn\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#cache-invalidation-strategies",
    "href": "pocket_book.usage_practices.html#cache-invalidation-strategies",
    "title": "6  Usage Practices",
    "section": "Cache Invalidation Strategies",
    "text": "Cache Invalidation Strategies\nPocket does not automatically detect when a function’s implementation changes. You must invalidate manually. Here are the strategies:\n\nStrategy 1: Manual Invalidation\nUse invalidate! for specific entries or invalidate-fn! for all entries of a function:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed false}\n\n\n(defn transform [x] (* x 2))\n\nCache a computation:\n\n(deref (pocket/cached #'transform 10))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n20\n\nFunction implementation changed — invalidate a single entry:\n\n(pocket/invalidate! #'transform 10)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-dev-practices/1c/(pocket-book.usage-practices_transform 10) existed= true\n\n\n\n\n\n{:path\n \"/tmp/pocket-dev-practices/1c/(pocket-book.usage-practices_transform 10)\",\n :existed true}\n\nOr invalidate all entries for a function:\n\n(deref (pocket/cached #'transform 1))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n2\n\n\n(deref (pocket/cached #'transform 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n4\n\n\n(pocket/invalidate-fn! #'transform)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Invalidated 2 entries for pocket-book.usage-practices/transform\n\n\n\n\n\n{:fn-name \"pocket-book.usage-practices/transform\",\n :count 2,\n :paths\n [\"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\"\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\"]}\n\n\n\nStrategy 2: Versioning Pattern\nAdd a version key to your function’s input. Bumping the version creates new cache entries while preserving old ones for comparison:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn process-data [{:keys [data version]}]\n  {:result (reduce + data)\n   :version version})\n\nVersion 1:\n\n(deref (pocket/cached #'process-data {:data [1 2 3] :version 1}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-data\n\n\n\n\n\n{:result 6, :version 1}\n\nAfter changing the function, bump version:\n\n(deref (pocket/cached #'process-data {:data [1 2 3] :version 2}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-data\n\n\n\n\n\n{:result 6, :version 2}\n\nBoth versions coexist in cache — useful for A/B comparison.\n\n\nStrategy 3: Full Cleanup\nFor a fresh start, use cleanup! to delete the entire cache:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#testing-with-pocket",
    "href": "pocket_book.usage_practices.html#testing-with-pocket",
    "title": "6  Usage Practices",
    "section": "Testing with Pocket",
    "text": "Testing with Pocket\nTests should be isolated from production caches and from each other. Use binding and cleanup fixtures:\n\nTest Fixture Pattern\n(def test-cache-dir \"/tmp/my-project-test-cache\")\n\n(defn cleanup-fixture [f]\n  (binding [pocket/*base-cache-dir* test-cache-dir]\n    (pocket/cleanup!)\n    (try\n      (f)\n      (finally\n        (pocket/cleanup!)))))\n\n(use-fixtures :each cleanup-fixture)\nThis ensures: 1. Tests use a separate cache directory 2. Cache is cleared before and after each test 3. Tests don’t affect each other\n\n\nVerifying Cache Behavior\nUse an atom to track computation calls:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed false}\n\n\n(def call-count (atom 0))\n\n\n(defn tracked-fn [x]\n  (swap! call-count inc)\n  (* x x))\n\nFirst call computes:\n\n(reset! call-count 0)\n\n\n0\n\n\n(let [result (deref (pocket/cached #'tracked-fn 5))\n      calls @call-count]\n  {:result result :calls calls})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/tracked-fn\n\n\n\n\n\n{:result 25, :calls 1}\n\nSecond call uses cache (no additional computation):\n\n(let [result (deref (pocket/cached #'tracked-fn 5))\n      calls @call-count]\n  {:result result :calls calls})\n\n\n{:result 25, :calls 1}",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#repl-development-workflow",
    "href": "pocket_book.usage_practices.html#repl-development-workflow",
    "title": "6  Usage Practices",
    "section": "REPL Development Workflow",
    "text": "REPL Development Workflow\n\nInspecting the Cache\nUse introspection functions to understand cache state:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(deref (pocket/cached #'transform 1))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n2\n\n\n(deref (pocket/cached #'transform 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n4\n\n\n(deref (pocket/cached #'tracked-fn 3))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/tracked-fn\n\n\n\n\n\n9\n\nSee all cached entries:\n\n(count (pocket/cache-entries))\n\n\n3\n\nGet aggregate statistics:\n\n(:total-entries (pocket/cache-stats))\n\n\n3\n\nVisualize cache structure:\n\n(pocket/dir-tree)\n\n\npocket-dev-practices\n├── db\n│   └── (pocket-book.usage-practices_transform 1)\n│       ├── meta.edn\n│       └── value.nippy\n├── e4\n│   └── (pocket-book.usage-practices_transform 2)\n│       ├── meta.edn\n│       └── value.nippy\n└── e8\n    └── (pocket-book.usage-practices_tracked-fn 3)\n        ├── meta.edn\n        └── value.nippy\n\nEach directory contains a meta.edn file with metadata about the cached computation:\n\n(-&gt; (pocket/cache-entries)\n    first\n    :path\n    (str \"/meta.edn\")\n    slurp\n    clojure.edn/read-string)\n\n\n{:id \"(pocket-book.usage-practices/transform 1)\",\n :fn-name \"pocket-book.usage-practices/transform\",\n :args-str \"[1]\",\n :created-at \"2026-02-08T00:27:25.237309002Z\"}\n\nThis same information is available through the API:\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\",\n  :id \"(pocket-book.usage-practices/transform 1)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[1]\",\n  :created-at \"2026-02-08T00:27:25.237309002Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\",\n  :id \"(pocket-book.usage-practices/transform 2)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[2]\",\n  :created-at \"2026-02-08T00:27:25.238209212Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e8/(pocket-book.usage-practices_tracked-fn 3)\",\n  :id \"(pocket-book.usage-practices/tracked-fn 3)\",\n  :fn-name \"pocket-book.usage-practices/tracked-fn\",\n  :args-str \"[3]\",\n  :created-at \"2026-02-08T00:27:25.239040958Z\"}]\n\nFilter entries by function name:\n\n(pocket/cache-entries (str (ns-name *ns*) \"/transform\"))\n\n\n[{:path\n  \"/tmp/pocket-dev-practices/db/(pocket-book.usage-practices_transform 1)\",\n  :id \"(pocket-book.usage-practices/transform 1)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[1]\",\n  :created-at \"2026-02-08T00:27:25.237309002Z\"}\n {:path\n  \"/tmp/pocket-dev-practices/e4/(pocket-book.usage-practices_transform 2)\",\n  :id \"(pocket-book.usage-practices/transform 2)\",\n  :fn-name \"pocket-book.usage-practices/transform\",\n  :args-str \"[2]\",\n  :created-at \"2026-02-08T00:27:25.238209212Z\"}]\n\n\n\nChecking Cached Status\nCached values print their status without forcing computation:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(def pending-value (pocket/cached #'transform 99))\n\nBefore deref:\n\n(pr-str pending-value)\n\n\n\"#&lt;Cached (pocket-book.usage-practices/transform 99) :pending&gt;\"\n\n\n(deref pending-value)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/transform\n\n\n\n\n\n198\n\nAfter deref:\n\n(pr-str pending-value)\n\n\n\"#&lt;Cached (pocket-book.usage-practices/transform 99) :cached&gt;\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#debugging-with-logging",
    "href": "pocket_book.usage_practices.html#debugging-with-logging",
    "title": "6  Usage Practices",
    "section": "Debugging with Logging",
    "text": "Debugging with Logging\nEnable debug logging to see cache hits, misses, and writes. See the Logging chapter for setup.\nWith debug logging enabled, you’ll see:\n\nCache miss, computing: ... — computation triggered\nCache hit (memory): ... — served from in-memory cache\nCache hit (disk): ... — loaded from disk\nCache write: ... — written to disk",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#long-cache-keys",
    "href": "pocket_book.usage_practices.html#long-cache-keys",
    "title": "6  Usage Practices",
    "section": "Long Cache Keys",
    "text": "Long Cache Keys\nWhen a cache key string exceeds 240 characters, Pocket falls back to using a SHA-1 hash as the directory name. This ensures the filesystem can handle arbitrarily complex arguments while maintaining correct caching behavior.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn process-long-text [text]\n  (str \"Processed: \" (count text) \" chars\"))\n\n\n(def long-text (apply str (repeat 300 \"x\")))\n\n\n(deref (pocket/cached #'process-long-text long-text))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/process-long-text\n\n\n\n\n\n\"Processed: 300 chars\"\n\nThe entry is stored with a hash-based directory name:\n\n(pocket/dir-tree)\n\n\npocket-dev-practices\n└── 6d\n    └── 6d7a9c06574c78354a8235a2e77b6ed27348e404\n        ├── meta.edn\n        └── value.nippy\n\nBut meta.edn inside still contains the full details, so cache-entries and invalidate-fn! work correctly:\n\n(-&gt; (pocket/cache-entries (str (ns-name *ns*) \"/process-long-text\"))\n    first\n    :fn-name)\n\n\n\"pocket-book.usage-practices/process-long-text\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#serialization-constraints",
    "href": "pocket_book.usage_practices.html#serialization-constraints",
    "title": "6  Usage Practices",
    "section": "Serialization Constraints",
    "text": "Serialization Constraints\nPocket uses Nippy for serialization. Most Clojure data structures work, but some don’t:\n\n✅ Safe to Cache\n\nPrimitive types (numbers, strings, keywords, symbols)\nCollections (vectors, maps, sets, lists)\nRecords and most deftypes\nJava Serializable objects\n\n\n\n⚠️ Requires Care\n\nLazy sequences — Nippy fully realizes them during serialization, which means infinite lazy seqs will hang or OOM. Force lazy seqs with doall inside your function (see below) to keep realization explicit and catch errors early. The round-trip type may also change (a LazySeq comes back as a regular seq).\n\n\n\n❌ Cannot Cache\n\nOpen file handles, streams\nNetwork connections, sockets\nFunctions, closures (use vars instead)\nAtoms, refs, agents (stateful references)\n\n\n\nLazy Sequences\nUse doall or vec to force evaluation inside your function:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\n(defn generate-data [n]\n  ;; doall forces full evaluation of the lazy sequence\n  (doall (range n)))\n\n\n(deref (pocket/cached #'generate-data 5))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.usage-practices/generate-data\n\n\n\n\n\n(0 1 2 3 4)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#known-limitations",
    "href": "pocket_book.usage_practices.html#known-limitations",
    "title": "6  Usage Practices",
    "section": "Known Limitations",
    "text": "Known Limitations\n\nNo automatic cache invalidation — Pocket doesn’t detect when a function’s implementation changes. Use invalidate!, invalidate-fn!, or the versioning pattern described above.\nRequires serializable values — Nippy handles most Clojure types, but you can’t cache functions, atoms, channels, file handles, or other stateful objects.\nDisk cache grows indefinitely — The in-memory cache supports eviction policies (LRU, TTL, etc.), but the disk cache has no automatic cleanup. Use cleanup! or invalidate-fn! periodically if disk space is a concern.\nNo disk cache TTL — Cached values on disk never expire automatically. If you need time-based expiration, you’ll need to manage it externally or use cleanup!.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.usage_practices.html#summary",
    "href": "pocket_book.usage_practices.html#summary",
    "title": "6  Usage Practices",
    "section": "Summary",
    "text": "Summary\n\n\n\nPractice\nRecommendation\n\n\n\n\nFunction identity\nAlways use vars (#'fn-name)\n\n\nInvalidation\nManual, versioning, or full cleanup\n\n\nTesting\nUse binding + cleanup fixtures\n\n\nDebugging\nEnable logging, use introspection\n\n\nLong cache keys\nAuto-handled with SHA-1 fallback\n\n\nSerialization\nAvoid stateful objects; force lazy seqs with doall\n\n\nConfiguration\nUse pocket.edn — see Configuration\n\n\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-dev-practices\n\n\n\n\n\n{:dir \"/tmp/pocket-dev-practices\", :existed true}\n\n\nsource: notebooks/pocket_book/usage_practices.clj",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Usage Practices</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html",
    "href": "pocket_book.real_world_walkthrough.html",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "",
    "text": "Overview\nThis walkthrough demonstrates a realistic data pipeline with multiple stages and branching dependencies. We’ll simulate a weather analysis workflow where raw sensor readings are cleaned, then fed into two independent analyses — one for temperature trends and one for rainfall totals. Both analyses share the same cleaned data, so Pocket caches it once and reuses it.\nThis builds on the concepts from Recursive Caching in Pipelines, adding branching dependencies where two analyses share a common upstream computation.\nThe dependency graph: fetch-readings → clean-data → both temperature-trends and rainfall-totals → summary.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#overview",
    "href": "pocket_book.real_world_walkthrough.html#overview",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "",
    "text": "flowchart TD\n    FR[fetch-readings] --&gt; CD[clean-data]\n    CD --&gt; TT[temperature-trends]\n    CD --&gt; RT[rainfall-totals]\n    TT --&gt; S[summary]\n    RT --&gt; S",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#setup",
    "href": "pocket_book.real_world_walkthrough.html#setup",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Setup",
    "text": "Setup\n\n(ns pocket-book.real-world-walkthrough\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Filesystem utilities:\n   [babashka.fs :as fs]))\n\n\n(def cache-dir \"/tmp/pocket-walkthrough\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-walkthrough\n\n\n\n\n\n\"/tmp/pocket-walkthrough\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-walkthrough\n\n\n\n\n\n{:dir \"/tmp/pocket-walkthrough\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#pipeline-functions",
    "href": "pocket_book.real_world_walkthrough.html#pipeline-functions",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Pipeline functions",
    "text": "Pipeline functions\nEach function simulates real work with a short delay. Note that these are plain Clojure functions — they know nothing about caching.\n\n(defn fetch-readings\n  \"Simulate fetching raw sensor data for a city.\"\n  [opts]\n  (println \"  Fetching readings for\" (:city opts) \"...\")\n  (Thread/sleep 300)\n  {:city (:city opts)\n   :source (:source opts)\n   :readings (case (:city opts)\n               \"Paris\"\n               [{:day 1 :temp-c 15.0 :rain-mm 2.1}\n                {:day 2 :temp-c 17.3 :rain-mm 0.0}\n                {:day 3 :temp-c 14.6 :rain-mm 7.8}\n                {:day 4 :temp-c 18.1 :rain-mm 0.0}\n                {:day 5 :temp-c 13.9 :rain-mm 4.5}\n                {:day 6 :temp-c 16.7 :rain-mm 0.0}\n                {:day 7 :temp-c 19.2 :rain-mm 1.0}]\n               ;; default (London, etc.)\n               [{:day 1 :temp-c 18.2 :rain-mm 0.0}\n                {:day 2 :temp-c 21.5 :rain-mm 5.2}\n                {:day 3 :temp-c 19.8 :rain-mm 12.1}\n                {:day 4 :temp-c 22.0 :rain-mm 0.0}\n                {:day 5 :temp-c 16.3 :rain-mm 8.4}\n                {:day 6 :temp-c 20.1 :rain-mm 0.0}\n                {:day 7 :temp-c 23.7 :rain-mm 3.3}])})\n\n\n(defn clean-data\n  \"Remove readings with missing values and round numbers.\"\n  [raw-data opts]\n  (println \"  Cleaning data for\" (:city raw-data) \"with\" opts \"...\")\n  (Thread/sleep 200)\n  (let [precision (:precision opts 10)]\n    (update raw-data :readings\n            (fn [rs]\n              (-&gt;&gt; rs\n                   (filter #(and (:temp-c %) (:rain-mm %)))\n                   (mapv #(-&gt; %\n                              (update :temp-c (fn [t] (Math/round (* t (double precision)))))\n                              (update :rain-mm (fn [r] (Math/round (* r (double precision))))))))))))\n\n\n(defn temperature-trends\n  \"Compute temperature statistics from cleaned data.\"\n  [clean-data opts]\n  (println \"  Analyzing temperature for\" (:city clean-data) \"...\")\n  (Thread/sleep 300)\n  (let [temps (map :temp-c (:readings clean-data))\n        n (count temps)]\n    {:city (:city clean-data)\n     :unit (:unit opts)\n     :min-temp (apply min temps)\n     :max-temp (apply max temps)\n     :mean-temp (quot (reduce + temps) n)\n     :days n}))\n\n\n(defn rainfall-totals\n  \"Compute rainfall statistics from cleaned data.\"\n  [clean-data opts]\n  (println \"  Analyzing rainfall for\" (:city clean-data) \"...\")\n  (Thread/sleep 300)\n  (let [rains (map :rain-mm (:readings clean-data))\n        rainy-days (count (filter pos? rains))]\n    {:city (:city clean-data)\n     :unit (:unit opts)\n     :total-rain (reduce + rains)\n     :rainy-days rainy-days\n     :dry-days (- (count rains) rainy-days)}))\n\n\n(defn summary\n  \"Combine temperature and rainfall analyses into a report.\"\n  [temp-analysis rain-analysis]\n  (println \"  Generating summary for\" (:city temp-analysis) \"...\")\n  (Thread/sleep 200)\n  (merge temp-analysis rain-analysis\n         {:report (str (:city temp-analysis)\n                       \": temp range \"\n                       (:min-temp temp-analysis) \"–\"\n                       (:max-temp temp-analysis)\n                       \", total rain \"\n                       (:total-rain rain-analysis)\n                       \" over \" (:rainy-days rain-analysis) \" days\")}))",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#first-run-everything-computes",
    "href": "pocket_book.real_world_walkthrough.html#first-run-everything-computes",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "First run: everything computes",
    "text": "First run: everything computes\nWe build the pipeline using cached. Each call returns a Cached object that we pass directly to the next stage. Pocket derives cache keys from the computation graph, not from intermediate values.\n\n(println \"=== First run ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n=== First run ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"London\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/summary\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/temperature-trends\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/clean-data\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/fetch-readings\n  Fetching readings for London ...\n  Cleaning data for London with {:precision 10, :remove-nulls true} ...\n  Analyzing temperature for London ...\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/rainfall-totals\n  Analyzing rainfall for London ...\n  Generating summary for London ...\n\"Elapsed time: 1312.262623 msecs\"\n\n\n\n\n\n{:report \"London: temp range 163–237, total rain 290 over 4 days\",\n :max-temp 237,\n :dry-days 3,\n :unit :mm,\n :city \"London\",\n :days 7,\n :total-rain 290,\n :rainy-days 4,\n :mean-temp 202,\n :min-temp 163}\n\nEvery function ran. Notice the log messages showing cache misses, computations, and writes.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#second-run-everything-from-cache",
    "href": "pocket_book.real_world_walkthrough.html#second-run-everything-from-cache",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Second run: everything from cache",
    "text": "Second run: everything from cache\nRunning the exact same pipeline again — nothing recomputes:\n\n(println \"\\n=== Second run (fully cached) ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Second run (fully cached) ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"London\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.234786 msecs\"\n\n\n\n\n\n{:report \"London: temp range 163–237, total rain 290 over 4 days\",\n :max-temp 237,\n :dry-days 3,\n :unit :mm,\n :city \"London\",\n :days 7,\n :total-rain 290,\n :rainy-days 4,\n :mean-temp 202,\n :min-temp 163}\n\nNo log output — served entirely from the in-memory cache.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#changing-an-upstream-input",
    "href": "pocket_book.real_world_walkthrough.html#changing-an-upstream-input",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Changing an upstream input",
    "text": "Changing an upstream input\nNow suppose we want a different city. The entire pipeline recomputes because the root input changed:\n\n(println \"\\n=== Different city ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Different city ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"Paris\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/summary\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/temperature-trends\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/clean-data\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/fetch-readings\n  Fetching readings for Paris ...\n  Cleaning data for Paris with {:precision 10, :remove-nulls true} ...\n  Analyzing temperature for Paris ...\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.real-world-walkthrough/rainfall-totals\n  Analyzing rainfall for Paris ...\n  Generating summary for Paris ...\n\"Elapsed time: 1319.415636 msecs\"\n\n\n\n\n\n{:report \"Paris: temp range 139–192, total rain 154 over 4 days\",\n :max-temp 192,\n :dry-days 3,\n :unit :mm,\n :city \"Paris\",\n :days 7,\n :total-rain 154,\n :rainy-days 4,\n :mean-temp 164,\n :min-temp 139}\n\nBut running it again is instant — Paris is now cached too:\n\n(println \"\\n=== Paris again (cached) ===\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\n=== Paris again (cached) ===\n\n\n\n\n\nnil\n\n\n(let [raw (pocket/cached #'fetch-readings {:city \"Paris\" :days 7 :source :api})\n      clean (pocket/cached #'clean-data raw {:precision 10 :remove-nulls true})\n      temps (pocket/cached #'temperature-trends clean {:unit :celsius})\n      rain (pocket/cached #'rainfall-totals clean {:unit :mm})\n      report (pocket/cached #'summary temps rain)]\n  (time (deref report)))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n\"Elapsed time: 0.240278 msecs\"\n\n\n\n\n\n{:report \"Paris: temp range 139–192, total rain 154 over 4 days\",\n :max-temp 192,\n :dry-days 3,\n :unit :mm,\n :city \"Paris\",\n :days 7,\n :total-rain 154,\n :rainy-days 4,\n :mean-temp 164,\n :min-temp 139}\n\nNo log output — served entirely from the in-memory cache.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#inspecting-the-cache-on-disk",
    "href": "pocket_book.real_world_walkthrough.html#inspecting-the-cache-on-disk",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Inspecting the cache on disk",
    "text": "Inspecting the cache on disk\nLet’s look at what Pocket stored. The cache directory is organized by a SHA-1 prefix, then a human-readable directory named after the function and arguments.\n\nCache entries\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-walkthrough/17/17db4a12cb5e1ba8da076b6148be68b333bc6a16\",\n  :id\n  \"(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius})\",\n  :fn-name \"pocket-book.real-world-walkthrough/temperature-trends\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}]\",\n  :created-at \"2026-02-08T00:27:26.156514668Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/be/be026e38b57ab3e7ce5623eff753a616df974e93\",\n  :id\n  \"(pocket-book.real-world-walkthrough/summary (pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}))\",\n  :fn-name \"pocket-book.real-world-walkthrough/summary\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})]\",\n  :created-at \"2026-02-08T00:27:27.992800702Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/2c/(pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :fn-name \"pocket-book.real-world-walkthrough/clean-data\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}]\",\n  :created-at \"2026-02-08T00:27:25.854183666Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/6d/(pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :fn-name \"pocket-book.real-world-walkthrough/rainfall-totals\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}]\",\n  :created-at \"2026-02-08T00:27:27.791294490Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/50/50a0ffd14b1b8fa3a7ba7a1fa3d75cf5b26f0c57\",\n  :id\n  \"(pocket-book.real-world-walkthrough/summary (pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}))\",\n  :fn-name \"pocket-book.real-world-walkthrough/summary\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}) (pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})]\",\n  :created-at \"2026-02-08T00:27:26.660856828Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/36/(pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\",\n  :fn-name \"pocket-book.real-world-walkthrough/clean-data\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}]\",\n  :created-at \"2026-02-08T00:27:27.187728688Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/49/(pocket-book.real-world-walkthrough_fetch-readings {:city \\\"Paris\\\", :days 7, :source :api})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api})\",\n  :fn-name \"pocket-book.real-world-walkthrough/fetch-readings\",\n  :args-str \"[{:city \\\"Paris\\\", :days 7, :source :api}]\",\n  :created-at \"2026-02-08T00:27:26.985497495Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/29/(pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api})\",\n  :fn-name \"pocket-book.real-world-walkthrough/fetch-readings\",\n  :args-str \"[{:city \\\"London\\\", :days 7, :source :api}]\",\n  :created-at \"2026-02-08T00:27:25.650996970Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/a4/(pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :id\n  \"(pocket-book.real-world-walkthrough/rainfall-totals (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\",\n  :fn-name \"pocket-book.real-world-walkthrough/rainfall-totals\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"London\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm}]\",\n  :created-at \"2026-02-08T00:27:26.459013691Z\"}\n {:path\n  \"/tmp/pocket-walkthrough/4d/4d7d654476f96c5a4808c863dd3c29e845d4a9f6\",\n  :id\n  \"(pocket-book.real-world-walkthrough/temperature-trends (pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius})\",\n  :fn-name \"pocket-book.real-world-walkthrough/temperature-trends\",\n  :args-str\n  \"[(pocket-book.real-world-walkthrough/clean-data (pocket-book.real-world-walkthrough/fetch-readings {:city \\\"Paris\\\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :celsius}]\",\n  :created-at \"2026-02-08T00:27:27.489345457Z\"}]\n\n\n\nCache statistics\n\n(pocket/cache-stats)\n\n\n{:total-entries 10,\n :total-size-bytes 16707,\n :entries-per-fn\n {\"pocket-book.real-world-walkthrough/temperature-trends\" 2,\n  \"pocket-book.real-world-walkthrough/summary\" 2,\n  \"pocket-book.real-world-walkthrough/clean-data\" 2,\n  \"pocket-book.real-world-walkthrough/rainfall-totals\" 2,\n  \"pocket-book.real-world-walkthrough/fetch-readings\" 2}}\n\n\n\nDirectory tree\nEach entry contains either a value.nippy file (serialized value) or a nil marker, plus a meta.edn with metadata. Here is the actual cache directory tree, generated dynamically.\nNotice that some entries use human-readable directory names while others fall back to SHA-1 hashes — this happens when the cache key (which includes the full upstream computation chain) exceeds 240 characters. The meta.edn inside each entry always contains the full details.\n\n(pocket/dir-tree)\n\n\npocket-walkthrough\n├── 17\n│   └── 17db4a12cb5e1ba8da076b6148be68b333bc6a16\n│       ├── meta.edn\n│       └── value.nippy\n├── 29\n│   └── (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api})\n│       ├── meta.edn\n│       └── value.nippy\n├── 2c\n│   └── (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\n│       ├── meta.edn\n│       └── value.nippy\n├── 36\n│   └── (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api}) {:precision 10, :remove-nulls true})\n│       ├── meta.edn\n│       └── value.nippy\n├── 49\n│   └── (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api})\n│       ├── meta.edn\n│       └── value.nippy\n├── 4d\n│   └── 4d7d654476f96c5a4808c863dd3c29e845d4a9f6\n│       ├── meta.edn\n│       └── value.nippy\n├── 50\n│   └── 50a0ffd14b1b8fa3a7ba7a1fa3d75cf5b26f0c57\n│       ├── meta.edn\n│       └── value.nippy\n├── 6d\n│   └── (pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"Paris\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\n│       ├── meta.edn\n│       └── value.nippy\n├── a4\n│   └── (pocket-book.real-world-walkthrough_rainfall-totals (pocket-book.real-world-walkthrough_clean-data (pocket-book.real-world-walkthrough_fetch-readings {:city \"London\", :days 7, :source :api}) {:precision 10, :remove-nulls true}) {:unit :mm})\n│       ├── meta.edn\n│       └── value.nippy\n└── be\n    └── be026e38b57ab3e7ce5623eff753a616df974e93\n        ├── meta.edn\n        └── value.nippy",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.real_world_walkthrough.html#cleanup",
    "href": "pocket_book.real_world_walkthrough.html#cleanup",
    "title": "7  Real-World Walkthrough: Weather Analysis Pipeline",
    "section": "Cleanup",
    "text": "Cleanup\nRemove all cached data:\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-walkthrough\n\n\n\n\n\n{:dir \"/tmp/pocket-walkthrough\", :existed true}\n\n\nsource: notebooks/pocket_book/real_world_walkthrough.clj",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Real-World Walkthrough: Weather Analysis Pipeline</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html",
    "href": "pocket_book.concurrency.html",
    "title": "8  Concurrency",
    "section": "",
    "text": "The Challenge\nPocket guarantees that when multiple threads deref the same Cached value concurrently, the underlying computation executes exactly once. This chapter explains how that guarantee is achieved and demonstrates the concurrency scenarios it handles.\nThe naive approach to caching — check if cached, compute if not — has a race condition:\nBoth threads see the cache miss and both compute the value. For expensive computations (minutes, hours), this wastes resources.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#the-challenge",
    "href": "pocket_book.concurrency.html#the-challenge",
    "title": "8  Concurrency",
    "section": "",
    "text": "Thread A                    Thread B\n────────                    ────────\ncheck cache → miss          check cache → miss\ncompute value               compute value     ← duplicate!\nstore result                store result",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#why-core.cache-alone-is-not-enough",
    "href": "pocket_book.concurrency.html#why-core.cache-alone-is-not-enough",
    "title": "8  Concurrency",
    "section": "Why core.cache Alone Is Not Enough",
    "text": "Why core.cache Alone Is Not Enough\nClojure’s core.cache provides lookup-or-miss which wraps the value function in a delay to prevent duplicate work across swap! retries within a single call. However, each call to lookup-or-miss creates its own delay, and the value function is evaluated inside the swap! body (via through-cache). This means concurrent callers racing into swap! can each see a miss and each start computing before any compare-and-swap succeeds:\nThread A                          Thread B\n────────                          ────────\nlookup-or-miss\n  create delay-A\n  swap!                           lookup-or-miss\n    through-cache → miss            create delay-B\n    @delay-A → computing...         swap!\n                                      through-cache → miss\n                                      @delay-B → computing... ← duplicate!\nThe swap! compare-and-swap ensures only one result enters the cache, but both computations have already started. The delay prevents redundant work across retries of a single swap! call — it does not deduplicate across concurrent callers.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#seeing-the-problem",
    "href": "pocket_book.concurrency.html#seeing-the-problem",
    "title": "8  Concurrency",
    "section": "Seeing the Problem",
    "text": "Seeing the Problem\nWe can demonstrate this directly. Here we use core.cache.wrapped/lookup-or-miss with a slow computation and five concurrent threads. A CyclicBarrier synchronizes the threads so they all call lookup-or-miss at the same instant:\n\n(let [call-count (atom 0)\n      cache (cw/lru-cache-factory {} :threshold 32)\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      slow-fn (fn [_key]\n                (swap! call-count inc)\n                (Thread/sleep 500)\n                42)]\n  (let [futures (doall (for [_ (range 5)]\n                         (future\n                           (.await barrier)\n                           (cw/lookup-or-miss cache :same-key slow-fn))))\n        results (mapv deref futures)]\n    {:results results\n     :computation-count @call-count}))\n\n\n{:results [42 42 42 42 42], :computation-count 5}\n\nAll five threads computed the value independently — computation-count is greater than 1 (typically 5). The delay inside lookup-or-miss prevented duplicate work on swap! retries within each thread, but concurrent callers each created and forced their own delay.\nScenario 1 (below) repeats this same pattern using Pocket, where the ConcurrentHashMap layer reduces the count to exactly 1.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#pockets-solution",
    "href": "pocket_book.concurrency.html#pockets-solution",
    "title": "8  Concurrency",
    "section": "Pocket’s Solution",
    "text": "Pocket’s Solution\nPocket adds a ConcurrentHashMap layer that ensures only one delay exists per cache key, regardless of how many threads request it:\n(def ^ConcurrentHashMap in-flight\n  (java.util.concurrent.ConcurrentHashMap.))\n\n;; Inside the lookup-or-miss miss-fn:\n(let [d (.computeIfAbsent\n          in-flight path\n          (fn [_]\n            (delay\n              (try\n                ;; disk check + computation\n                (finally\n                  (.remove in-flight path))))))]\n  @d)\ncomputeIfAbsent is atomic: the first thread creates and inserts the delay; all subsequent threads for the same key receive the same delay instance. Since a Clojure delay executes its body exactly once, the computation runs once and all threads share the result.\n\nFailure Handling\nThe finally block removes the entry from in-flight after computation (success or failure). If a computation throws, the next caller gets a fresh delay and a fresh attempt — exceptions are never cached.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#architecture-layers",
    "href": "pocket_book.concurrency.html#architecture-layers",
    "title": "8  Concurrency",
    "section": "Architecture Layers",
    "text": "Architecture Layers\nflowchart TB\n    subgraph Request\n    D[deref Cached]\n    end\n    subgraph Synchronization\n    CHM[ConcurrentHashMapin-flight]\n    DEL[delay]\n    end\n    subgraph Caching\n    MEM[Memory Cachecore.cache]\n    DISK[Disk CacheNippy files]\n    end\n    D --&gt; CHM\n    CHM --&gt;|one delay per key| DEL\n    DEL --&gt;|on miss| MEM\n    MEM --&gt;|on miss| DISK\n    DISK --&gt;|on miss| COMP[Compute]\n    COMP --&gt; DISK\n    DISK --&gt; MEM\n    MEM --&gt; D\n\n\n\nLayer\nPurpose\nGuarantee\n\n\n\n\nConcurrentHashMap\nDelay creation\nOne delay per key\n\n\ndelay\nComputation\nOne execution per delay\n\n\ncore.cache (mem-cache)\nIn-memory caching\nFast repeated access\n\n\nDisk cache\nPersistence\nCross-session caching",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#concurrency-scenarios",
    "href": "pocket_book.concurrency.html#concurrency-scenarios",
    "title": "8  Concurrency",
    "section": "Concurrency Scenarios",
    "text": "Concurrency Scenarios\nThe following scenarios demonstrate Pocket’s thread-safety guarantees with various timing patterns.\n\nSetup\n\n(def test-dir \"/tmp/pocket-concurrency-test\")\n\n\n(pocket/set-base-cache-dir! test-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-concurrency-test\n\n\n\n\n\n\"/tmp/pocket-concurrency-test\"\n\nA counter to track how many times computation actually runs:\n\n(def computation-count (atom 0))\n\n\n(defn slow-computation\n  \"A computation that takes 300ms and increments a counter.\"\n  [x]\n  (swap! computation-count inc)\n  (Thread/sleep 300)\n  (* x x))\n\nConvenience function to reset state before each scenario:\n\n(defn fresh-scenario!\n  \"Reset counters and caches for a fresh scenario.\n   Returns the start time for timing measurements.\"\n  ([]\n   (fresh-scenario! {}))\n  ([{:keys [mem-cache-opts]\n     :or {mem-cache-opts {:policy :lru :threshold 3}}}]\n   (reset! computation-count 0)\n   (pocket/cleanup!)\n   (pocket/set-mem-cache-options! mem-cache-opts)\n   {:started-at (java.time.LocalTime/now)\n    :mem-cache mem-cache-opts}))\n\n\n\n\nScenario 1: Concurrent Deref of Same Value\nMultiple threads deref the same Cached object while the computation is still running. All should receive the same result from a single computation.\nTimeline (ms):   0         100        300        400\n                 │          │          │          │\nThread A:       [─── request ───][─── computing ───]──→ result\nThread B:                  [─── request ───][ wait ]──→ result\n                                             ↑\n                             B waits for A's computation\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x3964d825 \"02:27:28.779416871\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nLaunch 5 threads that all deref the same cached value:\n\n(let [cached-val (pocket/cached #'slow-computation 10)\n      futures (doall (for [_ (range 5)]\n                       (future @cached-val)))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[clojure-agent-send-off-pool-406] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [100 100 100 100 100], :computation-count 1}\n\n\n\n\nScenario 2: Memory Cache Hit\nAfter the first computation, subsequent requests hit the memory cache instantly (no disk I/O, no recomputation).\nTimeline:\nThread A:  [── computing ──]\n                          ↓\n                     mem-cache populated\nThread B:                         [request]──→ instant result\n                                      ↑\n                                memory cache hit\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x7bd17fb6 \"02:27:29.091084726\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nFirst request computes, second is instant (memory hit):\n\n(let [;; First request - computes\n      result-1 @(pocket/cached #'slow-computation 20)\n      count-after-first @computation-count\n      ;; Second request - should hit memory cache\n      start (System/currentTimeMillis)\n      result-2 @(pocket/cached #'slow-computation 20)\n      elapsed (- (System/currentTimeMillis) start)\n      count-after-second @computation-count]\n  {:first-result result-1\n   :second-result result-2\n   :second-elapsed-ms elapsed\n   :computations-after-first count-after-first\n   :computations-after-second count-after-second})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:first-result 400,\n :second-result 400,\n :second-elapsed-ms 0,\n :computations-after-first 1,\n :computations-after-second 1}\n\n\n\n\nScenario 3: Disk Cache Hit After Memory Eviction\nFill the memory cache to evict our entry, then verify the next request reads from disk (not recomputes).\nTimeline:\n1. Compute value for arg=30          → stored in mem + disk\n2. Compute 3 more values (31,32,33)  → arg=30 evicted from mem (LRU)\n3. Request arg=30 again              → disk cache hit (no recompute)\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x2f70d3fe \"02:27:29.400394440\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nStep 1: Compute initial value, then fill cache to cause eviction:\n\n(let [;; Compute arg=30\n      _ @(pocket/cached #'slow-computation 30)\n      ;; Fill cache to evict arg=30 (threshold=3)\n      _ @(pocket/cached #'slow-computation 31)\n      _ @(pocket/cached #'slow-computation 32)\n      _ @(pocket/cached #'slow-computation 33)\n      count-before-retry @computation-count\n      ;; Request arg=30 again - should hit disk\n      result @(pocket/cached #'slow-computation 30)\n      count-after-retry @computation-count]\n  {:result result\n   :computations-before-retry count-before-retry\n   :computations-after-retry count-after-retry\n   :disk-hit? (= count-before-retry count-after-retry)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:result 900,\n :computations-before-retry 4,\n :computations-after-retry 4,\n :disk-hit? true}\n\n\n\n\nScenario 4: Failure and Retry\nWhen a computation fails, the exception is not cached. The next caller gets a fresh attempt.\nTimeline:\n1. Thread A requests → computation fails (exception)\n2. Thread B requests → fresh computation succeeds\n3. Thread C requests → cache hit (no recompute)\n\n(def failure-count (atom 0))\n\n\n(defn flaky-computation\n  \"Fails on first call, succeeds thereafter.\"\n  [x]\n  (if (zero? @failure-count)\n    (do (swap! failure-count inc)\n        (throw (ex-info \"Temporary failure\" {:x x})))\n    (do (swap! failure-count inc)\n        (* x 100))))\n\n\n(do\n  (reset! failure-count 0)\n  (pocket/cleanup!)\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n\n\n\n\n\n:ready\n\nFirst attempt fails, second succeeds, third hits cache:\n\n(let [;; First attempt - fails\n      attempt-1 (try\n                  @(pocket/cached #'flaky-computation 5)\n                  (catch Exception e {:error (.getMessage e)}))\n      count-after-1 @failure-count\n      ;; Second attempt - succeeds\n      attempt-2 @(pocket/cached #'flaky-computation 5)\n      count-after-2 @failure-count\n      ;; Third attempt - cache hit\n      attempt-3 @(pocket/cached #'flaky-computation 5)\n      count-after-3 @failure-count]\n  {:attempt-1 attempt-1\n   :attempt-2 attempt-2\n   :attempt-3 attempt-3\n   :counts [count-after-1 count-after-2 count-after-3]})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/flaky-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/flaky-computation\n\n\n\n\n\n{:attempt-1 {:error \"Temporary failure\"},\n :attempt-2 500,\n :attempt-3 500,\n :counts [1 2 2]}\n\n\n\n\nScenario 5: Different Arguments Compute in Parallel\nRequests with different arguments run in parallel (no unnecessary serialization).\nTimeline (ms):   0                   300\n                 │                    │\nThread A (x=40): [──── computing ────]──→ 1600\nThread B (x=41): [──── computing ────]──→ 1681\nThread C (x=42): [──── computing ────]──→ 1764\n                  ↑\n            All start ~simultaneously, run in parallel\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x3819a916 \"02:27:30.626581133\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\n\n(let [start (System/currentTimeMillis)\n      futures (mapv #(future @(pocket/cached #'slow-computation %))\n                    [40 41 42])\n      results (mapv deref futures)\n      elapsed (- (System/currentTimeMillis) start)]\n  {:results results\n   :elapsed-ms elapsed\n   :parallel? (&lt; elapsed 500)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[clojure-agent-send-off-pool-407] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[clojure-agent-send-off-pool-408] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[clojure-agent-send-off-pool-410] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [1600 1681 1764], :elapsed-ms 301, :parallel? true}\n\n\n\n\nScenario 6: Disk Hit with Empty Memory Cache\nClear memory cache while keeping disk cache. All requests should read from disk without recomputing.\nSetup: value for arg=50 is on disk but NOT in memory\n\nThreads A, B, C all request x=50\n→ All read from disk (no computation)\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x3629cf3c \"02:27:30.934881241\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nCompute, clear memory, then hit disk:\n\n(let [;; Compute and cache arg=50\n      _ @(pocket/cached #'slow-computation 50)\n      count-after-compute @computation-count\n      ;; Clear only memory cache (disk remains)\n      _ (pocket/clear-mem-cache!)\n      ;; Multiple threads hit disk cache\n      futures (mapv (fn [_] (future @(pocket/cached #'slow-computation 50)))\n                    (range 3))\n      results (mapv deref futures)\n      count-after-disk-hits @computation-count]\n  {:results results\n   :count-after-compute count-after-compute\n   :count-after-disk-hits count-after-disk-hits\n   :no-recompute? (= count-after-compute count-after-disk-hits)})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [2500 2500 2500],\n :count-after-compute 1,\n :count-after-disk-hits 1,\n :no-recompute? true}\n\n\n\n\nScenario 7: Full Cache Hierarchy Test\nA comprehensive scenario testing all cache layers:\n┌─────────────────────────────────────────────────────────────┐\n│ Step 1: Request x=60         → COMPUTE (miss everywhere)    │\n│ Step 2: Request x=60 again   → MEMORY HIT (instant)         │\n│ Step 3: Evict from memory    → (fill cache with other vals) │\n│ Step 4: Request x=60         → DISK HIT (read from disk)    │\n│ Step 5: Delete disk cache    → invalidate!                  │\n│ Step 6: Request x=60         → COMPUTE (miss everywhere)    │\n└─────────────────────────────────────────────────────────────┘\n\n(fresh-scenario! {:mem-cache-opts {:policy :lru :threshold 2}})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 2}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 2}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x399ad82f \"02:27:31.244578104\"],\n :mem-cache {:policy :lru, :threshold 2}}\n\n\n(let [;; Step 1: Initial computation\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-1 @computation-count\n\n      ;; Step 2: Memory hit (should be instant)\n      start-2 (System/currentTimeMillis)\n      _ @(pocket/cached #'slow-computation 60)\n      elapsed-2 (- (System/currentTimeMillis) start-2)\n      count-step-2 @computation-count\n\n      ;; Step 3: Evict from memory by filling cache\n      _ @(pocket/cached #'slow-computation 61)\n      _ @(pocket/cached #'slow-computation 62)\n      count-step-3 @computation-count\n\n      ;; Step 4: Disk hit (memory miss)\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-4 @computation-count\n\n      ;; Step 5: Delete disk cache\n      _ (pocket/invalidate! #'slow-computation 60)\n      _ (pocket/clear-mem-cache!)\n\n      ;; Step 6: Recompute (miss everywhere)\n      _ @(pocket/cached #'slow-computation 60)\n      count-step-6 @computation-count]\n  {:count-step-1 count-step-1\n   :elapsed-step-2 elapsed-2\n   :count-step-2 count-step-2\n   :count-step-3 count-step-3\n   :count-step-4 count-step-4\n   :count-step-6 count-step-6})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-concurrency-test/f4/(pocket-book.concurrency_slow-computation 60) existed= true\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:count-step-1 1,\n :elapsed-step-2 1,\n :count-step-2 1,\n :count-step-3 3,\n :count-step-4 3,\n :count-step-6 4}\n\n\n\nScenario 8: Synchronized Start (Barrier)\nA stricter variant of Scenario 1 that uses a CyclicBarrier to guarantee all threads enter deref at the same instant. This is the direct contrast to the core.cache demonstration above.\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x1a8e2c3 \"02:27:32.459999239\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @(pocket/cached #'slow-computation 70))))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[clojure-agent-send-off-pool-409] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [4900 4900 4900 4900 4900], :computation-count 1}\n\n\n\n\nScenario 9: Concurrent Pipeline Deref\nA pipeline where step 2 takes a Cached step 1 result as an argument. Multiple threads deref step 2 concurrently — both steps should compute exactly once.\n\n(def step-a-count (atom 0))\n\n\n(def step-b-count (atom 0))\n\n\n(defn pipeline-step-a\n  \"First pipeline step: slow transform.\"\n  [x]\n  (swap! step-a-count inc)\n  (Thread/sleep 200)\n  (* x 10))\n\n\n(defn pipeline-step-b\n  \"Second pipeline step: depends on step-a result.\"\n  [data]\n  (swap! step-b-count inc)\n  (Thread/sleep 200)\n  (+ data 1))\n\n\n(do\n  (reset! step-a-count 0)\n  (reset! step-b-count 0)\n  (pocket/cleanup!)\n  (pocket/set-mem-cache-options! {:policy :lru :threshold 10})\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 10}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 10}\n\n\n\n\n\n:ready\n\nBuild a two-step pipeline, then deref from 5 threads:\n\n(let [cached-a (pocket/cached #'pipeline-step-a 7)\n      cached-b (pocket/cached #'pipeline-step-b cached-a)\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @cached-b)))\n      results (mapv deref futures)]\n  {:results results\n   :step-a-count @step-a-count\n   :step-b-count @step-b-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[clojure-agent-send-off-pool-406] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/pipeline-step-b\n[clojure-agent-send-off-pool-406] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/pipeline-step-a\n\n\n\n\n\n{:results [71 71 71 71 71], :step-a-count 1, :step-b-count 1}\n\n\n\n\nScenario 10: Concurrent Failure\nMultiple threads hit a computation that throws. All threads should see the exception. A subsequent attempt should succeed (fresh delay).\n\n(def concurrent-fail-count (atom 0))\n\n\n(defn fail-once-computation\n  \"Fails when concurrent-fail-count is 0, succeeds after.\"\n  [x]\n  (let [n (swap! concurrent-fail-count inc)]\n    (when (= 1 n)\n      (Thread/sleep 200)\n      (throw (ex-info \"Transient error\" {:x x})))\n    (Thread/sleep 100)\n    (* x x)))\n\n\n(do\n  (reset! concurrent-fail-count 0)\n  (pocket/cleanup!)\n  (pocket/set-mem-cache-options! {:policy :lru :threshold 10})\n  :ready)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 10}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 10}\n\n\n\n\n\n:ready\n\n5 threads hit the failing computation simultaneously:\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         (try\n                           {:value @(pocket/cached #'fail-once-computation 8)}\n                           (catch Exception e\n                             {:error (.getMessage e)})))))\n      first-results (mapv deref futures)\n      errors (filterv :error first-results)\n      successes (filterv :value first-results)]\n  {:first-round-errors (count errors)\n   :first-round-successes (count successes)\n   :retry @(pocket/cached #'fail-once-computation 8)\n   :total-calls @concurrent-fail-count})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[clojure-agent-send-off-pool-408] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/fail-once-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/fail-once-computation\n\n\n\n\n\n{:first-round-errors 5,\n :first-round-successes 0,\n :retry 64,\n :total-calls 2}\n\n\n\n\nScenario 11: Eviction Under Contention\nWith a very small cache (threshold=2) and many concurrent requests, memory eviction happens frequently. The in-flight map still prevents duplicate computation for the same key.\n\n(fresh-scenario! {:mem-cache-opts {:policy :lru :threshold 2}})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 2}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 2}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x721c2d3f \"02:27:33.506154600\"],\n :mem-cache {:policy :lru, :threshold 2}}\n\nLaunch 4 threads per key, for 3 different keys. Each key should compute exactly once despite eviction pressure.\n\n(let [barrier (java.util.concurrent.CyclicBarrier. 12)\n      futures (doall\n               (for [x [80 81 82]\n                     _ (range 4)]\n                 (future\n                   (.await barrier)\n                   @(pocket/cached #'slow-computation x))))\n      results (mapv deref futures)]\n  {:results results\n   :computation-count @computation-count\n   :expected-results (vec (for [x [80 81 82]\n                                _ (range 4)]\n                            (* x x)))})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[clojure-agent-send-off-pool-408] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[clojure-agent-send-off-pool-417] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[clojure-agent-send-off-pool-406] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results\n [6400 6400 6400 6400 6561 6561 6561 6561 6724 6724 6724 6724],\n :computation-count 3,\n :expected-results\n [6400 6400 6400 6400 6561 6561 6561 6561 6724 6724 6724 6724]}\n\n\n\n\nScenario 12: Rapid Deref After Invalidation\nInvalidate a cached value and immediately re-request from multiple threads. The re-request should compute exactly once.\n\n(fresh-scenario!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 3}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 3}\n\n\n\n\n\n{:started-at\n #object[java.time.LocalTime 0x56cb5db \"02:27:33.821481064\"],\n :mem-cache {:policy :lru, :threshold 3}}\n\nCompute and cache a value:\n\n(let [_ @(pocket/cached #'slow-computation 90)\n      count-after-first @computation-count\n      ;; Invalidate\n      _ (pocket/invalidate! #'slow-computation 90)\n      ;; Immediately re-request from 5 concurrent threads\n      barrier (java.util.concurrent.CyclicBarrier. 5)\n      futures (doall (for [_ (range 5)]\n                       (future\n                         (.await barrier)\n                         @(pocket/cached #'slow-computation 90))))\n      results (mapv deref futures)\n      count-after-retry @computation-count]\n  {:results results\n   :count-after-first count-after-first\n   :count-after-retry count-after-retry})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-concurrency-test/22/(pocket-book.concurrency_slow-computation 90) existed= true\n[clojure-agent-send-off-pool-407] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.concurrency/slow-computation\n\n\n\n\n\n{:results [8100 8100 8100 8100 8100],\n :count-after-first 1,\n :count-after-retry 2}",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#design-notes",
    "href": "pocket_book.concurrency.html#design-notes",
    "title": "8  Concurrency",
    "section": "Design Notes",
    "text": "Design Notes\n\nWhy Not Use Caffeine?\nCaffeine (via Cloffeine) provides LoadingCache with built-in computeIfAbsent synchronization. This would eliminate the need for our explicit in-flight map.\nWe chose core.cache because:\n\nLighter dependency (pure Clojure data structures)\nPluggable, immutable cache implementations\nFamiliar to the Clojure ecosystem\n\nTrade-off: We need the explicit ConcurrentHashMap synchronization layer.\n\n\nThe computeIfAbsent Contract\nFrom the Java documentation:\n\nThe mapping function should not modify this map during computation.\n\nOur implementation is safe: the mapping function only creates a delay (cheap, instantaneous). The actual computation happens when the delay is dereferenced, outside of computeIfAbsent.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.concurrency.html#cleanup",
    "href": "pocket_book.concurrency.html#cleanup",
    "title": "8  Concurrency",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-concurrency-test\n\n\n\n\n\n{:dir \"/tmp/pocket-concurrency-test\", :existed true}\n\n\n(pocket/reset-mem-cache-options!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options reset to defaults: {:policy :lru, :threshold 256}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\nsource: notebooks/pocket_book/concurrency.clj",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Concurrency</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html",
    "href": "pocket_book.extending_pocket.html",
    "title": "9  Extending Pocket",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#setup",
    "href": "pocket_book.extending_pocket.html#setup",
    "title": "9  Extending Pocket",
    "section": "",
    "text": "(def cache-dir \"/tmp/pocket-extending\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-extending\n\n\n\n\n\n\"/tmp/pocket-extending\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending\n\n\n\n\n\n{:dir \"/tmp/pocket-extending\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#the-pidentifiable-protocol",
    "href": "pocket_book.extending_pocket.html#the-pidentifiable-protocol",
    "title": "9  Extending Pocket",
    "section": "The PIdentifiable protocol",
    "text": "The PIdentifiable protocol\nPocket derives cache keys from the identity of the function and its arguments. The PIdentifiable protocol controls how each value contributes to the cache key:\n\n(kind/doc #'pocket/-&gt;id)\n\n\n-&gt;id\n[x]\nReturn a cache key representation of a value. Dispatches via the PIdentifiable protocol.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#default-behaviors",
    "href": "pocket_book.extending_pocket.html#default-behaviors",
    "title": "9  Extending Pocket",
    "section": "Default behaviors",
    "text": "Default behaviors\nPocket provides default implementations for common types:\nA var’s identity is its fully-qualified name:\n\n(pocket/-&gt;id #'clojure.core/map)\n\n\nclojure.core/map\n\nA map’s identity is itself (keys are deep-sorted later for stable cache paths):\n\n(pocket/-&gt;id {:b 2 :a 1})\n\n\n{:b 2, :a 1}\n\nA Cached object’s identity captures the full computation graph:\n\n(defn add [x y] (+ x y))\n\n\n(pocket/-&gt;id (pocket/cached #'add 1 2))\n\n\n(pocket-book.extending-pocket/add 1 2)\n\nnil is handled:\n\n(pocket/-&gt;id nil)\n\n\nnil",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#built-in-dataset-support",
    "href": "pocket_book.extending_pocket.html#built-in-dataset-support",
    "title": "9  Extending Pocket",
    "section": "Built-in dataset support",
    "text": "Built-in dataset support\nPocket recognizes tech.ml.dataset datasets (the type behind tablecloth) and derives their identity from the actual column data and metadata — including annotations like inference targets.\nA dataset’s identity is a map of column names to {:data [...] :meta {...}}:\n\n(def example-ds\n  (-&gt; (tc/dataset {:x (range 30) :y (range 30)})\n      (ds-mod/set-inference-target :y)))\n\n\n(pocket/-&gt;id example-ds)\n\n\n{:x\n {:data\n  [0\n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29],\n  :meta {:name :x, :datatype :int64, :n-elems 30}},\n :y\n {:data\n  [0\n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29],\n  :meta\n  {:name :y, :datatype :int64, :n-elems 30, :inference-target? true}}}\n\nTwo datasets with identical content produce the same identity, even when the default toString representation would truncate rows:\n\n(def ds-a (tc/dataset {:x (range 30) :y (range 30)}))\n\n\n(def ds-b (tc/dataset {:x (range 30) :y (range 30)}))\n\n\n(= (pocket/-&gt;id ds-a) (pocket/-&gt;id ds-b))\n\n\ntrue\n\nDatasets with different content produce different identities, even when the difference falls in rows that toString would elide:\n\n(def ds-c (tc/dataset {:x (range 30)\n                       :y (concat (range 15) [999] (range 16 30))}))\n\n\n(= (pocket/-&gt;id ds-a) (pocket/-&gt;id ds-c))\n\n\nfalse\n\nThis means caching functions that take datasets as arguments (like ml/train) works correctly regardless of dataset size.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#extending-for-custom-types",
    "href": "pocket_book.extending_pocket.html#extending-for-custom-types",
    "title": "9  Extending Pocket",
    "section": "Extending for custom types",
    "text": "Extending for custom types\nIf you have domain-specific types, you can control how they appear in cache keys by extending PIdentifiable. This is useful when the default behavior (which uses the object itself) doesn’t produce stable or meaningful cache keys.\nFor example, suppose you have a record representing a dataset reference:\n\n(defrecord DatasetRef [source version])\n\nWithout extending the protocol, a DatasetRef would be treated as a plain map — its identity would be something like {:source \"census\", :version 3}, which works but isn’t very readable in cache directory names.\nLet’s give it a concise, meaningful identity:\n\n(extend-protocol pocket/PIdentifiable\n  DatasetRef\n  (-&gt;id [this]\n    (symbol (str (:source this) \"-v\" (:version this)))))\n\nNow the identity is a clean symbol:\n\n(pocket/-&gt;id (-&gt;DatasetRef \"census\" 3))\n\n\ncensus-v3",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#using-custom-types-in-cached-computations",
    "href": "pocket_book.extending_pocket.html#using-custom-types-in-cached-computations",
    "title": "9  Extending Pocket",
    "section": "Using custom types in cached computations",
    "text": "Using custom types in cached computations\n\n(defn analyze-dataset\n  \"Simulate analyzing a dataset.\"\n  [dataset-ref opts]\n  (println \"  Analyzing\" (:source dataset-ref) \"v\" (:version dataset-ref) \"...\")\n  (Thread/sleep 200)\n  {:source (:source dataset-ref)\n   :version (:version dataset-ref)\n   :rows 1000\n   :method (:method opts)})\n\nThe cache key now includes our custom identity:\n\n(def analysis\n  (pocket/cached #'analyze-dataset\n                 (-&gt;DatasetRef \"census\" 3)\n                 {:method :regression}))\n\n\n(pocket/-&gt;id analysis)\n\n\n(pocket-book.extending-pocket/analyze-dataset\n census-v3\n {:method :regression})\n\nFirst deref computes:\n\n(deref analysis)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset\n  Analyzing census v 3 ...\n\n\n\n\n\n{:source \"census\", :version 3, :rows 1000, :method :regression}\n\nSecond deref loads from cache:\n\n(deref analysis)\n\n\n{:source \"census\", :version 3, :rows 1000, :method :regression}\n\nA different version creates a different cache entry:\n\n(deref (pocket/cached #'analyze-dataset\n                      (-&gt;DatasetRef \"census\" 4)\n                      {:method :regression}))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset\n  Analyzing census v 4 ...\n\n\n\n\n\n{:source \"census\", :version 4, :rows 1000, :method :regression}",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#whats-on-disk",
    "href": "pocket_book.extending_pocket.html#whats-on-disk",
    "title": "9  Extending Pocket",
    "section": "What’s on disk?",
    "text": "What’s on disk?\nThe cache directory names reflect our custom identities:\n\n(pocket/dir-tree)\n\n\npocket-extending\n├── 62\n│   └── (pocket-book.extending-pocket_analyze-dataset census-v3 {:method :regression})\n│       ├── meta.edn\n│       └── value.nippy\n└── f6\n    └── (pocket-book.extending-pocket_analyze-dataset census-v4 {:method :regression})\n        ├── meta.edn\n        └── value.nippy",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#guidelines",
    "href": "pocket_book.extending_pocket.html#guidelines",
    "title": "9  Extending Pocket",
    "section": "Guidelines",
    "text": "Guidelines\nWhen extending PIdentifiable:\n\nReturn stable values. The identity must be the same across JVM sessions for the same logical input. Avoid including timestamps, random values, or object addresses.\nReturn distinct values. Two logically different inputs must produce different identities. If they don’t, Pocket will treat them as the same computation and return stale results.\nKeep it readable. The identity becomes part of the cache directory name. Symbols and short strings work well.\nPrefer symbols or keywords over complex nested structures. They produce clean, short directory names.\nRecords and plain maps can collide. A record like (-&gt;DatasetRef \"census\" 3) and a plain map {:source \"census\" :version 3} produce the same default cache key (both are maps with the same keys). If you use records as cache arguments, extend PIdentifiable to give them a distinct identity — as shown above.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#custom-nippy-serialization",
    "href": "pocket_book.extending_pocket.html#custom-nippy-serialization",
    "title": "9  Extending Pocket",
    "section": "Custom Nippy serialization",
    "text": "Custom Nippy serialization\nPocket uses Nippy for fast binary serialization. Most Clojure data structures and many Java objects serialize automatically. However, if you cache values containing custom types, you may need to extend Nippy.\nCommon types that work out of the box:\n\nAll Clojure collections (vectors, maps, sets, lists)\nPrimitives, strings, keywords, symbols\nJava Date, UUID, BigDecimal, BigInteger\nRecords and deftypes (if all fields are serializable)\nTribuo ML models\ntech.ml.dataset datasets\n\nTypes that require extension:\n\nObjects with unserializable fields (e.g., open file handles, database connections, thread pools)\nCustom Java classes from external libraries (unless they implement Serializable)\n\nTo extend Nippy for a custom type, use nippy/extend-freeze and nippy/extend-thaw:\n(require '[taoensso.nippy :as nippy])\n\n(defrecord MyModel [weights bias])\n\n(nippy/extend-freeze MyModel :my-model\n  [x data-output]\n  (nippy/freeze-to-out! data-output (:weights x))\n  (nippy/freeze-to-out! data-output (:bias x)))\n\n(nippy/extend-thaw :my-model\n  [data-input]\n  (-&gt;MyModel (nippy/thaw-from-in! data-input)\n             (nippy/thaw-from-in! data-input)))\nSee the Nippy documentation for more details.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.extending_pocket.html#cleanup",
    "href": "pocket_book.extending_pocket.html#cleanup",
    "title": "9  Extending Pocket",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending\n\n\n\n\n\n{:dir \"/tmp/pocket-extending\", :existed true}\n\n\nsource: notebooks/pocket_book/extending_pocket.clj",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Extending Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html",
    "href": "pocket_book.ml_workflows.html",
    "title": "10  Example: Machine Learning Workflows",
    "section": "",
    "text": "Setup\nThis chapter demonstrates Pocket in a realistic machine learning scenario. If you’re new to ML, don’t worry — we’ll explain the concepts as we go. The focus is on how caching helps when you’re exploring many combinations of data, features, and models.\nThe problem: We want to predict a numeric value (like house prices or temperature) from input data. This is called regression. We’ll generate synthetic data, try different ways of preparing it, and compare two learning algorithms.\nWhy caching matters: Training models can be slow. When you’re experimenting — tweaking parameters, trying new features — you don’t want to recompute everything each time. Pocket caches each step independently, so only the parts you changed get recomputed.\nWhat we’ll cover:\nNote: This notebook uses tablecloth for data manipulation, metamorph.ml and tribuo for ML, and Plotly.js for visualization. These are not Pocket dependencies — they illustrate a realistic ML workflow. All output is shown inline; to reproduce it, add noj to your project dependencies.\nWhy synthetic data? Working with synthetic data is a standard practice in machine learning. Because we define the true relationship (\\(y = \\sin(x) \\cdot x\\)), we can measure exactly how well each model recovers it — something impossible with real-world data where the ground truth is unknown. Synthetic experiments let us isolate one variable at a time: does feature engineering help? How does noise affect each algorithm? These controlled comparisons build intuition that transfers to real problems. In our case, we’ll see that a linear model is helpless against a nonlinear target unless we give it the right features, while a decision tree handles the shape on its own but pays a different price when noise increases.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#setup",
    "href": "pocket_book.ml_workflows.html#setup",
    "title": "10  Example: Machine Learning Workflows",
    "section": "",
    "text": "(ns pocket-book.ml-workflows\n  (:require\n   ;; Logging setup for this chapter (see Logging chapter):\n   [pocket-book.logging]\n   ;; Pocket API:\n   [scicloj.pocket :as pocket]\n   ;; Annotating kinds of visualizations:\n   [scicloj.kindly.v4.kind :as kind]\n   ;; Data processing:\n   [tablecloth.api :as tc]\n   [tablecloth.column.api :as tcc]\n   [tech.v3.dataset :as ds]\n   [tech.v3.dataset.modelling :as ds-mod]\n   ;; Machine learning:\n   [scicloj.metamorph.ml :as ml]\n   [scicloj.metamorph.ml.loss :as loss]\n   [scicloj.ml.tribuo]))\n\n\n(def cache-dir \"/tmp/pocket-regression\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-regression\n\n\n\n\n\n\"/tmp/pocket-regression\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed false}",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#pipeline-functions",
    "href": "pocket_book.ml_workflows.html#pipeline-functions",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Pipeline functions",
    "text": "Pipeline functions\nThese are the steps of our ML pipeline — plain Clojure functions that know nothing about caching. Pocket will wrap them later.\nData generation: make-regression-data creates a synthetic dataset from a ground-truth function. We control the sample size, noise level, and random seed — all of which become part of the cache key, so changing any parameter triggers recomputation.\n\n(defn make-regression-data\n  \"Generate a synthetic regression dataset.\n  `f` is a function from x to y (the ground truth).\n  Optional `outlier-fraction` (0–1) and `outlier-scale` inject\n  corrupted x values to simulate sensor glitches.\"\n  [{:keys [f n noise-sd seed outlier-fraction outlier-scale]\n    :or {outlier-fraction 0 outlier-scale 10}}]\n  (let [rng (java.util.Random. (long seed))\n        xs (vec (repeatedly n #(* 10.0 (.nextDouble rng))))\n        xs-final (if (pos? outlier-fraction)\n                   (let [out-rng (java.util.Random. (+ (long seed) 7919))]\n                     (mapv (fn [x]\n                             (if (&lt; (.nextDouble out-rng) outlier-fraction)\n                               (+ x (* (double outlier-scale) (.nextGaussian out-rng)))\n                               x))\n                           xs))\n                   xs)\n        ys (mapv (fn [x] (+ (double (f x))\n                            (* (double noise-sd) (.nextGaussian rng))))\n                 xs)]\n    (-&gt; (tc/dataset {:x xs-final :y ys})\n        (ds-mod/set-inference-target :y))))\n\nSplitting: split-dataset divides data into training and test sets. This is a cached step so the full provenance chain — from parameters through data generation to the split — is captured in the DAG.\n\n(defn split-dataset\n  \"Split a dataset into train/test using holdout.\"\n  [ds {:keys [seed]}]\n  (first (tc/split-&gt;seq ds :holdout {:seed seed})))\n\nFeature engineering: prepare-features transforms raw data by adding derived columns. The choice of feature set is a key hyperparameter — a linear model with only :raw features can’t learn nonlinear patterns, but :trig or :poly+trig features give it the building blocks it needs.\n\n(defn prepare-features\n  \"Add derived columns to a dataset according to `feature-set`.\n  Supported feature sets:\n\n  - `:raw`       — no extra columns\n  - `:quadratic` — add x²\n  - `:trig`      — add sin(x) and cos(x)\n  - `:poly+trig` — add x², sin(x), and cos(x)\"\n  [ds feature-set]\n  (let [x (:x ds)]\n    (-&gt; (case feature-set\n          :raw ds\n          :quadratic (tc/add-columns ds {:x2 (tcc/sq x)})\n          :trig (tc/add-columns ds {:sin-x (tcc/sin x)\n                                    :cos-x (tcc/cos x)})\n          :poly+trig (tc/add-columns ds {:x2 (tcc/sq x)\n                                         :sin-x (tcc/sin x)\n                                         :cos-x (tcc/cos x)}))\n        (ds-mod/set-inference-target :y))))\n\nTraining and evaluation: train-model fits a model to prepared data, and predict-and-rmse measures how well it generalizes to unseen test data. These are thin wrappers around metamorph.ml — the caching value comes from avoiding redundant retraining when only downstream parameters change.\n\n(defn train-model\n  \"Train a model on a dataset.\"\n  [train-ds model-spec]\n  (ml/train train-ds model-spec))\n\n\n(defn predict-and-rmse\n  \"Predict on test data and return RMSE.\"\n  [test-ds model]\n  (let [pred (ml/predict test-ds model)]\n    (loss/rmse (:y test-ds) (:y pred))))",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#ground-truth",
    "href": "pocket_book.ml_workflows.html#ground-truth",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Ground truth",
    "text": "Ground truth\nWe need a function to predict. In real problems you don’t know the true relationship — that’s what you’re trying to learn. Here we define it explicitly so we can measure how well our models do.\nOur target is \\(y = \\sin(x) \\cdot x\\) — a wavy curve that grows with \\(x\\). A straight line can’t fit this shape, so a simple linear model will struggle unless we help it with better features.\n\n(defn nonlinear-fn\n  \"y = sin(x) · x\"\n  [x]\n  (* (Math/sin x) x))",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#model-specifications",
    "href": "pocket_book.ml_workflows.html#model-specifications",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Model specifications",
    "text": "Model specifications\nWe’ll compare two fundamentally different algorithms:\nLinear model (gradient descent): Finds the best straight-line (or hyperplane) relationship between inputs and output. Simple and fast, but can only learn linear patterns. Needs good features.\nDecision tree (CART): Learns by splitting data into regions based on thresholds (“if x &gt; 5, go left”). Can capture complex patterns automatically, but may overfit noisy data.\nThese algorithms respond differently to feature engineering — that contrast is the heart of Part 1.\n\n(def linear-sgd-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"squared\"\n                        :type \"org.tribuo.regression.sgd.objectives.SquaredLoss\"}\n                       {:name \"trainer\"\n                        :type \"org.tribuo.regression.sgd.linear.LinearSGDTrainer\"\n                        :properties {:objective \"squared\"\n                                     :epochs \"50\"\n                                     :loggingInterval \"10000\"}}]\n   :tribuo-trainer-name \"trainer\"})\n\n\n(def cart-spec\n  {:model-type :scicloj.ml.tribuo/regression\n   :tribuo-components [{:name \"cart\"\n                        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                        :properties {:maxDepth \"8\"}}]\n   :tribuo-trainer-name \"cart\"})",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-1-feature-engineering-matters-for-some-models",
    "href": "pocket_book.ml_workflows.html#part-1-feature-engineering-matters-for-some-models",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Part 1 — Feature engineering matters (for some models)",
    "text": "Part 1 — Feature engineering matters (for some models)\nFeature engineering means transforming raw inputs into forms that help models learn. For example, if the true relationship involves \\(x^2\\), adding a squared column gives the model that pattern directly instead of forcing it to discover it.\nWe’ll test four feature sets:\n\n:raw — just the original \\(x\\) value\n:quadratic — add \\(x^2\\)\n:trig — add \\(\\sin(x)\\) and \\(\\cos(x)\\)\n:poly+trig — add all three\n\nCrossed with two model types, that’s eight combinations. Every step is cached, so re-running is instant.\n\nGenerate data\n\n(def data-c\n  (pocket/cached #'make-regression-data\n                 {:f #'nonlinear-fn :n 500 :noise-sd 0.5 :seed 42}))\n\n\n(tc/head (deref data-c))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n\n\n\n\n\n_unnamed [5 2]:\n\n\n\n:x\n:y\n\n\n\n\n7.27563680\n6.74555252\n\n\n6.83223472\n4.07224915\n\n\n3.08719455\n0.22904859\n\n\n2.77078490\n0.47163659\n\n\n6.65548952\n2.81816258\n\n\n\n\n\n\nSplit into train and test\n\n(def split-c\n  (pocket/cached #'split-dataset data-c {:seed 42}))\n\nExtract train and test sets — using keywords as cached functions. The DAG now traces from numerical parameters through data generation to the split to each subset.\n\n(def train-c (pocket/cached :train split-c))\n\n\n(def test-c (pocket/cached :test split-c))\n\n\n\nFeature sets\n\n(def feature-sets [:raw :quadratic :trig :poly+trig])\n\n\n\nPrepare features (cached)\nEach feature set applied to each split half is a separate cached computation — eight in total.\n\n(def prepared\n  (into {}\n        (for [fs feature-sets\n              [role ds-c] [[:train train-c] [:test test-c]]]\n          [[fs role]\n           (pocket/cached #'prepare-features ds-c fs)])))\n\n\n\nTrain models (cached)\nTwo models per feature set — eight cached training runs.\n\n(def models\n  (into {}\n        (for [fs feature-sets\n              [model-name spec] [[:sgd linear-sgd-spec]\n                                 [:cart cart-spec]]]\n          [[fs model-name]\n           (pocket/cached #'train-model\n                          (prepared [fs :train])\n                          spec)])))\n\n\n\nResults\n\n(def feature-results\n  (vec (for [fs feature-sets\n             [model-name _] [[:sgd linear-sgd-spec]\n                             [:cart cart-spec]]]\n         {:feature-set fs\n          :model (name model-name)\n          :rmse (predict-and-rmse @(prepared [fs :test])\n                                  @(models [fs model-name]))})))\n\n\n\n\n\n\n\nNoteERR\n\n\n\n\n\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 7.061050130878382\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 7.746488252108407\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 0.9717267353378612\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.866764,min=-5.501972,mean=0.840206,variance=15.440717})\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.5031022528715852\n\n\n\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n\n\n\n\n\nfeature-results\n\n\n[{:feature-set :raw, :model \"sgd\", :rmse 3.6917759873191685}\n {:feature-set :raw, :model \"cart\", :rmse 0.6334615055076024}\n {:feature-set :quadratic, :model \"sgd\", :rmse 3.576999082640806}\n {:feature-set :quadratic, :model \"cart\", :rmse 0.6334615055076024}\n {:feature-set :trig, :model \"sgd\", :rmse 1.4577701415666355}\n {:feature-set :trig, :model \"cart\", :rmse 0.6805569759436894}\n {:feature-set :poly+trig, :model \"sgd\", :rmse 1.3410184469297421}\n {:feature-set :poly+trig, :model \"cart\", :rmse 0.6805569759436894}]\n\nWhat the results show:\nThe linear model (SGD) has high error with raw features — it’s trying to draw a straight line through a wavy curve. But give it \\(\\sin(x)\\) and \\(\\cos(x)\\) as features, and it can combine them to approximate the true shape. Feature engineering saved the day.\nThe decision tree (CART) doesn’t care. It discovers the wavy pattern by splitting the data into regions. Extra features don’t help because the tree already found the structure.\nTakeaway: Some models need feature engineering; others don’t. Caching lets you explore both without waiting.\n\n\nPredictions plot\nBest linear model (poly+trig) vs best tree (raw) vs actual values.\n\n(let [test-ds @(prepared [:raw :test])\n      sgd-pred (:y (ml/predict @(prepared [:poly+trig :test])\n                               @(models [:poly+trig :sgd])))\n      cart-pred (:y (ml/predict test-ds\n                                @(models [:raw :cart])))\n      xs (vec (:x test-ds))\n      actuals (vec (:y test-ds))\n      sgd-vals (vec sgd-pred)\n      cart-vals (vec cart-pred)]\n  (kind/plotly\n   {:data [{:x xs :y actuals :mode \"markers\" :name \"actual\"\n            :marker {:opacity 0.3 :color \"gray\"}}\n           {:x xs :y sgd-vals :mode \"markers\" :name \"Linear SGD (poly+trig)\"\n            :marker {:opacity 0.5 :color \"steelblue\"}}\n           {:x xs :y cart-vals :mode \"markers\" :name \"CART (raw)\"\n            :marker {:opacity 0.5 :color \"tomato\"}}]\n    :layout {:xaxis {:title \"x\"} :yaxis {:title \"y\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-2-how-models-handle-noisy-data",
    "href": "pocket_book.ml_workflows.html#part-2-how-models-handle-noisy-data",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Part 2 — How models handle noisy data",
    "text": "Part 2 — How models handle noisy data\nReal data is messy. Measurements have errors, inputs are approximate. Noise is the random variation that obscures the true pattern.\nHow do our models behave as noise increases? We’ll test five levels, from nearly clean (0.1) to very noisy (5.0).\nNotice: the noise=0.5 dataset reuses the cache from Part 1 — Pocket recognizes the same function and arguments.\n\n(def noise-levels [0.1 0.5 1.0 2.0 5.0])\n\n\n(def noise-results\n  (vec\n   (for [noise-sd noise-levels]\n     (let [data-c (pocket/cached #'make-regression-data\n                                 {:f #'nonlinear-fn :n 500 :noise-sd noise-sd :seed 42})\n           split-c (pocket/cached #'split-dataset data-c {:seed 42})\n           train-c (pocket/cached :train split-c)\n           test-c (pocket/cached :test split-c)\n           cart-train (pocket/cached #'prepare-features train-c :raw)\n           cart-test (pocket/cached #'prepare-features test-c :raw)\n           sgd-train (pocket/cached #'prepare-features train-c :poly+trig)\n           sgd-test (pocket/cached #'prepare-features test-c :poly+trig)\n           cart-model (pocket/cached #'train-model cart-train cart-spec)\n           sgd-model (pocket/cached #'train-model sgd-train linear-sgd-spec)]\n       {:noise-sd noise-sd\n        :cart-rmse (predict-and-rmse @cart-test @cart-model)\n        :sgd-rmse (predict-and-rmse @sgd-test @sgd-model)}))))\n\n\n\n\n\n\n\nNoteERR\n\n\n\n\n\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=8.106624,min=-5.332393,mean=0.805881,variance=15.304966})\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.4235088958624642\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=9.816940,min=-6.625413,mean=0.883112,variance=15.979208})\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 1.8153008504655874\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=11.717291,min=-8.958664,mean=0.968924,variance=18.285525})\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 3.123027977933463\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Training SGD model with 333 examples\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: Outputs - RegressionInfo({name=y,id=0,count=333,max=17.418345,min=-15.958416,mean=1.226360,variance=35.039175})\nFeb 08, 2026 2:27:35 AM org.tribuo.common.sgd.AbstractSGDTrainer train\nINFO: At iteration 10000, average loss = 12.1030268449752\n\n\n\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/prepare-features\n\n\n\n\n\nnoise-results\n\n\n[{:noise-sd 0.1,\n  :cart-rmse 0.18813079748027944,\n  :sgd-rmse 1.2744431229599325}\n {:noise-sd 0.5,\n  :cart-rmse 0.6334615055076024,\n  :sgd-rmse 1.3410184469297421}\n {:noise-sd 1.0,\n  :cart-rmse 1.2499664669902657,\n  :sgd-rmse 1.582298583473656}\n {:noise-sd 2.0,\n  :cart-rmse 2.453719422103725,\n  :sgd-rmse 2.352662287937308}\n {:noise-sd 5.0,\n  :cart-rmse 5.960858808406107,\n  :sgd-rmse 5.262029923696976}]\n\nWhat the results show:\nAt low noise, the tree wins — it captures fine details the linear model smooths over. But as noise increases, the tree starts memorizing random wiggles (overfitting), and its error explodes.\nThe linear model degrades more gracefully. Its rigid structure (a weighted sum of features) acts as a built-in regularizer — it can’t chase noise even if it wanted to.\nTakeaway: Flexible models (trees) excel with clean data but suffer with noise. Simple models (linear) are more robust.\n\nRMSE vs. noise\n\n(let [noise-sds (vec (map :noise-sd noise-results))\n      cart-rmses (vec (map :cart-rmse noise-results))\n      sgd-rmses (vec (map :sgd-rmse noise-results))]\n  (kind/plotly\n   {:data [{:x noise-sds :y cart-rmses :mode \"lines+markers\" :name \"CART\"}\n           {:x noise-sds :y sgd-rmses :mode \"lines+markers\" :name \"Linear SGD\"}]\n    :layout {:xaxis {:title \"noise-sd\"} :yaxis {:title \"rmse\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-3-what-got-cached",
    "href": "pocket_book.ml_workflows.html#part-3-what-got-cached",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Part 3 — What got cached?",
    "text": "Part 3 — What got cached?\nWe’ve run many combinations of data, features, and models. Each pocket/cached call created an independent cache entry. Let’s see what we accumulated:\n\n(:total-entries (pocket/cache-stats))\n\n\n60\n\n\n(:entries-per-fn (pocket/cache-stats))\n\n\n{\"pocket-book.ml-workflows/prepare-features\" 24,\n \"pocket-book.ml-workflows/make-regression-data\" 5,\n \"pocket-book.ml-workflows/train-model\" 16,\n \":test\" 5,\n \":train\" 5,\n \"pocket-book.ml-workflows/split-dataset\" 5}\n\nWith this small synthetic data, each step runs in milliseconds. But the structure is what matters. In real workflows — large datasets, deep neural networks, hyperparameter searches — the same cache graph saves hours or days.\nHere’s what happens when you change something:\n\n\n\n\n\n\n\nChange\nWhat recomputes\n\n\n\n\nEdit a feature set\nThat feature prep + its models\n\n\nChange a model hyperparameter\nOnly that model\n\n\nChange the noise level\nThat data + its features + its models\n\n\nRe-run the whole notebook\nNothing — all cached",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#cleanup",
    "href": "pocket_book.ml_workflows.html#cleanup",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-4-sharing-computations-across-branches",
    "href": "pocket_book.ml_workflows.html#part-4-sharing-computations-across-branches",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Part 4 — Sharing computations across branches",
    "text": "Part 4 — Sharing computations across branches\nReal sensors glitch. A positioning system occasionally records a wildly wrong x value — the physics (y) is unaffected, but the recorded input is corrupted. When we build polynomial features like x², these outlier x values get amplified: an errant x=50 gives x²=2500 instead of the expected ~25 from a normal x≈5.\nThe fix is feature outlier clipping: compute what range of x is “normal” from training data, then clip both train and test inputs to those bounds — before feature engineering.\nThe clipping threshold must come from training data alone. Using test data would leak future information.\nThis creates a diamond dependency — one computation (the threshold) feeds into multiple downstream steps:\n make-regression-data (with x outliers)\n         |\n    split-dataset\n         |\n    +----+----+\n    v         v\n (:train)  (:test)\n    |         |\n    v         |\nfit-threshold |\n    |         |\n    +----+----+\n    v         v\nclip(train) clip(test)\n    |         |\n    v         v\nfeatures   features\n    |         |\n    v         |\ntrain-model   |\n    |         |\n    +----+----+\n    v\n  evaluate\nPocket handles this naturally. The threshold node is computed once and feeds both clipping steps. When you change the training data, the threshold recomputes, and both branches update.\n\nPipeline functions\nThese are plain functions. Each does one thing: fit a threshold, clip outliers, or evaluate. Pocket will wire them together.\n\n(defn fit-outlier-threshold\n  \"Compute IQR-based clipping bounds for :x from training data.\n  Returns {:lower &lt;bound&gt; :upper &lt;bound&gt;}.\"\n  [train-ds]\n  (println \"  Fitting outlier threshold from training data...\")\n  (let [xs (sort (vec (:x train-ds)))\n        n (count xs)\n        q1 (nth xs (int (* 0.25 n)))\n        q3 (nth xs (int (* 0.75 n)))\n        iqr (- q3 q1)]\n    {:lower (- q1 (* 1.5 iqr))\n     :upper (+ q3 (* 1.5 iqr))}))\n\n\n(defn clip-outliers\n  \"Clip :x values using pre-computed threshold bounds.\"\n  [ds threshold]\n  (println \"  Clipping outliers with bounds:\" (select-keys threshold [:lower :upper]))\n  (let [{:keys [lower upper]} threshold]\n    (tc/add-column ds :x (-&gt; (:x ds) (tcc/max lower) (tcc/min upper)))))\n\n\n(defn evaluate-model\n  \"Evaluate a model on test data.\"\n  [test-ds model]\n  (println \"  Evaluating model...\")\n  (let [pred (ml/predict test-ds model)]\n    {:rmse (loss/rmse (:y test-ds) (:y pred))}))\n\n\n\nBuild the DAG with mixed storage policies\nNot every step needs disk persistence. We use caching-fn with per-function storage policies:\n\n:mem for cheap shared computations (threshold, clipping, feature engineering) — no disk I/O, but in-memory dedup ensures each runs only once persists across JVM sessions\n:none for trivial steps (evaluation) — just tracks identity in the DAG without any shared caching\n\n\n(def c-fit-threshold\n  (pocket/caching-fn #'fit-outlier-threshold {:storage :mem}))\n\n\n(def c-clip\n  (pocket/caching-fn #'clip-outliers {:storage :mem}))\n\n\n(def c-prepare\n  (pocket/caching-fn #'prepare-features {:storage :mem}))\n\n\n(def c-train\n  (pocket/caching-fn #'train-model))\n\n\n(def c-evaluate\n  (pocket/caching-fn #'evaluate-model {:storage :none}))\n\nGenerate data with outliers for this demo — 10% of the x values are corrupted by large random spikes, simulating sensor glitches. The y values (physics) are computed from the clean x, then noise is added normally — so only the input is corrupted.\n\n(def dag-data-c\n  (pocket/cached #'make-regression-data\n                 {:f #'nonlinear-fn :n 200 :noise-sd 0.3 :seed 99\n                  :outlier-fraction 0.1 :outlier-scale 15}))\n\n\n(def dag-split-c\n  (pocket/cached #'split-dataset dag-data-c {:seed 99}))\n\n\n(def dag-train-c (pocket/cached :train dag-split-c))\n\n\n(def dag-test-c (pocket/cached :test dag-split-c))\n\nNow wire the pipeline. The threshold is fitted once from training data (in memory) and feeds both clipping steps — a diamond dependency handled naturally.\n\n(def threshold-c\n  (c-fit-threshold dag-train-c))\n\n\n(def train-clipped-c\n  (c-clip dag-train-c threshold-c))\n\n\n(def test-clipped-c\n  (c-clip dag-test-c threshold-c))\n\n\n(def train-prepped-c\n  (c-prepare train-clipped-c :poly+trig))\n\n\n(def test-prepped-c\n  (c-prepare test-clipped-c :poly+trig))\n\n\n(def model-c\n  (c-train train-prepped-c cart-spec))\n\n\n(def metrics-c\n  (c-evaluate test-prepped-c model-c))\n\n\n\nVisualize the DAG\nPocket provides three functions for DAG introspection, each suited to different use cases.\norigin-story returns a nested tree structure. Each cached node has :fn, :args, and :id. The :id is unique; when the same Cached instance appears multiple times (diamond pattern), subsequent occurrences become {:ref &lt;id&gt;} pointers. This avoids infinite recursion and makes the diamond explicit:\n\n(pocket/origin-story metrics-c)\n\n\n{:fn #'pocket-book.ml-workflows/evaluate-model,\n :args\n [{:fn #'pocket-book.ml-workflows/prepare-features,\n   :args\n   [{:fn #'pocket-book.ml-workflows/clip-outliers,\n     :args\n     [{:fn :test,\n       :args\n       [{:fn #'pocket-book.ml-workflows/split-dataset,\n         :args\n         [{:fn #'pocket-book.ml-workflows/make-regression-data,\n           :args\n           [{:value\n             {:f #'pocket-book.ml-workflows/nonlinear-fn,\n              :n 200,\n              :noise-sd 0.3,\n              :seed 99,\n              :outlier-fraction 0.1,\n              :outlier-scale 15}}],\n           :id \"c6\"}\n          {:value {:seed 99}}],\n         :id \"c5\"}],\n       :id \"c4\"}\n      {:fn #'pocket-book.ml-workflows/fit-outlier-threshold,\n       :args [{:fn :train, :args [{:ref \"c5\"}], :id \"c8\"}],\n       :id \"c7\"}],\n     :id \"c3\"}\n    {:value :poly+trig}],\n   :id \"c2\"}\n  {:fn #'pocket-book.ml-workflows/train-model,\n   :args\n   [{:fn #'pocket-book.ml-workflows/prepare-features,\n     :args\n     [{:fn #'pocket-book.ml-workflows/clip-outliers,\n       :args [{:ref \"c8\"} {:ref \"c7\"}],\n       :id \"c11\"}\n      {:value :poly+trig}],\n     :id \"c10\"}\n    {:value\n     {:model-type :scicloj.ml.tribuo/regression,\n      :tribuo-components\n      [{:name \"cart\",\n        :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\",\n        :properties {:maxDepth \"8\"}}],\n      :tribuo-trainer-name \"cart\"}}],\n   :id \"c9\"}],\n :id \"c1\"}\n\nNotice how the threshold node appears as a :ref in one branch — it’s the same computation feeding both train and test clipping.\norigin-story-graph normalizes the tree into a flat {:nodes ... :edges ...} structure suitable for graph algorithms:\n\n(pocket/origin-story-graph metrics-c)\n\n\n{:nodes\n {\"c9\" {:fn #'pocket-book.ml-workflows/fit-outlier-threshold},\n  \"c10\" {:fn :train},\n  \"c13\" {:fn #'pocket-book.ml-workflows/prepare-features},\n  \"c14\" {:fn #'pocket-book.ml-workflows/clip-outliers},\n  \"v15\" {:value :poly+trig},\n  \"v7\"\n  {:value\n   {:f #'pocket-book.ml-workflows/nonlinear-fn,\n    :n 200,\n    :noise-sd 0.3,\n    :seed 99,\n    :outlier-fraction 0.1,\n    :outlier-scale 15}},\n  \"v8\" {:value {:seed 99}},\n  \"c2\" {:fn #'pocket-book.ml-workflows/prepare-features},\n  \"v11\" {:value :poly+trig},\n  \"c12\" {:fn #'pocket-book.ml-workflows/train-model},\n  \"v16\"\n  {:value\n   {:model-type :scicloj.ml.tribuo/regression,\n    :tribuo-components\n    [{:name \"cart\",\n      :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\",\n      :properties {:maxDepth \"8\"}}],\n    :tribuo-trainer-name \"cart\"}},\n  \"c3\" {:fn #'pocket-book.ml-workflows/clip-outliers},\n  \"c4\" {:fn :test},\n  \"c5\" {:fn #'pocket-book.ml-workflows/split-dataset},\n  \"c6\" {:fn #'pocket-book.ml-workflows/make-regression-data},\n  \"c1\" {:fn #'pocket-book.ml-workflows/evaluate-model}},\n :edges\n [[\"c1\" \"c2\"]\n  [\"c2\" \"c3\"]\n  [\"c3\" \"c4\"]\n  [\"c4\" \"c5\"]\n  [\"c5\" \"c6\"]\n  [\"c6\" \"v7\"]\n  [\"c5\" \"v8\"]\n  [\"c3\" \"c9\"]\n  [\"c9\" \"c10\"]\n  [\"c10\" \"c5\"]\n  [\"c2\" \"v11\"]\n  [\"c1\" \"c12\"]\n  [\"c12\" \"c13\"]\n  [\"c13\" \"c14\"]\n  [\"c14\" \"c10\"]\n  [\"c14\" \"c9\"]\n  [\"c13\" \"v15\"]\n  [\"c12\" \"v16\"]]}\n\norigin-story-mermaid renders the DAG as a Mermaid flowchart, with arrows showing data flow direction (from inputs toward the final result). The diamond dependency is clearly visible — the threshold feeds both clipping steps:\n\n(pocket/origin-story-mermaid metrics-c)\n\nflowchart TD\n  n0[\"evaluate-model\"]\n  n1[\"prepare-features\"]\n  n2[\"clip-outliers\"]\n  n3[\":test\"]\n  n4[\"split-dataset\"]\n  n5[\"make-regression-data\"]\n  n6[/\"{:f #'pocket-book.ml-workflows/nonlinear-fn,:n 200,:noise-sd 0.3,:seed 99,:outlier-fraction 0.1,:outlier-scale 15}\"/]\n  n6 --&gt; n5\n  n5 --&gt; n4\n  n7[/\"{:seed 99}\"/]\n  n7 --&gt; n4\n  n4 --&gt; n3\n  n3 --&gt; n2\n  n8[\"fit-outlier-threshold\"]\n  n9[\":train\"]\n  n4 --&gt; n9\n  n9 --&gt; n8\n  n8 --&gt; n2\n  n2 --&gt; n1\n  n10[/\":poly+trig\"/]\n  n10 --&gt; n1\n  n1 --&gt; n0\n  n11[\"train-model\"]\n  n12[\"prepare-features\"]\n  n13[\"clip-outliers\"]\n  n9 --&gt; n13\n  n8 --&gt; n13\n  n13 --&gt; n12\n  n14[/\":poly+trig\"/]\n  n14 --&gt; n12\n  n12 --&gt; n11\n  n15[/\"{:model-type :scicloj.ml.tribuo/regression,:tribuo-components [{:name 'cart',:type 'org.tribuo.regression.rtree.CARTRegressionTrainer',:properties {:maxDepth '8'}}],:tribuo-trainer-name 'cart'}\"/]\n  n15 --&gt; n11\n  n11 --&gt; n0\n\n\nExecute the pipeline\n\n(deref metrics-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/clip-outliers\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/fit-outlier-threshold\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n  Fitting outlier threshold from training data...\n  Clipping outliers with bounds: {:lower -5.499694170624462, :upper 15.994051959902624}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/clip-outliers\n  Clipping outliers with bounds: {:lower -5.499694170624462, :upper 15.994051959902624}\n  Evaluating model...\n\n\n\n\n\n{:rmse 1.601302555211606}\n\nHow much did clipping help? Let’s compare three scenarios using the same cached building blocks.\nThe no-clip and clean-baseline pipelines are local — they exist only for this comparison. Each still builds a cached DAG that shares steps with the clipped pipeline above.\n\n(let [;; No-clip: skip clipping, go straight from raw splits to features\n      noclip-train-c  (c-prepare dag-train-c :poly+trig)\n      noclip-test-c   (c-prepare dag-test-c :poly+trig)\n      noclip-model-c  (c-train noclip-train-c cart-spec)\n      noclip-metrics  @(c-evaluate noclip-test-c noclip-model-c)\n      ;; Clean baseline: same structure, data without outliers\n      clean-data-c    (pocket/cached #'make-regression-data\n                                     {:f #'nonlinear-fn :n 200 :noise-sd 0.3 :seed 99})\n      clean-split-c   (pocket/cached #'split-dataset clean-data-c {:seed 99})\n      clean-train-c   (c-prepare (pocket/cached :train clean-split-c) :poly+trig)\n      clean-test-c    (c-prepare (pocket/cached :test clean-split-c) :poly+trig)\n      clean-model-c   (c-train clean-train-c cart-spec)\n      clean-metrics   @(c-evaluate clean-test-c clean-model-c)]\n  {:clean            clean-metrics\n   :outliers-no-clip noclip-metrics\n   :outliers-clipped @metrics-c})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n  Evaluating model...\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :test\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/split-dataset\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/make-regression-data\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/train-model\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss (mem), computing: pocket-book.ml-workflows/prepare-features\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: :train\n  Evaluating model...\n\n\n\n\n\n{:clean {:rmse 0.4263098047865239},\n :outliers-no-clip {:rmse 2.552495499444297},\n :outliers-clipped {:rmse 1.601302555211606}}\n\nClipping x before building polynomial features makes a visible difference — the amplification through x² is tamed.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#part-5-comparing-many-experiments-at-once",
    "href": "pocket_book.ml_workflows.html#part-5-comparing-many-experiments-at-once",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Part 5 — Comparing many experiments at once",
    "text": "Part 5 — Comparing many experiments at once\nHyperparameters are settings you choose before training: tree depth, learning rate, which features to use. Finding good values usually means trying many combinations — a hyperparameter sweep.\nPocket’s compare-experiments helps here. You pass a collection of cached experiments, and it extracts the parameters that vary across them (ignoring ones that are constant).\n\n(defn run-pipeline\n  \"Run a complete pipeline with given hyperparameters.\"\n  [{:keys [noise-sd feature-set max-depth]}]\n  (let [ds (make-regression-data {:f nonlinear-fn :n 200 :noise-sd noise-sd :seed 42})\n        sp (split-dataset ds {:seed 42})\n        train-prep (prepare-features (:train sp) feature-set)\n        test-prep (prepare-features (:test sp) feature-set)\n        spec {:model-type :scicloj.ml.tribuo/regression\n              :tribuo-components [{:name \"cart\"\n                                   :type \"org.tribuo.regression.rtree.CARTRegressionTrainer\"\n                                   :properties {:maxDepth (str max-depth)}}]\n              :tribuo-trainer-name \"cart\"}\n        model (ml/train train-prep spec)\n        pred (ml/predict test-prep model)]\n    {:rmse (loss/rmse (:y test-prep) (:y pred))}))\n\nRun experiments across a grid of hyperparameters:\n\n(def experiments\n  (for [noise-sd [0.3 0.5]\n        feature-set [:raw :poly+trig]\n        max-depth [4 8]]\n    (pocket/cached #'run-pipeline\n                   {:noise-sd noise-sd\n                    :feature-set feature-set\n                    :max-depth max-depth})))\n\nCompare all experiments — only varying parameters are shown:\n\n(def comparison\n  (pocket/compare-experiments experiments))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.ml-workflows/run-pipeline\n\n\n\n\n\n(tc/dataset comparison)\n\n\n_unnamed [8 4]:\n\n\n\n:noise-sd\n:feature-set\n:max-depth\n:result\n\n\n\n\n0.3\n:raw\n4\n{:rmse 0.7189521159338053}\n\n\n0.3\n:raw\n8\n{:rmse 0.41024324994778005}\n\n\n0.3\n:poly+trig\n4\n{:rmse 0.5297031491020386}\n\n\n0.3\n:poly+trig\n8\n{:rmse 0.4530388384300822}\n\n\n0.5\n:raw\n4\n{:rmse 0.8815492449083825}\n\n\n0.5\n:raw\n8\n{:rmse 0.6467985374993637}\n\n\n0.5\n:poly+trig\n4\n{:rmse 0.7728233864192875}\n\n\n0.5\n:poly+trig\n8\n{:rmse 0.6785270538736407}\n\n\n\n\nEach row shows the varying parameters plus the result. Parameters that were constant (like seed=42) are excluded automatically — you see only what differs.\n\nResults visualization\n\n(let [rows (map (fn [exp]\n                  (merge (select-keys exp [:noise-sd :feature-set :max-depth])\n                         (:result exp)))\n                comparison)\n      ;; Group by both feature-set and noise-sd for legend entries\n      grouped (group-by (juxt :feature-set :noise-sd) rows)\n      feature-colors {:raw \"steelblue\" :poly \"tomato\" :poly+trig \"green\"}]\n  (kind/plotly\n   {:data (vec (for [[[feature-set noise-sd] pts] (sort-by first grouped)\n                     :let [max-depths (mapv :max-depth pts)\n                           rmses (mapv :rmse pts)]]\n                 {:x max-depths\n                  :y rmses\n                  :mode \"markers\"\n                  :name (str (name feature-set) \" (noise=\" noise-sd \")\")\n                  :legendgroup (name feature-set)\n                  :marker {:size (+ 8 (* 15 noise-sd))\n                           :color (feature-colors feature-set)}}))\n\n    :layout {:xaxis {:title \"max-depth\"} :yaxis {:title \"rmse\"}}}))",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#what-we-learned",
    "href": "pocket_book.ml_workflows.html#what-we-learned",
    "title": "10  Example: Machine Learning Workflows",
    "section": "What we learned",
    "text": "What we learned\nThis experiment revealed a clear story about the interplay between models, features, and noise:\n\nFeature engineering is decisive for linear models. With raw features, the linear model couldn’t capture the nonlinear target at all. Adding trigonometric features (sin, cos) — which match the structure of the true function — dramatically improved it. The model didn’t get smarter; we gave it the right vocabulary.\nDecision trees are self-sufficient but fragile. The CART model achieved low error regardless of feature set, because it can learn nonlinear splits on its own. But as noise increased, it began fitting the noise rather than the signal — a classic overfitting pattern.\nThe crossover point matters. At low noise, the tree wins. At high noise, the well-featured linear model degrades more gracefully. Knowing where this crossover happens is exactly the kind of insight you get from systematic experimentation.\nCaching structures the workflow. In this small example, each step runs in milliseconds — caching isn’t needed for speed. But the pattern scales: with real datasets and expensive training, the same pipeline structure ensures that only changed steps recompute. Meanwhile, compare-experiments extracted the varying parameters automatically, turning cached results into a comparison table — useful at any scale.\nPreprocessing order matters. Outlier x values get amplified by polynomial features (x²), so clipping must come before feature engineering. The diamond dependency — one threshold feeding both train and test clipping — is handled naturally by Pocket’s DAG.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.ml_workflows.html#cleanup-1",
    "href": "pocket_book.ml_workflows.html#cleanup-1",
    "title": "10  Example: Machine Learning Workflows",
    "section": "Cleanup",
    "text": "Cleanup\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-regression\n\n\n\n\n\n{:dir \"/tmp/pocket-regression\", :existed true}\n\n\nsource: notebooks/pocket_book/ml_workflows.clj",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Example: Machine Learning Workflows</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html",
    "href": "pocket_book.developing_pocket.html",
    "title": "11  Developing Pocket",
    "section": "",
    "text": "Rendering notebooks\nThis chapter is for contributors and curious readers. It describes how Pocket’s documentation is built, how tests are structured, and the conventions the notebooks follow.\nPocket’s documentation is a Clay book — a collection of Clojure source files that Clay evaluates and renders as HTML (via Quarto) or as GitHub Flavored Markdown.\nThe chapter list lives in notebooks/chapters.edn:\nEach entry maps to a file under notebooks/pocket_book/. For example, \"getting_started\" corresponds to notebooks/pocket_book/getting_started.clj.\nThe rendering helpers live in notebooks/dev.clj. From a REPL with the :dev alias:\nThe Quarto configuration is in clay.edn at the project root.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#rendering-notebooks",
    "href": "pocket_book.developing_pocket.html#rendering-notebooks",
    "title": "11  Developing Pocket",
    "section": "",
    "text": "(-&gt;&gt; \"notebooks/chapters.edn\"\n     slurp\n     clojure.edn/read-string)\n\n\n[\"getting_started\"\n \"configuration\"\n \"logging\"\n \"recursive_caching_in_pipelines\"\n \"usage_practices\"\n \"real_world_walkthrough\"\n \"concurrency\"\n \"extending_pocket\"\n \"ml_workflows\"\n \"developing_pocket\"\n \"api_reference\"]\n\n\n\n(require '[dev :as dev] :reload)\n\n;; Render the full HTML book (opens a browser):\n(dev/make-book!)\n\n;; Render one or more chapters as GitHub Flavored Markdown\n;; (useful for reviewing in a terminal or diff tool):\n(dev/make-gfm! \"pocket_book/getting_started.clj\")",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#running-tests",
    "href": "pocket_book.developing_pocket.html#running-tests",
    "title": "11  Developing Pocket",
    "section": "Running tests",
    "text": "Running tests\nThe test suite combines hand-written tests with tests generated from notebooks:\n./run_tests.sh\nThis runs clojure -M:dev:test -m cognitect.test-runner, which scans the test/ directory recursively. It picks up:\n\ntest/scicloj/pocket_test.clj — hand-written unit tests\ntest/pocket_book/*_generated_test.clj — tests generated from notebook kind/test-last annotations (see below)",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#literate-testing-with-kindtest-last",
    "href": "pocket_book.developing_pocket.html#literate-testing-with-kindtest-last",
    "title": "11  Developing Pocket",
    "section": "Literate testing with kind/test-last",
    "text": "Literate testing with kind/test-last\nClay notebooks can embed inline assertions using kind/test-last. A form like:\n(+ 1 2)\n\n(kind/test-last [= 3])\nasserts that the result of the previous form equals 3. The kind/test-last form is invisible in the rendered documentation — readers see only the code and its output.\nWhen Clay renders the notebook, it generates a standard clojure.test file as a side effect. For example, a notebook notebooks/pocket_book/foo.clj produces test/pocket_book/foo_generated_test.clj.\nHere is a live example:\n\n(def demo-value (+ 10 20))\n\n\ndemo-value\n\n\n30\n\nThe assertion above is invisible in the rendered output — but it generated a deftest that runs with every test suite execution.\nThe predicate can be any function. Common patterns:\n\n(type demo-value)\n\n\njava.lang.Long\n\n\n(str \"result is \" demo-value)\n\n\n\"result is 30\"",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.developing_pocket.html#api-reference-with-kinddoc",
    "href": "pocket_book.developing_pocket.html#api-reference-with-kinddoc",
    "title": "11  Developing Pocket",
    "section": "API Reference with kind/doc",
    "text": "API Reference with kind/doc\nThe API Reference chapter uses kind/doc to render a var’s docstring as formatted documentation:\n\n(kind/doc #'clojure.core/map)\n\n\nmap\n[f]\n[f coll]\n[f c1 c2]\n[f c1 c2 c3]\n[f c1 c2 c3 & colls]\nReturns a lazy sequence consisting of the result of applying f to the set of first items of each coll, followed by applying f to the set of second items in each coll, until any one of the colls is exhausted. Any remaining items in other colls are ignored. Function f should accept number-of-colls arguments. Returns a transducer when no collection is provided.\nEach kind/doc call produces a documentation block from the var’s metadata (docstring, arglists, etc.). Live code examples follow naturally after each block.\nThe API Reference namespace uses a metadata hint to hide the kind/doc source code in the rendered output:\n^{:kindly/hide-code true\n  :kindly/options {:kinds-that-hide-code #{:kind/doc}}}\n(ns pocket-book.api-reference ...)\nThis means readers see the formatted docstring but not the (kind/doc ...) call that produced it.\n\nsource: notebooks/pocket_book/developing_pocket.clj",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Developing Pocket</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html",
    "href": "pocket_book.api_reference.html",
    "title": "12  API Reference",
    "section": "",
    "text": "Setup\nA few preparations for the code examples below:",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#setup",
    "href": "pocket_book.api_reference.html#setup",
    "title": "12  API Reference",
    "section": "",
    "text": "(require '[scicloj.pocket :as pocket])\n\n\n(def cache-dir \"/tmp/pocket-demo-reference\")\n\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-reference\n\n\n\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed false}\n\n\n(defn expensive-calculation\n  \"Simulates an expensive computation\"\n  [x y]\n  (println (str \"Computing \" x \" + \" y \" (this is expensive!)\"))\n  (Thread/sleep 400)\n  (+ x y))",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#reference",
    "href": "pocket_book.api_reference.html#reference",
    "title": "12  API Reference",
    "section": "Reference",
    "text": "Reference\n\n*base-cache-dir*\nBase directory for cache storage.\nResolved with precedence: binding &gt; set-base-cache-dir! &gt; POCKET_BASE_CACHE_DIR env var &gt; pocket.edn :base-cache-dir &gt; pocket-defaults.edn (library default: .cache/pocket).\nThe current value:\n\npocket/*base-cache-dir*\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n\nset-base-cache-dir!\n[dir]\nSet the base cache directory by altering *base-cache-dir*. Returns the directory path.\n\n(pocket/set-base-cache-dir! \"/tmp/pocket-demo-2\")\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-2\n\n\n\n\n\n\"/tmp/pocket-demo-2\"\n\n\npocket/*base-cache-dir*\n\n\n\"/tmp/pocket-demo-2\"\n\nRestore it for the rest of the notebook:\n\n(pocket/set-base-cache-dir! cache-dir)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-reference\n\n\n\n\n\n\"/tmp/pocket-demo-reference\"\n\n\n\nconfig\n[]\nReturn the effective resolved configuration as a map. Useful for inspecting which cache directory, mem-cache policy, storage policy, and filename length limit are in effect after applying the precedence chain.\nInspect the current effective configuration:\n\n(pocket/config)\n\n\n{:base-cache-dir \"/tmp/pocket-demo-reference\",\n :mem-cache {:policy :lru, :threshold 256},\n :storage :mem+disk,\n :filename-length-limit 240}\n\n\n\ncached\n[func & args]\nCreate a cached computation (returns IDeref).\nThe computation is executed on first deref and cached to disk. Subsequent derefs load from cache if available.\nfunc must be a var (e.g., #'my-fn) or keyword (e.g., :train) for stable cache keys. Keywords are useful for extracting from cached maps: (cached :train split-c).\nStorage policy is controlled by *storage* (see set-storage!). Use caching-fn with an opts map for per-function overrides.\ncached returns a Cached object — the computation is not yet executed:\n\n(def my-result (pocket/cached #'expensive-calculation 100 200))\n\n\n(type my-result)\n\n\nscicloj.pocket.impl.cache.Cached\n\nThe computation runs when we deref:\n\n(deref my-result)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 100 + 200 (this is expensive!)\n\n\n\n\n\n300\n\nDerefing again loads from cache (no recomputation):\n\n(deref my-result)\n\n\n300\n\n\n\ncaching-fn\n[f]\n[f opts]\nWrap a function to automatically cache its results.\nReturns a new function where each call returns a Cached object (IDeref). Deref the result to trigger computation or load from cache. f must be a var (e.g., #'my-fn) or keyword for stable cache keys.\nOptionally accepts an options map to override configuration per-function:\n\n:storage — :mem+disk, :mem, or :none (overrides *storage*)\n:cache-dir — base cache directory (overrides *base-cache-dir*)\n:mem-cache — in-memory cache options (overrides *mem-cache-options*)\n:filename-length-limit — max filename length before SHA-1 fallback (overrides *filename-length-limit*)\n\ncaching-fn wraps a function so that every call returns a Cached object:\n\n(def my-caching-fn (pocket/caching-fn #'expensive-calculation))\n\n\n(deref (my-caching-fn 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\nSame args hit the cache:\n\n(deref (my-caching-fn 3 4))\n\n\n7\n\ncaching-fn accepts an optional map to override per-function configuration:\n(pocket/caching-fn #'f {:storage :mem})     ;; in-memory only\n(pocket/caching-fn #'f {:storage :none})    ;; identity tracking only\n(pocket/caching-fn #'f {:cache-dir \"/tmp/alt\"})  ;; alternate cache dir\nSee the Configuration chapter for details on storage modes and the full option map.\n\n\nmaybe-deref\n[x]\nDeref if x implements IDeref, otherwise return x as-is.\nUseful in pipeline functions that may receive either Cached or plain values.\nA plain value passes through unchanged:\n\n(pocket/maybe-deref 42)\n\n\n42\n\nA Cached value gets derefed:\n\n(pocket/maybe-deref (pocket/cached #'expensive-calculation 100 200))\n\n\n300\n\n\n\n-&gt;id\n[x]\nReturn a cache key representation of a value. Dispatches via the PIdentifiable protocol.\nA var’s identity is its fully-qualified name:\n\n(pocket/-&gt;id #'expensive-calculation)\n\n\npocket-book.api-reference/expensive-calculation\n\nA map’s identity is itself (maps are deep-sorted later for stable cache paths):\n\n(pocket/-&gt;id {:b 2 :a 1})\n\n\n{:b 2, :a 1}\n\nA Cached object’s identity captures the full computation — function name and argument identities — without running it:\n\n(pocket/-&gt;id (pocket/cached #'expensive-calculation 100 200))\n\n\n(pocket-book.api-reference/expensive-calculation 100 200)\n\nnil is handled as well:\n\n(pocket/-&gt;id nil)\n\n\nnil\n\n\n\nset-mem-cache-options!\n[opts]\nConfigure the in-memory cache. Resets it, discarding any currently cached values.\nSupported keys:\n\n:policy — :lru, :fifo, :lu, :ttl, :lirs, :soft, or :basic\n:threshold — max entries for :lru, :fifo, :lu\n:ttl — time-to-live in ms for :ttl policy\n:s-history-limit / :q-history-limit — for :lirs policy\n\nDefaults come from pocket-defaults.edn.\nSwitch to a FIFO policy with 100 entries:\n\n(pocket/set-mem-cache-options! {:policy :fifo :threshold 100})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :fifo, :threshold 100}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :fifo, :threshold 100}\n\n\n\n\n\n{:policy :fifo, :threshold 100}\n\nReset to default:\n\n(pocket/set-mem-cache-options! {:policy :lru :threshold 256})\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options set: {:policy :lru, :threshold 256}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\n\nreset-mem-cache-options!\n[]\nReset the in-memory cache configuration to library defaults. Clears any options set by set-mem-cache-options! and reconfigures the mem-cache with the default policy from pocket-defaults.edn. Returns the default options.\nReset mem-cache configuration to library defaults:\n\n(pocket/reset-mem-cache-options!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Mem-cache options reset to defaults: {:policy :lru, :threshold 256}\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Mem-cache reconfigured: {:policy :lru, :threshold 256}\n\n\n\n\n\n{:policy :lru, :threshold 256}\n\n\n\n*storage*\nStorage policy for cached computations: :mem+disk, :mem, or :none.\n\n:mem+disk (default) — in-memory cache backed by disk persistence\n:mem — in-memory cache only, no disk I/O\n:none — no shared cache; instance-local memoization only\n\nResolved with precedence: binding &gt; set-storage! &gt; POCKET_STORAGE env var &gt; pocket.edn :storage &gt; pocket-defaults.edn (library default: :mem+disk).\n\n\nset-storage!\n[storage]\nSet the storage policy by altering *storage*. Valid values: :mem+disk, :mem, :none. Returns the storage policy.\nSwitch to memory-only storage:\n\n(pocket/set-storage! :mem)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Storage policy set to: :mem\n\n\n\n\n\n:mem\n\nReset to default:\n\n(pocket/set-storage! nil)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Storage policy set to: nil\n\n\n\n\n\nnil\n\n\n\ncleanup!\n[]\nDelete the cache directory, removing all cached values. Also clears the in-memory cache. Returns a map with :dir and :existed indicating what happened.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\nclear-mem-cache!\n[]\nClear all entries from the in-memory cache without deleting the disk cache. The next deref of a cached value will reload from disk if available. Useful for testing scenarios that need to simulate memory eviction.\nClear in-memory cache without touching disk:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n(pocket/clear-mem-cache!)\n\n\n{}\n\n\n\ninvalidate!\n[func & args]\nInvalidate a specific cached computation, removing it from both disk and memory. Takes the same arguments as cached: a function var (or keyword) and its arguments. Returns a map with :path and :existed.\nRemove a specific cached entry:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n30\n\n\n(pocket/invalidate! #'expensive-calculation 10 20)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Invalidated: /tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20) existed= true\n\n\n\n\n\n{:path\n \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n :existed true}\n\nDerefing again will recompute:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n\ninvalidate-fn!\n[func]\nInvalidate all cached entries for a given function var (or keyword), regardless of arguments. Removes matching entries from both disk and memory. Returns a map with :fn-name, :count, and :paths.\nCache a few entries, then invalidate them all:\n\n(deref (pocket/cached #'expensive-calculation 1 2))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 1 + 2 (this is expensive!)\n\n\n\n\n\n3\n\n\n(deref (pocket/cached #'expensive-calculation 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\n\n(pocket/invalidate-fn! #'expensive-calculation)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Invalidated 3 entries for pocket-book.api-reference/expensive-calculation\n\n\n\n\n\n{:fn-name \"pocket-book.api-reference/expensive-calculation\",\n :count 3,\n :paths\n [\"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\"\n  \"/tmp/pocket-demo-reference/d2/(pocket-book.api-reference_expensive-calculation 1 2)\"\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\"]}\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\ncache-entries\n[]\n[fn-name]\nScan the cache directory and return a sequence of metadata maps. Each entry contains :path, :id, :fn-name, :args-str, and :created-at (when metadata is available — entries cached before metadata support will only have :path). Optionally filter by function name.\nList all cached entries:\n\n(deref (pocket/cached #'expensive-calculation 10 20))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 10 + 20 (this is expensive!)\n\n\n\n\n\n30\n\n\n(deref (pocket/cached #'expensive-calculation 3 4))\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/expensive-calculation\nComputing 3 + 4 (this is expensive!)\n\n\n\n\n\n7\n\n\n(pocket/cache-entries)\n\n\n[{:path\n  \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 10 20)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[10 20]\",\n  :created-at \"2026-02-08T00:27:38.413701428Z\"}\n {:path\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 3 4)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[3 4]\",\n  :created-at \"2026-02-08T00:27:38.817313436Z\"}]\n\nFilter by function name:\n\n(pocket/cache-entries \"pocket-book.api-reference/expensive-calculation\")\n\n\n[{:path\n  \"/tmp/pocket-demo-reference/a3/(pocket-book.api-reference_expensive-calculation 10 20)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 10 20)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[10 20]\",\n  :created-at \"2026-02-08T00:27:38.413701428Z\"}\n {:path\n  \"/tmp/pocket-demo-reference/49/(pocket-book.api-reference_expensive-calculation 3 4)\",\n  :id \"(pocket-book.api-reference/expensive-calculation 3 4)\",\n  :fn-name \"pocket-book.api-reference/expensive-calculation\",\n  :args-str \"[3 4]\",\n  :created-at \"2026-02-08T00:27:38.817313436Z\"}]\n\n\n\ncache-stats\n[]\nReturn aggregate statistics about the cache. Returns a map with :total-entries, :total-size-bytes, and :entries-per-fn.\n\n(pocket/cache-stats)\n\n\n{:total-entries 2,\n :total-size-bytes 388,\n :entries-per-fn {\"pocket-book.api-reference/expensive-calculation\" 2}}\n\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}\n\n\n\norigin-story\n[x]\nGiven a value, return its computation DAG as a nested map.\nFor a Cached value, each node is {:fn &lt;var&gt; :args [&lt;nodes&gt;] :id &lt;string&gt;}, with :value included if the computation has been realized. Plain (non-Cached) arguments become {:value &lt;val&gt;} leaf nodes.\nWhen the same Cached instance appears multiple times in the tree, subsequent occurrences are represented as {:ref &lt;id&gt;} pointing to the first occurrence’s :id. This enables proper DAG representation for diamond dependencies.\nDoes not trigger computation — only peeks at already-realized values. Works with all storage policies (:mem+disk, :mem, :none).\norigin-story returns a nested map describing a computation’s DAG. Each cached step is {:fn &lt;var&gt; :args [...]}, with :value if realized. Plain arguments become {:value ...} leaves.\n\n(defn step-a [x] (+ x 10))\n\n\n(defn step-b [x y] (* x y))\n\n\n(def a-c (pocket/cached #'step-a 5))\n\n\n(def b-c (pocket/cached #'step-b a-c 3))\n\nBefore deref — no :value keys:\n\n(pocket/origin-story b-c)\n\n\n{:fn #'pocket-book.api-reference/step-b,\n :args\n [{:fn #'pocket-book.api-reference/step-a,\n   :args [{:value 5}],\n   :id \"c2\"}\n  {:value 3}],\n :id \"c1\"}\n\nDeref to trigger computation:\n\n(deref b-c)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/step-b\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/step-a\n\n\n\n\n\n45\n\nAfter deref — :value keys appear:\n\n(pocket/origin-story b-c)\n\n\n{:fn #'pocket-book.api-reference/step-b,\n :args\n [{:fn #'pocket-book.api-reference/step-a,\n   :args [{:value 5}],\n   :id \"c2\",\n   :value 15}\n  {:value 3}],\n :id \"c1\",\n :value 45}\n\n\n\norigin-story-mermaid\n[x]\nGiven a value, return a Mermaid flowchart string of its computation DAG.\nAccepts a Cached value (walks it via origin-story) or a tree map previously returned by origin-story.\nReturns a plain string. Wrap with (kind/mermaid ...) for Kindly rendering.\nReturns a Mermaid flowchart with kindly metadata for notebook rendering:\n\n(pocket/origin-story-mermaid b-c)\n\nflowchart TD\n  n0[\"step-b\"]\n  n1[\"step-a\"]\n  n2[/\"5\"/]\n  n2 --&gt; n1\n  n1 --&gt; n0\n  n3[/\"3\"/]\n  n3 --&gt; n0\n\n\norigin-story-graph\n[x]\nGiven a value, return its computation DAG as a normalized graph.\nReturns {:nodes {&lt;id&gt; &lt;node-map&gt;} :edges [[&lt;from&gt; &lt;to&gt;] ...]}.\nNode maps contain :fn (for cached steps) or :value (for leaves), plus :value if the cached computation has been realized.\nThis is the fully normalized (Format B) representation of the DAG. Use origin-story for the tree-with-refs representation (Format A).\norigin-story-graph returns a normalized {:nodes ... :edges ...} format, suitable for graph algorithms:\n\n(pocket/origin-story-graph b-c)\n\n\n{:nodes\n {\"c1\" {:fn #'pocket-book.api-reference/step-b, :value 45},\n  \"c2\" {:fn #'pocket-book.api-reference/step-a, :value 15},\n  \"v3\" {:value 5},\n  \"v4\" {:value 3}},\n :edges [[\"c1\" \"c2\"] [\"c2\" \"v3\"] [\"c1\" \"v4\"]]}\n\n\n\ncompare-experiments\n[cached-values]\nCompare multiple cached experiment results.\nTakes a seq of Cached values (typically final metrics from different hyperparameter configurations). Walks each experiment’s origin-story to extract parameter maps, identifies which parameters vary across experiments, and returns a seq of maps containing the varying params plus the experiment result.\nOnly parameters that differ across experiments are included. The :result key contains the derefed value of each Cached.\ncompare-experiments extracts varying parameters from multiple experiments. This is useful for hyperparameter sweeps where you want to see which parameters differ across experiments.\n\n(defn run-exp [config]\n  {:rmse (* 0.1 (:lr config))})\n\n\n(def exp1 (pocket/cached #'run-exp {:lr 0.01 :epochs 100}))\n\n\n(def exp2 (pocket/cached #'run-exp {:lr 0.001 :epochs 100}))\n\n\n(pocket/compare-experiments [exp1 exp2])\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/run-exp\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.api-reference/run-exp\n\n\n\n\n\n[{:lr 0.01, :result {:rmse 0.001}} {:lr 0.001, :result {:rmse 1.0E-4}}]\n\nNote: :epochs is not shown because it’s the same (100) in both experiments. Only varying parameters appear in the comparison.\n\n(pocket/cleanup!)\n\n\n\n\n\n\n\nNoteOUT\n\n\n\n\n\n[nREPL-session-0d604c57-4fb8-4f34-9be9-92fa21fd04a5] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-reference\n\n\n\n\n\n{:dir \"/tmp/pocket-demo-reference\", :existed true}",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>API Reference</span>"
    ]
  },
  {
    "objectID": "pocket_book.api_reference.html#extending-pidentifiable",
    "href": "pocket_book.api_reference.html#extending-pidentifiable",
    "title": "12  API Reference",
    "section": "Extending PIdentifiable",
    "text": "Extending PIdentifiable\nYou can customize how your types contribute to cache keys by extending the PIdentifiable protocol. See the Extending Pocket chapter for a full walkthrough with examples.\n\nsource: notebooks/pocket_book/api_reference.clj",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>API Reference</span>"
    ]
  }
]