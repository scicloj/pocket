---
format:
  html:
    toc: true
    toc-depth: 4
    theme: [cosmo, notebooks/custom.scss]
    toc-expand: 2
    number-depth: 1
    filters: [notebooks/collapse-callouts.lua]

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script>

# Under the hood: cache keys

When Pocket caches a function call, it builds a **cache key** from
the function identity and all arguments. This chapter looks at how
that works internally and what it costs — especially for large
arguments like datasets.


## Setup


::: {.sourceClojure}
```clojure
(ns pocket-book.cache-keys
  (:require
   ;; Pocket API and internals:
   [scicloj.pocket :as pocket]
   [scicloj.pocket.impl.cache :as cache]
   [scicloj.pocket.protocols :as proto]
   ;; Annotating kinds of visualizations:
   [scicloj.kindly.v4.kind :as kind]
   ;; Data processing:
   [tablecloth.api :as tc]
   [tech.v3.dataset.modelling :as ds-mod]))
```
:::



## The four steps

Every call to `pocket/cached` goes through four steps to produce a
filesystem path for the cache entry:

1. **`->id`** — convert each argument to its identity
   representation via the `PIdentifiable` protocol. Vars become
   fully-qualified symbols; `Cached` references become lightweight
   references; datasets become their full column data + metadata.

2. **`canonical-id`** — deep-sort maps and normalize the structure
   so that `{:a 1 :b 2}` and `{:b 2 :a 1}` produce the same key.

3. **`str`** — serialize the canonical form to a string.

4. **`sha`** — SHA-1 hash for a fixed-length, filesystem-safe path.

When a function's arguments are small (scalars, keywords, or
`Cached` references), all four steps are sub-millisecond. But when a raw
dataset is passed directly, the full dataset content becomes part
of the cache key.


## Measuring the cost

Let's pass a 50,000-row dataset as a direct argument and time
each step:


::: {.sourceClojure}
```clojure
(let [ds (-> (tc/dataset {:x (vec (range 50000))
                          :y (vec (range 50000))
                          :z (repeatedly 50000 rand)})
             (ds-mod/set-inference-target :y))
      ;; Step 1: ->id
      t0 (System/nanoTime)
      id (proto/->id ds)
      t1 (System/nanoTime)
      ;; Step 2: canonical-id
      cid (cache/canonical-id id)
      t2 (System/nanoTime)
      ;; Step 3: str
      s (str cid)
      t3 (System/nanoTime)
      ;; Step 4: sha
      _ (cache/sha s)
      t4 (System/nanoTime)]
  {:rows 50000
   :string-length (count s)
   :->id-ms (/ (- t1 t0) 1e6)
   :canonical-id-ms (/ (- t2 t1) 1e6)
   :str-ms (/ (- t3 t2) 1e6)
   :sha-ms (/ (- t4 t3) 1e6)})
```
:::



::: {.printedClojure}
```clojure
{:rows 50000,
 :string-length 1541530,
 :->id-ms 3.107625,
 :canonical-id-ms 8.489021,
 :str-ms 26.945714,
 :sha-ms 1.471067}

```
:::


The `str` serialization step dominates — it must walk the entire
nested structure and produce a ~1.5 MB string. SHA-1 hashing that
string is fast by comparison. Switching to a faster hash algorithm
would not meaningfully help.


## Why `Cached` references matter

When an argument is a `Cached` reference rather than a raw dataset, its
identity is a lightweight reference to the computation that produced
it — not the data itself. Compare:


::: {.sourceClojure}
```clojure
(pocket/set-base-cache-dir! "/tmp/pocket-cache-keys")
```
:::



::: {.callout-note}
## OUT
```
21:44:05.362 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-cache-keys

```
:::



::: {.printedClojure}
```clojure
"/tmp/pocket-cache-keys"

```
:::



::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
21:44:05.362 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-cache-keys

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-cache-keys", :existed false}

```
:::



::: {.sourceClojure}
```clojure
(defn make-data [n]
  (tc/dataset {:x (vec (range n))
               :y (vec (range n))}))
```
:::


Direct dataset — identity includes all 50,000 rows:


::: {.sourceClojure}
```clojure
(let [ds (make-data 50000)
      t0 (System/nanoTime)
      _ (str (cache/canonical-id (proto/->id ds)))
      t1 (System/nanoTime)]
  {:direct-ms (/ (- t1 t0) 1e6)})
```
:::



::: {.printedClojure}
```clojure
{:direct-ms 19.043167}

```
:::


`Cached` reference — identity is just `(make-data 50000)`:


::: {.sourceClojure}
```clojure
(let [data-c (pocket/cached #'make-data 50000)
      t0 (System/nanoTime)
      _ (str (cache/canonical-id (proto/->id data-c)))
      t1 (System/nanoTime)]
  {:cached-reference-ms (/ (- t1 t0) 1e6)})
```
:::



::: {.printedClojure}
```clojure
{:cached-reference-ms 0.254178}

```
:::


The `Cached` reference is orders of magnitude faster because its identity
is a small form like `(pocket-book.cache-keys/make-data 50000)`,
regardless of how large the output dataset is.

This is one of the key reasons to chain `pocket/cached` calls in a
pipeline: each step's cache key references its inputs by identity
rather than by content, keeping key generation fast and enabling
full provenance through the DAG.


## Cleanup


::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
21:44:05.393 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-cache-keys

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-cache-keys", :existed false}

```
:::



```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/scicloj/pocket/blob/master/notebooks/pocket_book/cache_keys.clj">notebooks/pocket_book/cache_keys.clj</a></small></small></pre></div>
```