---
format:
  html:
    toc: true
    toc-depth: 4
    theme: [cosmo, notebooks/custom.scss]
    toc-expand: 2
    number-depth: 1
    filters: [notebooks/collapse-callouts.lua]

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script>

# Extending Pocket

**Last modified: 2026-02-08**


::: {.sourceClojure}
```clojure
(ns pocket-book.extending-pocket
  (:require
   ;; Logging setup for this chapter (see Logging chapter):
   [pocket-book.logging]
   ;; Pocket API:
   [scicloj.pocket :as pocket]
   ;; Annotating kinds of visualizations:
   [scicloj.kindly.v4.kind :as kind]
   ;; For the dataset identity example:
   [tablecloth.api :as tc]
   [tech.v3.dataset.modelling :as ds-mod]
   ;; For the Nippy serialization example:
   [taoensso.nippy :as nippy]))
```
:::



## Setup


::: {.sourceClojure}
```clojure
(def cache-dir "/tmp/pocket-extending")
```
:::



::: {.sourceClojure}
```clojure
(pocket/set-base-cache-dir! cache-dir)
```
:::



::: {.callout-note}
## OUT
```
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] INFO scicloj.pocket - Cache dir set to: /tmp/pocket-extending

```
:::



::: {.printedClojure}
```clojure
"/tmp/pocket-extending"

```
:::



::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-extending", :existed false}

```
:::



## The `PIdentifiable` protocol

Pocket derives cache keys from the **identity** of the function
and its arguments. The `PIdentifiable` protocol controls how
each value contributes to the cache key:


::: {.sourceClojure}
```clojure
(kind/doc #'pocket/->id)
```
:::


### `->id`
`[x]`

Return a cache key representation of a value.
   Dispatches via the `PIdentifiable` protocol.
   
   For derefed `Cached` values, returns the same lightweight identity
   as the original `Cached` reference — the origin registry preserves
   the link automatically (see `cache_keys` notebook for details).


## Default behaviors

Pocket provides default implementations for common types:

A var's identity is its fully-qualified name:


::: {.sourceClojure}
```clojure
(pocket/->id #'clojure.core/map)
```
:::



::: {.printedClojure}
```clojure
clojure.core/map

```
:::


A map's identity is itself (keys are deep-sorted later for stable cache paths):


::: {.sourceClojure}
```clojure
(pocket/->id {:b 2 :a 1})
```
:::



::: {.printedClojure}
```clojure
{:b 2, :a 1}

```
:::


A `Cached` object's identity captures the full computation graph:


::: {.sourceClojure}
```clojure
(defn add [x y] (+ x y))
```
:::



::: {.sourceClojure}
```clojure
(pocket/->id (pocket/cached #'add 1 2))
```
:::



::: {.printedClojure}
```clojure
(pocket-book.extending-pocket/add 1 2)

```
:::


A derefed `Cached` value carries its origin identity — see
[Under the hood: cache keys](pocket_book.cache_keys.html) for details.
This works for maps, vectors, sets, and datasets:


::: {.sourceClojure}
```clojure
(defn make-pair [a b] {:a a :b b})
```
:::



::: {.sourceClojure}
```clojure
(let [c (pocket/cached #'make-pair 1 2)]
  (= (pocket/->id (deref c)) (pocket/->id c)))
```
:::



::: {.callout-note}
## OUT
```
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/make-pair
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/55/(pocket-book.extending-pocket_make-pair 1 2)

```
:::



::: {.printedClojure}
```clojure
true

```
:::


`nil` is handled:


::: {.sourceClojure}
```clojure
(pocket/->id nil)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



## Built-in dataset support

Pocket recognizes
[tech.ml.dataset](https://github.com/techascent/tech.ml.dataset)
datasets (the type behind tablecloth) and derives their identity
from the actual column data and metadata — including annotations
like inference targets.

A dataset's identity is a map of column names to
`{:data [...] :meta {...}}`:


::: {.sourceClojure}
```clojure
(def example-ds
  (-> (tc/dataset {:x (range 30) :y (range 30)})
      (ds-mod/set-inference-target :y)))
```
:::



::: {.sourceClojure}
```clojure
(pocket/->id example-ds)
```
:::



::: {.printedClojure}
```clojure
{:x
 {:data
  [0
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   19
   20
   21
   22
   23
   24
   25
   26
   27
   28
   29],
  :meta {:name :x, :datatype :int64, :n-elems 30}},
 :y
 {:data
  [0
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   19
   20
   21
   22
   23
   24
   25
   26
   27
   28
   29],
  :meta
  {:name :y, :datatype :int64, :n-elems 30, :inference-target? true}}}

```
:::


Two datasets with identical content produce the same identity,
even when the default `toString` representation would truncate
rows:


::: {.sourceClojure}
```clojure
(def ds-a (tc/dataset {:x (range 30) :y (range 30)}))
```
:::



::: {.sourceClojure}
```clojure
(def ds-b (tc/dataset {:x (range 30) :y (range 30)}))
```
:::



::: {.sourceClojure}
```clojure
(= (pocket/->id ds-a) (pocket/->id ds-b))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


Datasets with different content produce different identities,
even when the difference falls in rows that `toString` would elide:


::: {.sourceClojure}
```clojure
(def ds-c (tc/dataset {:x (range 30)
                       :y (concat (range 15) [999] (range 16 30))}))
```
:::



::: {.sourceClojure}
```clojure
(= (pocket/->id ds-a) (pocket/->id ds-c))
```
:::



::: {.printedClojure}
```clojure
false

```
:::


This means caching functions that take datasets as arguments
(like `ml/train`) works correctly regardless of dataset size.


## Extending for custom types

If you have domain-specific types, you can control how they
appear in cache keys by extending `PIdentifiable`. This is
useful when the default behavior (which uses the object itself)
doesn't produce stable or meaningful cache keys.

For example, suppose you have a record representing a dataset
reference:


::: {.sourceClojure}
```clojure
(defrecord DatasetRef [source version])
```
:::


Without extending the protocol, a `DatasetRef` would be treated
as a plain map — its identity would be something like
`{:source "census", :version 3}`, which works but isn't very
readable in cache directory names.

Let's give it a concise, meaningful identity:


::: {.sourceClojure}
```clojure
(extend-protocol pocket/PIdentifiable
  DatasetRef
  (->id [this]
    (symbol (str (:source this) "-v" (:version this)))))
```
:::


Now the identity is a clean symbol:


::: {.sourceClojure}
```clojure
(pocket/->id (->DatasetRef "census" 3))
```
:::



::: {.printedClojure}
```clojure
census-v3

```
:::



## Using custom types in cached computations


::: {.sourceClojure}
```clojure
(defn analyze-dataset
  "Simulate analyzing a dataset."
  [dataset-ref opts]
  (println "  Analyzing" (:source dataset-ref) "v" (:version dataset-ref) "...")
  (Thread/sleep 200)
  {:source (:source dataset-ref)
   :version (:version dataset-ref)
   :rows 1000
   :method (:method opts)})
```
:::


The cache key now includes our custom identity:


::: {.sourceClojure}
```clojure
(def analysis
  (pocket/cached #'analyze-dataset
                 (->DatasetRef "census" 3)
                 {:method :regression}))
```
:::



::: {.sourceClojure}
```clojure
(pocket/->id analysis)
```
:::



::: {.printedClojure}
```clojure
(pocket-book.extending-pocket/analyze-dataset
 census-v3
 {:method :regression})

```
:::


First deref computes:


::: {.sourceClojure}
```clojure
(deref analysis)
```
:::



::: {.callout-note}
## OUT
```
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset
  Analyzing census v 3 ...
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/62/(pocket-book.extending-pocket_analyze-dataset census-v3 {:method :regression})

```
:::



::: {.printedClojure}
```clojure
{:source "census", :version 3, :rows 1000, :method :regression}

```
:::


Second deref loads from cache:


::: {.sourceClojure}
```clojure
(deref analysis)
```
:::



::: {.printedClojure}
```clojure
{:source "census", :version 3, :rows 1000, :method :regression}

```
:::


A different version creates a different cache entry:


::: {.sourceClojure}
```clojure
(deref (pocket/cached #'analyze-dataset
                      (->DatasetRef "census" 4)
                      {:method :regression}))
```
:::



::: {.callout-note}
## OUT
```
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset
  Analyzing census v 4 ...
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/f6/(pocket-book.extending-pocket_analyze-dataset census-v4 {:method :regression})

```
:::



::: {.printedClojure}
```clojure
{:source "census", :version 4, :rows 1000, :method :regression}

```
:::



## What's on disk?

The cache directory names reflect our custom identities:


::: {.sourceClojure}
```clojure
(pocket/dir-tree)
```
:::



::: {.sourceClojure}
```clojure
pocket-extending
├── 55
│   └── (pocket-book.extending-pocket_make-pair 1 2)
│       ├── meta.edn
│       └── value.nippy
├── 62
│   └── (pocket-book.extending-pocket_analyze-dataset census-v3 {:method :regression})
│       ├── meta.edn
│       └── value.nippy
└── f6
    └── (pocket-book.extending-pocket_analyze-dataset census-v4 {:method :regression})
        ├── meta.edn
        └── value.nippy

```
:::



## Guidelines

When extending `PIdentifiable`:


- **Return stable values.** The identity must be the same across
  JVM sessions for the same logical input. Avoid including
  timestamps, random values, or object addresses.


- **Return distinct values.** Two logically different inputs must
  produce different identities. If they don't, Pocket will treat
  them as the same computation and return stale results.


- **Keep it readable.** The identity becomes part of the cache
  directory name. Symbols and short strings work well.


- **Prefer symbols or keywords** over complex nested structures.
  They produce clean, short directory names.


- **Records and plain maps can collide.** A record like
  `(->DatasetRef "census" 3)` and a plain map
  `{:source "census" :version 3}` produce the same default cache
  key (both are maps with the same keys). If you use records as
  cache arguments, extend `PIdentifiable` to give them a distinct
  identity — as shown above.


## Custom Nippy serialization

Pocket uses [Nippy](https://github.com/taoensso/nippy) for fast
binary serialization. Most Clojure data structures and many Java
objects serialize automatically. However, if we cache values
containing custom types, we may need to extend Nippy.

Common types that work out of the box:


- All Clojure collections (vectors, maps, sets, lists)
- Primitives, strings, keywords, symbols
- Java Date, UUID, BigDecimal, BigInteger
- Records and deftypes (if all fields are serializable)
- [Tribuo](https://github.com/scicloj/scicloj.ml.tribuo) ML models
- [tech.ml.dataset](https://github.com/techascent/tech.ml.dataset) datasets

Types that require extension:


- Objects with unserializable fields (e.g., open file handles,
  database connections, thread pools)

- Custom Java classes from external libraries — even if they
  implement `Serializable`, Nippy 3 checks a
  [thaw allowlist](https://cljdoc.org/d/com.taoensso/nippy/3.6.0/api/taoensso.nippy#*thaw-serializable-allowlist*)
  and will quarantine classes not on it.
  Extending Nippy directly (as shown below) avoids this issue entirely.


### Example: a custom model type

Suppose we have a record that wraps model weights. Out of the box,
Nippy can freeze records whose fields are all serializable — but
let's say our record contains a Java array or another type that
Nippy doesn't handle natively. We extend freeze and thaw explicitly:


::: {.sourceClojure}
```clojure
(defrecord MyModel [weights bias])
```
:::



::: {.sourceClojure}
```clojure
(nippy/extend-freeze MyModel :my-model
                     [x data-output]
                     (nippy/freeze-to-out! data-output (:weights x))
                     (nippy/freeze-to-out! data-output (:bias x)))
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



::: {.sourceClojure}
```clojure
(do (nippy/extend-thaw :my-model
                       [data-input]
                       (->MyModel (nippy/thaw-from-in! data-input)
                                  (nippy/thaw-from-in! data-input)))
    :done)
```
:::



::: {.printedClojure}
```clojure
:done

```
:::


We can verify the round-trip works:


::: {.sourceClojure}
```clojure
(def original (->MyModel [0.5 -0.3 1.2] 0.1))
```
:::



::: {.sourceClojure}
```clojure
(= original (nippy/thaw (nippy/freeze original)))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


Now caching a function that returns a `MyModel` works seamlessly:


::: {.sourceClojure}
```clojure
(defn train-my-model [data]
  (->MyModel (mapv #(* % 0.01) data) 0.42))
```
:::



::: {.sourceClojure}
```clojure
(let [result (deref (pocket/cached #'train-my-model [10 20 30]))]
  result)
```
:::



::: {.callout-note}
## OUT
```
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/train-my-model
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/ac/(pocket-book.extending-pocket_train-my-model [10 20 30])

```
:::



::: {.printedClojure}
```clojure
{:weights [0.1 0.2 0.3], :bias 0.42}

```
:::


See the [Nippy documentation](https://github.com/taoensso/nippy#custom-types)
for more details.


## Cleanup


::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
[nREPL-session-da935d57-d44a-48ad-9272-3a3413aeb98c] INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-extending", :existed true}

```
:::



```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/scicloj/pocket/blob/master/notebooks/pocket_book/extending_pocket.clj">notebooks/pocket_book/extending_pocket.clj</a></small></small></pre></div>
```