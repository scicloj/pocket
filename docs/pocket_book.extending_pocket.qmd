---
format:
  html:
    toc: true
    toc-depth: 4
    theme: [cosmo, notebooks/custom.scss]
    toc-expand: 2
    number-depth: 1
    filters: [notebooks/collapse-callouts.lua]

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script>

# Extending Pocket

**Last modified: 2026-02-08**


::: {.sourceClojure}
```clojure
(ns pocket-book.extending-pocket
  (:require
   ;; Logging setup for this chapter (see Logging chapter):
   [pocket-book.logging]
   ;; Pocket API:
   [scicloj.pocket :as pocket]
   ;; Annotating kinds of visualizations:
   [scicloj.kindly.v4.kind :as kind]
   ;; For the dataset identity example:
   [tablecloth.api :as tc]
   [tech.v3.dataset.modelling :as ds-mod]))
```
:::



## Setup


::: {.sourceClojure}
```clojure
(def cache-dir "/tmp/pocket-extending")
```
:::



::: {.sourceClojure}
```clojure
(pocket/set-base-cache-dir! cache-dir)
```
:::



::: {.callout-note}
## OUT
```
13:37:20.412 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-extending

```
:::



::: {.printedClojure}
```clojure
"/tmp/pocket-extending"

```
:::



::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
13:37:20.413 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-extending", :existed false}

```
:::



## The `PIdentifiable` protocol

Pocket derives cache keys from the **identity** of the function
and its arguments. The `PIdentifiable` protocol controls how
each value contributes to the cache key:


::: {.sourceClojure}
```clojure
(kind/doc #'pocket/->id)
```
:::


### `->id`
`[x]`

Return a cache key representation of a value.
   Dispatches via the `PIdentifiable` protocol.


## Default behaviors

Pocket provides default implementations for common types:

A var's identity is its fully-qualified name:


::: {.sourceClojure}
```clojure
(pocket/->id #'clojure.core/map)
```
:::



::: {.printedClojure}
```clojure
clojure.core/map

```
:::


A map's identity is itself (keys are deep-sorted later for stable cache paths):


::: {.sourceClojure}
```clojure
(pocket/->id {:b 2 :a 1})
```
:::



::: {.printedClojure}
```clojure
{:b 2, :a 1}

```
:::


A `Cached` object's identity captures the full computation graph:


::: {.sourceClojure}
```clojure
(defn add [x y] (+ x y))
```
:::



::: {.sourceClojure}
```clojure
(pocket/->id (pocket/cached #'add 1 2))
```
:::



::: {.printedClojure}
```clojure
(pocket-book.extending-pocket/add 1 2)

```
:::


`nil` is handled:


::: {.sourceClojure}
```clojure
(pocket/->id nil)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



## Built-in dataset support

Pocket recognizes
[tech.ml.dataset](https://github.com/techascent/tech.ml.dataset)
datasets (the type behind tablecloth) and derives their identity
from the actual column data and metadata — including annotations
like inference targets.

A dataset's identity is a map of column names to
`{:data [...] :meta {...}}`:


::: {.sourceClojure}
```clojure
(def example-ds
  (-> (tc/dataset {:x (range 30) :y (range 30)})
      (ds-mod/set-inference-target :y)))
```
:::



::: {.sourceClojure}
```clojure
(pocket/->id example-ds)
```
:::



::: {.printedClojure}
```clojure
{:x
 {:data
  [0
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   19
   20
   21
   22
   23
   24
   25
   26
   27
   28
   29],
  :meta {:name :x, :datatype :int64, :n-elems 30}},
 :y
 {:data
  [0
   1
   2
   3
   4
   5
   6
   7
   8
   9
   10
   11
   12
   13
   14
   15
   16
   17
   18
   19
   20
   21
   22
   23
   24
   25
   26
   27
   28
   29],
  :meta
  {:name :y, :datatype :int64, :n-elems 30, :inference-target? true}}}

```
:::


Two datasets with identical content produce the same identity,
even when the default `toString` representation would truncate
rows:


::: {.sourceClojure}
```clojure
(def ds-a (tc/dataset {:x (range 30) :y (range 30)}))
```
:::



::: {.sourceClojure}
```clojure
(def ds-b (tc/dataset {:x (range 30) :y (range 30)}))
```
:::



::: {.sourceClojure}
```clojure
(= (pocket/->id ds-a) (pocket/->id ds-b))
```
:::



::: {.printedClojure}
```clojure
true

```
:::


Datasets with different content produce different identities,
even when the difference falls in rows that `toString` would elide:


::: {.sourceClojure}
```clojure
(def ds-c (tc/dataset {:x (range 30)
                       :y (concat (range 15) [999] (range 16 30))}))
```
:::



::: {.sourceClojure}
```clojure
(= (pocket/->id ds-a) (pocket/->id ds-c))
```
:::



::: {.printedClojure}
```clojure
false

```
:::


This means caching functions that take datasets as arguments
(like `ml/train`) works correctly regardless of dataset size.


## Extending for custom types

If you have domain-specific types, you can control how they
appear in cache keys by extending `PIdentifiable`. This is
useful when the default behavior (which uses the object itself)
doesn't produce stable or meaningful cache keys.

For example, suppose you have a record representing a dataset
reference:


::: {.sourceClojure}
```clojure
(defrecord DatasetRef [source version])
```
:::


Without extending the protocol, a `DatasetRef` would be treated
as a plain map — its identity would be something like
`{:source "census", :version 3}`, which works but isn't very
readable in cache directory names.

Let's give it a concise, meaningful identity:


::: {.sourceClojure}
```clojure
(extend-protocol pocket/PIdentifiable
  DatasetRef
  (->id [this]
    (symbol (str (:source this) "-v" (:version this)))))
```
:::


Now the identity is a clean symbol:


::: {.sourceClojure}
```clojure
(pocket/->id (->DatasetRef "census" 3))
```
:::



::: {.printedClojure}
```clojure
census-v3

```
:::



## Using custom types in cached computations


::: {.sourceClojure}
```clojure
(defn analyze-dataset
  "Simulate analyzing a dataset."
  [dataset-ref opts]
  (println "  Analyzing" (:source dataset-ref) "v" (:version dataset-ref) "...")
  (Thread/sleep 200)
  {:source (:source dataset-ref)
   :version (:version dataset-ref)
   :rows 1000
   :method (:method opts)})
```
:::


The cache key now includes our custom identity:


::: {.sourceClojure}
```clojure
(def analysis
  (pocket/cached #'analyze-dataset
                 (->DatasetRef "census" 3)
                 {:method :regression}))
```
:::



::: {.sourceClojure}
```clojure
(pocket/->id analysis)
```
:::



::: {.printedClojure}
```clojure
(pocket-book.extending-pocket/analyze-dataset
 census-v3
 {:method :regression})

```
:::


First deref computes:


::: {.sourceClojure}
```clojure
(deref analysis)
```
:::



::: {.callout-note}
## OUT
```
13:37:20.437 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset
  Analyzing census v 3 ...
13:37:20.640 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/62/(pocket-book.extending-pocket_analyze-dataset census-v3 {:method :regression})

```
:::



::: {.printedClojure}
```clojure
{:source "census", :version 3, :rows 1000, :method :regression}

```
:::


Second deref loads from cache:


::: {.sourceClojure}
```clojure
(deref analysis)
```
:::



::: {.printedClojure}
```clojure
{:source "census", :version 3, :rows 1000, :method :regression}

```
:::


A different version creates a different cache entry:


::: {.sourceClojure}
```clojure
(deref (pocket/cached #'analyze-dataset
                      (->DatasetRef "census" 4)
                      {:method :regression}))
```
:::



::: {.callout-note}
## OUT
```
13:37:20.654 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.extending-pocket/analyze-dataset
  Analyzing census v 4 ...
13:37:20.856 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-extending/f6/(pocket-book.extending-pocket_analyze-dataset census-v4 {:method :regression})

```
:::



::: {.printedClojure}
```clojure
{:source "census", :version 4, :rows 1000, :method :regression}

```
:::



## What's on disk?

The cache directory names reflect our custom identities:


::: {.sourceClojure}
```clojure
(pocket/dir-tree)
```
:::



::: {.sourceClojure}
```clojure
pocket-extending
├── 62
│   └── (pocket-book.extending-pocket_analyze-dataset census-v3 {:method :regression})
│       ├── meta.edn
│       └── value.nippy
└── f6
    └── (pocket-book.extending-pocket_analyze-dataset census-v4 {:method :regression})
        ├── meta.edn
        └── value.nippy

```
:::



## Guidelines

When extending `PIdentifiable`:


- **Return stable values.** The identity must be the same across
  JVM sessions for the same logical input. Avoid including
  timestamps, random values, or object addresses.


- **Return distinct values.** Two logically different inputs must
  produce different identities. If they don't, Pocket will treat
  them as the same computation and return stale results.


- **Keep it readable.** The identity becomes part of the cache
  directory name. Symbols and short strings work well.


- **Prefer symbols or keywords** over complex nested structures.
  They produce clean, short directory names.


- **Records and plain maps can collide.** A record like
  `(->DatasetRef "census" 3)` and a plain map
  `{:source "census" :version 3}` produce the same default cache
  key (both are maps with the same keys). If you use records as
  cache arguments, extend `PIdentifiable` to give them a distinct
  identity — as shown above.


## Custom Nippy serialization

Pocket uses [Nippy](https://github.com/taoensso/nippy) for fast
binary serialization. Most Clojure data structures and many Java
objects serialize automatically. However, if you cache values
containing custom types, you may need to extend Nippy.

Common types that work out of the box:


- All Clojure collections (vectors, maps, sets, lists)
- Primitives, strings, keywords, symbols
- Java Date, UUID, BigDecimal, BigInteger
- Records and deftypes (if all fields are serializable)
- [Tribuo](https://github.com/scicloj/scicloj.ml.tribuo) ML models
- [tech.ml.dataset](https://github.com/techascent/tech.ml.dataset) datasets

Types that require extension:


- Objects with unserializable fields (e.g., open file handles,
  database connections, thread pools)

- Custom Java classes from external libraries (unless they
  implement `Serializable`)

To extend Nippy for a custom type, use `nippy/extend-freeze` and
`nippy/extend-thaw`:

```clojure
(require '[taoensso.nippy :as nippy])

(defrecord MyModel [weights bias])

(nippy/extend-freeze MyModel :my-model
  [x data-output]
  (nippy/freeze-to-out! data-output (:weights x))
  (nippy/freeze-to-out! data-output (:bias x)))

(nippy/extend-thaw :my-model
  [data-input]
  (->MyModel (nippy/thaw-from-in! data-input)
             (nippy/thaw-from-in! data-input)))
```

See the [Nippy documentation](https://github.com/taoensso/nippy#custom-types)
for more details.


## Cleanup


::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
13:37:20.862 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-extending

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-extending", :existed true}

```
:::



```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/scicloj/pocket/blob/master/notebooks/pocket_book/extending_pocket.clj">notebooks/pocket_book/extending_pocket.clj</a></small></small></pre></div>
```