---
format:
  html:
    toc: true
    toc-depth: 4
    theme: [cosmo, notebooks/custom.scss]
    toc-expand: 2
    number-depth: 1
    filters: [notebooks/collapse-callouts.lua]

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script><script src="https://cdn.jsdelivr.net/npm/mermaid@11.10.1/dist/mermaid.min.js" type="text/javascript"></script>

# Recursive Caching in Pipelines

**Last modified: 2026-02-08**

When you pass a `Cached` value as an argument to another cached function,
Pocket handles this recursively. The cache key for the outer computation
is derived from the **identity** of the inner computation (its function
name and arguments), not from its result. This means the entire pipeline's
cache key captures the full [computation graph](https://en.wikipedia.org/wiki/Dataflow_programming).

Pocket automatically derefs any `Cached` arguments before calling the
function, so pipeline functions receive plain values and don't need
any special handling.


## Setup


::: {.sourceClojure}
```clojure
(ns pocket-book.recursive-caching-in-pipelines
  (:require
   ;; Logging setup for this chapter (see Logging chapter):
   [pocket-book.logging]
   ;; Pocket API:
   [scicloj.pocket :as pocket]
   ;; Annotating kinds of visualizations:
   [scicloj.kindly.v4.kind :as kind]
   ;; String utilities:
   [clojure.string :as str]))
```
:::



::: {.sourceClojure}
```clojure
(def cache-dir "/tmp/pocket-demo-pipelines")
```
:::



::: {.sourceClojure}
```clojure
(pocket/set-base-cache-dir! cache-dir)
```
:::



::: {.callout-note}
## OUT
```
21:43:52.591 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo-pipelines

```
:::



::: {.printedClojure}
```clojure
"/tmp/pocket-demo-pipelines"

```
:::



::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
21:43:52.591 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-pipelines

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-demo-pipelines", :existed false}

```
:::



## A three-step pipeline

We'll build a simple data science pipeline with three stages:
load data, preprocess it, and train a model. Each stage is
wrapped with `caching-fn` so every call returns a `Cached` object.
Passing one `Cached` result into the next stage is what makes
the caching recursive.


```{=html}
<div class="mermaid">flowchart LR
    LD[load-dataset] --> PP[preprocess]
    PP --> TM[train-model]</div>
```



## Pipeline functions


::: {.sourceClojure}
```clojure
(defn load-dataset [path]
  (println "Loading dataset from" path "...")
  (Thread/sleep 300)
  {:data [1 2 3 4 5] :source path})
```
:::



::: {.sourceClojure}
```clojure
(defn preprocess [data opts]
  (println "Preprocessing with options:" opts)
  (Thread/sleep 300)
  (update data :data #(map (fn [x] (* x (:scale opts))) %)))
```
:::



::: {.sourceClojure}
```clojure
(defn train-model [data params]
  (println "Training model with params:" params)
  (Thread/sleep 300)
  {:model :trained :accuracy 0.95 :data data})
```
:::


Wrap each function with `caching-fn` so every call returns a `Cached` object:


::: {.sourceClojure}
```clojure
(def load-dataset* (pocket/caching-fn #'load-dataset))
```
:::



::: {.sourceClojure}
```clojure
(def preprocess* (pocket/caching-fn #'preprocess))
```
:::



::: {.sourceClojure}
```clojure
(def train-model* (pocket/caching-fn #'train-model))
```
:::



## Running the pipeline

Chain cached computations in a pipeline:

First pipeline run:


::: {.sourceClojure}
```clojure
(time
 (-> "data/raw.csv"
     (load-dataset*)
     (preprocess* {:scale 2})
     (train-model* {:epochs 100})
     deref
     (select-keys [:model :accuracy])))
```
:::



::: {.callout-note}
## OUT
```
21:43:52.597 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/train-model
21:43:52.597 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess
21:43:52.597 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset
Loading dataset from data/raw.csv ...
21:43:52.899 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/b8/(pocket-book.recursive-caching-in-pipelines_load-dataset "data_raw.csv")
Preprocessing with options: {:scale 2}
21:43:53.201 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/85/(pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset "data_raw.csv") {:scale 2})
Training model with params: {:epochs 100}
21:43:53.504 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/c9/(pocket-book.recursive-caching-in-pipelines_train-model (pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset "data_raw.csv") {:scale 2}) {:epochs 100})
"Elapsed time: 907.390788 msecs"

```
:::



::: {.printedClojure}
```clojure
{:model :trained, :accuracy 0.95}

```
:::


Run the same pipeline again — everything loads from cache:

Second pipeline run (all cached):


::: {.sourceClojure}
```clojure
(time
 (-> "data/raw.csv"
     (load-dataset*)
     (preprocess* {:scale 2})
     (train-model* {:epochs 100})
     deref
     (select-keys [:model :accuracy])))
```
:::



::: {.callout-note}
## OUT
```
"Elapsed time: 0.614904 msecs"

```
:::



::: {.printedClojure}
```clojure
{:model :trained, :accuracy 0.95}

```
:::


No log output above — the result was served entirely from the
in-memory cache, so no disk I/O or computation occurred.
Each step caches independently. If you change only the last step
(e.g., different training params), the upstream steps load from cache while
only the final step recomputes.


## Provenance in cache entries

The cache entries reveal the pipeline structure. Each entry's
identity encodes its full computation history — not just the
function name, but the nested identities of all its cached inputs.


::: {.sourceClojure}
```clojure
(->> (pocket/cache-entries)
     (mapv :id))
```
:::



::: {.printedClojure}
```clojure
["(pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\")"
 "(pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\") {:scale 2})"
 "(pocket-book.recursive-caching-in-pipelines/train-model (pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset \"data/raw.csv\") {:scale 2}) {:epochs 100})"]

```
:::



::: {.sourceClojure}
```clojure
(->> (pocket/cache-entries)
     (mapv :id)
     (str/join "\n")
     kind/code)
```
:::



::: {.sourceClojure}
```clojure
(pocket-book.recursive-caching-in-pipelines/load-dataset "data/raw.csv")
(pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset "data/raw.csv") {:scale 2})
(pocket-book.recursive-caching-in-pipelines/train-model (pocket-book.recursive-caching-in-pipelines/preprocess (pocket-book.recursive-caching-in-pipelines/load-dataset "data/raw.csv") {:scale 2}) {:epochs 100})
```
:::


The inner step appears as a literal sub-expression in the outer
step's identity. This is how Pocket tracks provenance: the cache
key for `train-model` records that its input came from
`preprocess`, which in turn came from `load-dataset`.

This happens automatically when you pass `Cached` objects (without
derefing) from one cached step to the next. If you deref early
with `@` (or `deref`), the downstream step sees a plain value and the
provenance link is lost — the cache key is based on the value's
hash instead. Both patterns work; the choice is whether you need
traceability.

For a fuller example with branching dependencies, see the
[Real-World Walkthrough](pocket_book.real_world_walkthrough.html).


## Inspecting the DAG

Pocket provides three functions for DAG introspection:


- `origin-story` — nested tree with `:ref` pointers for shared nodes
- `origin-story-graph` — flat `{:nodes ... :edges ...}` for graph algorithms
- `origin-story-mermaid` — Mermaid flowchart string for visualization

Build the pipeline keeping the intermediate `Cached` objects:


::: {.sourceClojure}
```clojure
(def data-c (load-dataset* "data/experiment.csv"))
```
:::



::: {.sourceClojure}
```clojure
(def preprocessed-c (preprocess* data-c {:scale 2}))
```
:::



::: {.sourceClojure}
```clojure
(def model-c (train-model* preprocessed-c {:epochs 100}))
```
:::



### `origin-story` — tree structure

Returns a nested map where each cached step is `{:fn <var> :args [...] :id <string>}`.
Plain arguments become `{:value ...}` leaves. If a step has been computed,
`:value` is included.

Before any computation:


::: {.sourceClojure}
```clojure
(pocket/origin-story model-c)
```
:::



::: {.printedClojure}
```clojure
{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,
 :args
 [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,
   :args
   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,
     :args [{:value "data/experiment.csv"}],
     :id "c3"}
    {:value {:scale 2}}],
   :id "c2"}
  {:value {:epochs 100}}],
 :id "c1"}

```
:::


No `:value` keys yet. Now trigger computation:


::: {.sourceClojure}
```clojure
(deref model-c)
```
:::



::: {.callout-note}
## OUT
```
21:43:53.515 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/train-model
21:43:53.515 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/preprocess
21:43:53.515 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.recursive-caching-in-pipelines/load-dataset
Loading dataset from data/experiment.csv ...
21:43:53.817 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/cd/(pocket-book.recursive-caching-in-pipelines_load-dataset "data_experiment.csv")
Preprocessing with options: {:scale 2}
21:43:54.119 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/f8/(pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset "data_experiment.csv") {:scale 2})
Training model with params: {:epochs 100}
21:43:54.420 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo-pipelines/9e/(pocket-book.recursive-caching-in-pipelines_train-model (pocket-book.recursive-caching-in-pipelines_preprocess (pocket-book.recursive-caching-in-pipelines_load-dataset "data_experiment.csv") {:scale 2}) {:epochs 100})

```
:::



::: {.printedClojure}
```clojure
{:model :trained,
 :accuracy 0.95,
 :data {:data (2 4 6 8 10), :source "data/experiment.csv"}}

```
:::


After deref, every node includes its `:value`:


::: {.sourceClojure}
```clojure
(pocket/origin-story model-c)
```
:::



::: {.printedClojure}
```clojure
{:fn #'pocket-book.recursive-caching-in-pipelines/train-model,
 :args
 [{:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,
   :args
   [{:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,
     :args [{:value "data/experiment.csv"}],
     :id "c3",
     :value {:data [1 2 3 4 5], :source "data/experiment.csv"}}
    {:value {:scale 2}}],
   :id "c2",
   :value {:data (2 4 6 8 10), :source "data/experiment.csv"}}
  {:value {:epochs 100}}],
 :id "c1",
 :value
 {:model :trained,
  :accuracy 0.95,
  :data {:data (2 4 6 8 10), :source "data/experiment.csv"}}}

```
:::


When the same `Cached` instance appears multiple times (diamond pattern),
subsequent occurrences are `{:ref <id>}` pointing to the first.


### `origin-story-graph` — flat graph

Returns `{:nodes {<id> <node-map>} :edges [[<from> <to>] ...]}`.
Useful for graph algorithms or custom rendering.


::: {.sourceClojure}
```clojure
(pocket/origin-story-graph model-c)
```
:::



::: {.printedClojure}
```clojure
{:nodes
 {"c1"
  {:fn #'pocket-book.recursive-caching-in-pipelines/train-model,
   :value
   {:model :trained,
    :accuracy 0.95,
    :data {:data (2 4 6 8 10), :source "data/experiment.csv"}}},
  "c2"
  {:fn #'pocket-book.recursive-caching-in-pipelines/preprocess,
   :value {:data (2 4 6 8 10), :source "data/experiment.csv"}},
  "c3"
  {:fn #'pocket-book.recursive-caching-in-pipelines/load-dataset,
   :value {:data [1 2 3 4 5], :source "data/experiment.csv"}},
  "v4" {:value "data/experiment.csv"},
  "v5" {:value {:scale 2}},
  "v6" {:value {:epochs 100}}},
 :edges [["c1" "c2"] ["c2" "c3"] ["c3" "v4"] ["c2" "v5"] ["c1" "v6"]]}

```
:::



### `origin-story-mermaid` — visualization

Returns a Mermaid flowchart string. Arrows show data flow direction
(from inputs toward the final result). It returns a kindly value that renders directly.


::: {.sourceClojure}
```clojure
(pocket/origin-story-mermaid model-c)
```
:::



```{=html}
<div class="mermaid">flowchart TD
  n0["train-model"]
  n1["preprocess"]
  n2["load-dataset"]
  n3[/"'data/experiment.csv'"/]
  n3 --> n2
  n2 --> n1
  n4[/"{:scale 2}"/]
  n4 --> n1
  n1 --> n0
  n5[/"{:epochs 100}"/]
  n5 --> n0</div>
```



## Cleanup


::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
21:43:54.425 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo-pipelines

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-demo-pipelines", :existed true}

```
:::



```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/scicloj/pocket/blob/master/notebooks/pocket_book/recursive_caching_in_pipelines.clj">notebooks/pocket_book/recursive_caching_in_pipelines.clj</a></small></small></pre></div>
```