---
format:
  html:
    toc: true
    toc-depth: 4
    theme: [cosmo, notebooks/custom.scss]
    toc-expand: 2
    number-depth: 1
    filters: [notebooks/collapse-callouts.lua]

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="https://code.jquery.com/jquery-3.6.0.min.js" type="text/javascript"></script><script src="https://code.jquery.com/ui/1.13.1/jquery-ui.min.js" type="text/javascript"></script>

# Getting Started

**Last modified: 2026-02-08**

[Pocket](https://github.com/scicloj/pocket) is a Clojure library for
filesystem-based caching of expensive computations. It persists results
to disk so they survive JVM restarts. Cache keys are derived from the
function identity and its arguments, so the same computation always
maps to the same cache entry.


## Setup


::: {.sourceClojure}
```clojure
(ns pocket-book.getting-started
  (:require
   ;; Pocket API:
   [scicloj.pocket :as pocket]
   ;; Annotating kinds of visualizations:
   [scicloj.kindly.v4.kind :as kind]
   ;; Logging setup for this chapter (see Logging chapter):
   [pocket-book.logging]))
```
:::


First, we set up a cache directory and define an expensive computation:


::: {.sourceClojure}
```clojure
(def cache-dir "/tmp/pocket-demo")
```
:::



::: {.sourceClojure}
```clojure
(pocket/set-base-cache-dir! cache-dir)
```
:::



::: {.callout-note}
## OUT
```
13:37:07.750 INFO scicloj.pocket - Cache dir set to: /tmp/pocket-demo

```
:::



::: {.printedClojure}
```clojure
"/tmp/pocket-demo"

```
:::


Start fresh so the examples below run from a clean slate:


::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
13:37:07.751 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-demo", :existed false}

```
:::



::: {.sourceClojure}
```clojure
(defn expensive-calculation
  "Simulates an expensive computation"
  [x y]
  (println (str "Computing " x " + " y " (this is expensive!)"))
  (Thread/sleep 400)
  (+ x y))
```
:::



## Background: deref in Clojure

In Clojure, [`deref`](https://clojure.org/reference/concurrency#deref)
extracts a value from a reference type. It can be written as `(deref x)`
or with the shorthand reader macro `@x` — both are equivalent.
Pocket's `cached` returns a `Cached` object that implements `IDeref`,
so you use `@` (or `deref`) to trigger the computation and retrieve
the result.


## Creating a cached computation

`cached` creates a [lazy](https://en.wikipedia.org/wiki/Lazy_evaluation) cached computation.
It returns a `Cached` object — the computation won't run until we deref it:


::: {.sourceClojure}
```clojure
(def cached-result
  (pocket/cached #'expensive-calculation 10 20))
```
:::



::: {.sourceClojure}
```clojure
(type cached-result)
```
:::



::: {.printedClojure}
```clojure
scicloj.pocket.impl.cache.Cached

```
:::


First deref (computes and caches):


::: {.sourceClojure}
```clojure
(time @cached-result)
```
:::



::: {.callout-note}
## OUT
```
13:37:07.755 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation
Computing 10 + 20 (this is expensive!)
13:37:08.157 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo/fb/(pocket-book.getting-started_expensive-calculation 10 20)
"Elapsed time: 402.425137 msecs"

```
:::



::: {.printedClojure}
```clojure
30

```
:::


Second deref (loaded from cache, instant):


::: {.sourceClojure}
```clojure
(time @cached-result)
```
:::



::: {.callout-note}
## OUT
```
"Elapsed time: 0.266807 msecs"

```
:::



::: {.printedClojure}
```clojure
30

```
:::



## Wrapping functions with `caching-fn`

For convenience, `caching-fn` wraps a function so that every call
returns a `Cached` object:


::: {.sourceClojure}
```clojure
(def cached-expensive
  (pocket/caching-fn #'expensive-calculation))
```
:::


First call:


::: {.sourceClojure}
```clojure
(time @(cached-expensive 5 15))
```
:::



::: {.callout-note}
## OUT
```
13:37:08.163 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation
Computing 5 + 15 (this is expensive!)
13:37:08.566 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo/c4/(pocket-book.getting-started_expensive-calculation 5 15)
"Elapsed time: 402.622979 msecs"

```
:::



::: {.printedClojure}
```clojure
20

```
:::


Same args — cache hit:


::: {.sourceClojure}
```clojure
(time @(cached-expensive 5 15))
```
:::



::: {.callout-note}
## OUT
```
"Elapsed time: 0.408141 msecs"

```
:::



::: {.printedClojure}
```clojure
20

```
:::


Different args — new computation:


::: {.sourceClojure}
```clojure
(time @(cached-expensive 7 8))
```
:::



::: {.callout-note}
## OUT
```
13:37:08.571 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/expensive-calculation
Computing 7 + 8 (this is expensive!)
13:37:08.972 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo/a2/(pocket-book.getting-started_expensive-calculation 7 8)
"Elapsed time: 402.520248 msecs"

```
:::



::: {.printedClojure}
```clojure
15

```
:::



## Nil handling

Pocket properly handles `nil` values. Since the cache uses files on disk,
it needs to distinguish "never computed" from "computed and got `nil`".
It does this with a special marker file:


::: {.sourceClojure}
```clojure
(defn returns-nil [] nil)
```
:::



::: {.sourceClojure}
```clojure
(def nil-result (pocket/cached #'returns-nil))
```
:::


Cached nil value:


::: {.sourceClojure}
```clojure
(deref nil-result)
```
:::



::: {.callout-note}
## OUT
```
13:37:08.976 INFO scicloj.pocket.impl.cache - Cache miss, computing: pocket-book.getting-started/returns-nil
13:37:08.977 DEBUG scicloj.pocket.impl.cache - Cache write: /tmp/pocket-demo/7a/(pocket-book.getting-started_returns-nil)

```
:::



::: {.printedClojure}
```clojure
nil

```
:::


Loading nil from cache:


::: {.sourceClojure}
```clojure
(deref nil-result)
```
:::



::: {.printedClojure}
```clojure
nil

```
:::



## Important: use vars or keywords for functions

Always pass functions as **vars** (`#'fn-name`) or **keywords**,
not as bare function objects. Vars have stable names that produce
consistent cache keys across sessions. Keywords are useful for
extracting from cached maps (e.g., `(cached :train split-c)`).
Pocket throws an error if you pass a bare function:

```clojure
;; ✅ (pocket/cached #'my-function args)
;; ✅ (pocket/cached :train cached-map)
;; ❌ (pocket/cached my-function args)
```
See the [Usage Practices](pocket_book.usage_practices.html) chapter
for a detailed explanation and more best practices.


## Next steps


- [Configuration](pocket_book.configuration.html) — cache directory,
  in-memory eviction policies, `pocket.edn`

- [Recursive Caching in Pipelines](pocket_book.recursive_caching_in_pipelines.html) —
  chaining cached computations

- [Usage Practices](pocket_book.usage_practices.html) — invalidation
  strategies, testing, serialization, and more


## Cleanup


::: {.sourceClojure}
```clojure
(pocket/cleanup!)
```
:::



::: {.callout-note}
## OUT
```
13:37:08.981 INFO scicloj.pocket - Cache cleanup: /tmp/pocket-demo

```
:::



::: {.printedClojure}
```clojure
{:dir "/tmp/pocket-demo", :existed true}

```
:::



```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/scicloj/pocket/blob/master/notebooks/pocket_book/getting_started.clj">notebooks/pocket_book/getting_started.clj</a></small></small></pre></div>
```